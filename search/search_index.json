{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Finbot Documentation","text":"<p>Welcome to the Finbot documentation! Finbot is a comprehensive financial data collection, simulation, and backtesting platform designed for quantitative analysis and portfolio optimization.</p>"},{"location":"#overview","title":"Overview","text":"<p>Finbot consolidates three key areas of quantitative finance:</p> <ul> <li>Data Collection: Automated fetching from Yahoo Finance, FRED, Alpha Vantage, Google Finance, and more</li> <li>Simulation: Fund simulators (leveraged ETFs), bond ladders, Monte Carlo risk analysis</li> <li>Backtesting: 10 trading strategies with comprehensive performance metrics using Backtrader</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#comprehensive-backtesting-engine","title":"\ud83d\udcca Comprehensive Backtesting Engine","text":"<ul> <li>10 built-in strategies: Rebalance, NoRebalance, SMA Crossovers, MACD, Dip Buying, Hybrid strategies</li> <li>Performance metrics: CAGR, Sharpe ratio, Sortino ratio, Max drawdown, Win rate, Kelly criterion</li> <li>Powered by Backtrader: Industry-standard backtesting framework with custom analyzers</li> </ul>"},{"location":"#advanced-simulation-systems","title":"\ud83c\udfaf Advanced Simulation Systems","text":"<ul> <li>Fund Simulator: Simulate leveraged ETFs with fees, borrowing costs, and tracking error</li> <li>Bond Ladder Simulator: Model bond portfolios with yield curves and maturity rolling</li> <li>Monte Carlo Simulator: Portfolio risk analysis with probability distributions and VaR</li> <li>Specific fund implementations: SPY, SSO, UPRO, QQQ, TQQQ, TLT, TMF, and more</li> </ul>"},{"location":"#portfolio-optimization","title":"\ud83d\udd27 Portfolio Optimization","text":"<ul> <li>DCA Optimizer: Grid search across asset ratios, durations, and purchase intervals</li> <li>Rebalance Optimizer: Gradient descent for optimal portfolio rebalancing</li> <li>Multi-metric optimization: CAGR, Sharpe, Sortino, Max drawdown</li> </ul>"},{"location":"#data-collection-infrastructure","title":"\ud83d\udcc8 Data Collection Infrastructure","text":"<ul> <li>Multiple data sources: Yahoo Finance, FRED, Alpha Vantage, Google Finance, BLS, MSCI</li> <li>Automatic caching: Zstandard-compressed parquet files for performance</li> <li>Daily update pipeline: Automated data refresh with retry logic and error handling</li> </ul>"},{"location":"#modern-infrastructure","title":"\ud83d\udee0\ufe0f Modern Infrastructure","text":"<ul> <li>CLI interface: <code>finbot simulate</code>, <code>finbot backtest</code>, <code>finbot optimize</code>, <code>finbot update</code></li> <li>Dynaconf configuration: Environment-aware YAML config (development, production)</li> <li>Queue-based logging: Non-blocking async logging with JSON output</li> <li>Comprehensive utilities: 160+ utility functions across 15 categories</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install with uv\nuv sync\n\n# Set environment\nexport DYNACONF_ENV=development\n\n# Run tests\nuv run pytest\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code># Simulate a leveraged fund\nfinbot simulate --fund UPRO --start 2010-01-01 --plot\n\n# Backtest a strategy\nfinbot backtest --strategy Rebalance --asset SPY,TLT --plot\n\n# Optimize DCA portfolio\nfinbot optimize --method dca --assets SPY,TQQQ --plot\n\n# Update all data\nfinbot update\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<pre><code>from finbot.services.simulation import fund_simulator\nfrom finbot.services.backtesting import BacktestRunner\nfrom finbot.services.optimization import dca_optimizer\n\n# Simulate UPRO fund\nupro_sim = fund_simulator.simulate_fund('UPRO', start_date='2010-01-01')\n\n# Run backtest\nrunner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy_data, 'TLT': tlt_data},\n    strategy_params={'rebalance_days': 30}\n)\nresults = runner.run()\n\n# Optimize DCA strategy\noptimal_results = dca_optimizer(\n    price_history=combined_df,\n    ratio_linspace=(0.5, 0.95, 10),\n    dca_duration_days=365 * 5,\n    trial_duration_days=365 * 10\n)\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>User Guide: Installation, configuration, and usage tutorials</li> <li>API Reference: Detailed API documentation for all modules</li> <li>Research: Published research findings and analysis</li> <li>Contributing: Guidelines for contributors</li> </ul>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository: github.com/jerdaw/finbot</li> <li>Issue Tracker: GitHub Issues</li> <li>Changelog: CHANGELOG.md</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;=3.11, &lt;3.15</li> <li>uv for dependency management</li> <li>Optional: API keys for data sources (Alpha Vantage, NASDAQ Data Link, BLS, Google Finance)</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Finbot are documented here.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>For the full changelog, see CHANGELOG.md in the repository.</p>"},{"location":"changelog/#100-2026-02-10","title":"[1.0.0] - 2026-02-10","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>CLI interface with 4 commands (simulate, backtest, optimize, update)</li> <li>Comprehensive test suite (80 tests, 444% increase)</li> <li>5 example Jupyter notebooks</li> <li>3 research documents (~50 pages)</li> <li>Documentation (README expansion, utils overview, ADRs)</li> <li>Performance benchmarks</li> <li>CI/CD pipeline with 8 checks</li> <li>Dependabot configuration</li> <li>Makefile with 14 targets</li> <li>Pre-commit hooks (17 total)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Consolidated dual config system to Dynaconf only</li> <li>Refactored fund simulations to data-driven config</li> <li>Updated ruff to v0.11.13 with expanded rules</li> <li>Modernized pyproject.toml to PEP 621</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Logger code duplication</li> <li>Import-time side effects in constants</li> <li>Dangerous error handling (bare except, assert)</li> <li>103 lint violations \u2192 0</li> </ul>"},{"location":"changelog/#010-2026-02-09","title":"[0.1.0] - 2026-02-09","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial consolidated release</li> <li>Merged three repos (finbot, bb, backbetter)</li> <li>10 backtesting strategies</li> <li>Fund, bond ladder, and Monte Carlo simulators</li> <li>160+ utility functions</li> <li>Comprehensive data collection</li> <li>CI workflow</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Replaced numba with vectorized NumPy</li> <li>Replaced pickle with parquet</li> <li>Lazy API key loading</li> </ul>"},{"location":"changelog/#project-lineage","title":"Project Lineage","text":"<p>Finbot consolidates work from three repositories:</p> <ul> <li>finbot (2021-2022): Original backtesting and simulation code</li> <li>bb (2023-2024): Data collection and utilities</li> <li>backbetter (2022): Enhanced backtesting features</li> </ul> <p>See ADR-001 for consolidation rationale.</p>"},{"location":"contributing/","title":"Contributing to Finbot","text":"<p>Thank you for your interest in contributing to Finbot! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install with dev dependencies\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n\n# Run tests\nuv run pytest\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":""},{"location":"contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<pre><code># Run all checks\nmake check\n\n# Individual checks\nmake lint      # Ruff linting\nmake format    # Ruff formatting\nmake type      # Mypy type checking\nmake security  # Bandit security scan\n</code></pre>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Automatic hooks run on every commit: - Trailing whitespace removal - YAML/JSON/TOML syntax validation - Python AST validation - Ruff linting and formatting - Line ending normalization (LF)</p> <p>Manual hooks (run on demand): <pre><code>uv run pre-commit run --hook-stage manual mypy\nuv run pre-commit run --hook-stage manual bandit\n</code></pre></p>"},{"location":"contributing/#testing","title":"Testing","text":"<pre><code># Run all tests\nmake test\n\n# Run with coverage\nmake test-cov\n\n# Run specific test\nuv run pytest tests/unit/test_finance_utils.py -v\n</code></pre>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Python version: 3.11+</li> <li>Line length: 120 characters</li> <li>Docstrings: Google style</li> <li>Type hints: Required for all functions</li> <li>Imports: Sorted with ruff/isort</li> <li>Code style: ruff format</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create feature branch (<code>git checkout -b feature/my-feature</code>)</li> <li>Make changes with tests</li> <li>Run <code>make check</code> and <code>make test</code></li> <li>Commit with descriptive message</li> <li>Push to your fork</li> <li>Create pull request</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow conventional commit format:</p> <pre><code>type(scope): brief description\n\nLonger description if needed.\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>test</code>, <code>refactor</code>, <code>perf</code>, <code>chore</code></p>"},{"location":"contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"contributing/#new-utility-functions","title":"New Utility Functions","text":"<ol> <li>Add function to appropriate <code>finbot/utils/</code> category</li> <li>Add comprehensive docstring (Google style)</li> <li>Add type hints</li> <li>Add unit tests</li> <li>Update category README if needed</li> </ol>"},{"location":"contributing/#new-strategies","title":"New Strategies","text":"<ol> <li>Create strategy in <code>finbot/services/backtesting/strategies/</code></li> <li>Inherit from <code>bt.Strategy</code></li> <li>Add comprehensive docstring</li> <li>Add to strategy registry</li> <li>Add tests</li> </ol>"},{"location":"contributing/#new-simulators","title":"New Simulators","text":"<ol> <li>Create simulator in <code>finbot/services/simulation/</code></li> <li>Use vectorized NumPy operations</li> <li>Add comprehensive docstring</li> <li>Add validation tests</li> <li>Add performance benchmark</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#module-docstrings","title":"Module Docstrings","text":"<p>All modules require comprehensive module-level docstrings:</p> <pre><code>\"\"\"Brief one-line description.\n\nDetailed description with:\n- Purpose\n- Typical usage examples\n- Key features\n- Use cases\n- Performance notes\n- Limitations\n- Dependencies\n- Related modules\n\"\"\"\n</code></pre>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<p>Update mkdocs documentation when adding public APIs:</p> <pre><code># Build documentation\nuv run mkdocs build\n\n# Serve locally\nuv run mkdocs serve\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Documentation: This site</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"api/","title":"API Reference Overview","text":"<p>This section provides comprehensive API documentation for Finbot's modules, automatically generated from inline docstrings.</p>"},{"location":"api/#package-structure","title":"Package Structure","text":"<p>Finbot is organized into three main areas:</p>"},{"location":"api/#services-finbotservices","title":"Services (<code>finbot/services/</code>)","text":"<p>High-level analysis and simulation services:</p> <ul> <li>Backtesting (<code>backtesting/</code>): Strategy backtesting engine powered by Backtrader</li> <li><code>BacktestRunner</code>: Main orchestrator for running backtests</li> <li><code>run_backtest</code>, <code>backtest_batch</code>: Single and parallel backtest execution</li> <li><code>compute_stats</code>: Performance metrics calculation</li> <li><code>strategies/</code>: 10 trading strategies</li> <li> <p><code>rebalance_optimizer</code>: Portfolio rebalancing optimization</p> </li> <li> <p>Simulation (<code>simulation/</code>): Financial instrument simulators</p> </li> <li><code>fund_simulator</code>: Simulate leveraged ETFs with fees and borrowing costs</li> <li><code>bond_ladder/</code>: Bond ladder construction and simulation</li> <li><code>monte_carlo/</code>: Monte Carlo risk analysis</li> <li><code>sim_specific_funds</code>: Pre-configured fund simulations (SPY, UPRO, TQQQ, etc.)</li> <li> <p><code>sim_specific_*_indexes</code>: Stock and bond index simulations</p> </li> <li> <p>Optimization (<code>optimization/</code>): Portfolio optimization tools</p> </li> <li><code>dca_optimizer</code>: Dollar-cost averaging strategy optimizer</li> <li><code>rebalance_optimizer</code>: Rebalance ratio optimizer (convenience import)</li> </ul>"},{"location":"api/#utilities-finbotutils","title":"Utilities (<code>finbot/utils/</code>)","text":"<p>160+ utility functions across 15 categories:</p> Category Count Purpose finance_utils 19 CGR, drawdown, periods, risk-free rate, price trends datetime_utils 23 Business dates, duration, conversions, time ranges pandas_utils 17 Save/load parquet, filtering, frequency detection data_collection_utils 40 Yahoo Finance, FRED, Alpha Vantage, BLS, Google Finance data_science_utils 37 Missing data, outliers, scaling, imputation file_utils 10 Text I/O with compression, staleness checking json_utils 4 JSON serialization with zstandard compression request_utils 2 HTTP client with retry logic and caching plotting_utils 1 Interactive plotly visualizations multithreading_utils 1 Optimal thread count calculation validation_utils 1 Parameter validation helpers vectorization_utils 1 Vectorization profiling class_utils 1 Singleton metaclasses dict_utils 1 Deterministic dictionary hashing function_utils 1 Logging decorators"},{"location":"api/#infrastructure","title":"Infrastructure","text":"<ul> <li>config/: Dynaconf-based configuration with lazy API key loading</li> <li>constants/: Application constants (paths, APIs, datetime, networking)</li> <li>libs/: Core libraries (API manager, queue-based logger)</li> </ul>"},{"location":"api/#navigation","title":"Navigation","text":"<p>Use the left sidebar to navigate to specific modules. Each page provides:</p> <ul> <li>Module overview and purpose</li> <li>Typical usage examples</li> <li>Full API documentation with signatures</li> <li>Parameter descriptions</li> <li>Return types</li> <li>Raises information</li> <li>Related modules</li> </ul>"},{"location":"api/#key-entry-points","title":"Key Entry Points","text":"Module Purpose Documentation <code>fund_simulator</code> Simulate leveraged funds Fund Simulator API <code>BacktestRunner</code> Run strategy backtests BacktestRunner API <code>dca_optimizer</code> Optimize DCA strategies DCA Optimizer API <code>monte_carlo_simulator</code> Portfolio risk analysis Monte Carlo API <code>finbot.cli</code> Command-line interface CLI Reference"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All services and utilities include type hints for parameters and return values. Type checking is performed using <code>mypy</code> with strict optional checking.</p>"},{"location":"api/#docstring-format","title":"Docstring Format","text":"<p>All modules use Google-style docstrings with the following sections:</p> <ul> <li>Module-level docstring with purpose, usage examples, and features</li> <li>Function/method docstrings with Args, Returns, Raises</li> <li>Class docstrings with attributes and methods</li> </ul>"},{"location":"api/#source-code","title":"Source Code","text":"<p>All API documentation pages include links to the source code on GitHub for reference.</p>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>The Finbot CLI provides command-line access to simulations, backtesting, optimization, data updates, and status monitoring.</p>"},{"location":"api/cli/#overview","title":"Overview","text":"<p>The CLI is built with Click and provides:</p> <ul> <li>5 main commands: simulate, backtest, optimize, update, status</li> <li>Streamlit dashboard: Launch interactive web interface</li> <li>Subcommands: Multiple simulation and optimization types</li> <li>Rich output: Colored, formatted console output</li> <li>Error handling: Graceful failures with helpful messages</li> </ul>"},{"location":"api/cli/#installation","title":"Installation","text":"<p>The CLI is installed automatically with finbot:</p> <pre><code>uv sync\n</code></pre>"},{"location":"api/cli/#global-options","title":"Global Options","text":"<pre><code>finbot --help\nfinbot --version\n</code></pre>"},{"location":"api/cli/#commands","title":"Commands","text":""},{"location":"api/cli/#cli-module","title":"CLI Module","text":"<p>Main CLI entry point and command definitions:</p>"},{"location":"api/cli/#finbot.cli.main","title":"finbot.cli.main","text":"<p>Main CLI entry point for Finbot.</p>"},{"location":"api/cli/#finbot.cli.main.cli","title":"cli","text":"<pre><code>cli(ctx: Context, verbose: bool) -&gt; None\n</code></pre> <p>Finbot - Financial simulation and backtesting platform.</p> <p>\b Available commands:   simulate   Run fund, bond, or Monte Carlo simulations   backtest   Execute strategy backtests   optimize   Run portfolio optimization (DCA, rebalance)   update     Run daily data update pipeline   status     Show data freshness and pipeline health   dashboard  Launch the Streamlit web dashboard</p> <p>\b Examples:   finbot simulate --fund UPRO --start 2020-01-01   finbot backtest --strategy Rebalance --asset SPY   finbot optimize --method dca --asset SPY   finbot update --dry-run   finbot dashboard --port 8501</p> Source code in <code>finbot/cli/main.py</code> <pre><code>@click.group()\n@click.version_option(version=\"1.0.0\", prog_name=\"finbot\")\n@click.option(\n    \"--verbose\",\n    \"-v\",\n    is_flag=True,\n    help=\"Enable verbose logging output\",\n)\n@click.pass_context\ndef cli(ctx: click.Context, verbose: bool) -&gt; None:\n    \"\"\"Finbot - Financial simulation and backtesting platform.\n\n    \\b\n    Available commands:\n      simulate   Run fund, bond, or Monte Carlo simulations\n      backtest   Execute strategy backtests\n      optimize   Run portfolio optimization (DCA, rebalance)\n      update     Run daily data update pipeline\n      status     Show data freshness and pipeline health\n      dashboard  Launch the Streamlit web dashboard\n\n    \\b\n    Examples:\n      finbot simulate --fund UPRO --start 2020-01-01\n      finbot backtest --strategy Rebalance --asset SPY\n      finbot optimize --method dca --asset SPY\n      finbot update --dry-run\n      finbot dashboard --port 8501\n    \"\"\"\n    # Store verbose flag in context for subcommands\n    ctx.ensure_object(dict)\n    ctx.obj[\"verbose\"] = verbose\n\n    if verbose:\n        logger.info(\"Verbose mode enabled\")\n</code></pre>"},{"location":"api/cli/#command-reference","title":"Command Reference","text":""},{"location":"api/cli/#1-simulate","title":"1. simulate","text":"<p>Run financial simulations (funds, indexes, bond ladder, Monte Carlo).</p>"},{"location":"api/cli/#subcommands","title":"Subcommands","text":""},{"location":"api/cli/#simulate-fund","title":"simulate fund","text":"<p>Simulate a specific fund:</p> <pre><code>finbot simulate fund UPRO --start 2010-01-01 --end 2024-01-01\n</code></pre> <p>Options: - <code>TICKER</code> (required): Fund ticker symbol (UPRO, TQQQ, TMF, etc.) - <code>--start DATE</code>: Start date (YYYY-MM-DD, default: 10 years ago) - <code>--end DATE</code>: End date (YYYY-MM-DD, default: today) - <code>--output PATH</code>: Save results to file (parquet format)</p> <p>Available funds: SPY, SSO, UPRO, QQQ, QLD, TQQQ, TLT, UBT, TMF, IEF, UST, TYD, SHY, NTSX</p>"},{"location":"api/cli/#simulate-index","title":"simulate index","text":"<p>Simulate a stock or bond index:</p> <pre><code>finbot simulate index sp500 --start 2010-01-01\n</code></pre> <p>Options: - <code>INDEX</code> (required): Index name (sp500, nasdaq100, treasury_20y, treasury_7y, treasury_1y) - <code>--start DATE</code>: Start date - <code>--end DATE</code>: End date - <code>--output PATH</code>: Save results to file</p> <p>Available indexes: - Stock: sp500, nasdaq100 - Bond: treasury_20y, treasury_7y, treasury_1y</p>"},{"location":"api/cli/#simulate-bond-ladder","title":"simulate bond-ladder","text":"<p>Simulate a bond ladder portfolio:</p> <pre><code>finbot simulate bond-ladder --investment 100000 --years 10 --start 2010-01-01\n</code></pre> <p>Options: - <code>--investment FLOAT</code>: Initial investment amount (default: 100000) - <code>--years INT</code>: Ladder duration in years (default: 10) - <code>--start DATE</code>: Start date (default: 10 years ago) - <code>--end DATE</code>: End date (default: today) - <code>--output PATH</code>: Save results to file</p>"},{"location":"api/cli/#simulate-monte-carlo","title":"simulate monte-carlo","text":"<p>Run Monte Carlo risk simulation:</p> <pre><code>finbot simulate monte-carlo --ticker SPY --trials 10000 --years 30\n</code></pre> <p>Options: - <code>--ticker TEXT</code>: Asset ticker symbol (default: SPY) - <code>--trials INT</code>: Number of simulation trials (default: 10000) - <code>--years INT</code>: Projection horizon in years (default: 30) - <code>--initial-investment FLOAT</code>: Starting amount (default: 100000) - <code>--annual-contribution FLOAT</code>: Yearly contribution (default: 0) - <code>--output PATH</code>: Save results to file</p>"},{"location":"api/cli/#simulate-all","title":"simulate all","text":"<p>Run all simulations (full pipeline):</p> <pre><code>finbot simulate all\n</code></pre> <p>Runs: 1. Overnight LIBOR approximation 2. All stock indexes (SP500, Nasdaq 100) 3. All bond indexes (1Y, 7Y, 20Y Treasuries) 4. All 15 fund simulations</p> <p>Use case: Daily data update pipeline</p>"},{"location":"api/cli/#2-backtest","title":"2. backtest","text":"<p>Run strategy backtests.</p> <pre><code>finbot backtest --strategy Rebalance --tickers SPY TLT --start 2010-01-01\n</code></pre> <p>Options: - <code>--strategy TEXT</code> (required): Strategy name - <code>--tickers TEXT...</code> (required): Asset tickers (space-separated) - <code>--start DATE</code>: Start date (default: 10 years ago) - <code>--end DATE</code>: End date (default: today) - <code>--cash FLOAT</code>: Starting cash (default: 100000) - <code>--commission FLOAT</code>: Commission rate (default: 0.001) - <code>--params JSON</code>: Strategy parameters as JSON (default: {}) - <code>--output PATH</code>: Save results to file</p> <p>Available strategies: Rebalance, NoRebalance, SMACrossover, SMACrossoverDouble, SMACrossoverTriple, MACDSingle, MACDDual, DipBuySMA, DipBuyStdev, SMARebalMix, DualMomentum, RiskParity</p> <p>Example with parameters: <pre><code>finbot backtest \\\n  --strategy SMACrossover \\\n  --tickers SPY \\\n  --params '{\"fast_period\": 50, \"slow_period\": 200}' \\\n  --start 2010-01-01 \\\n  --commission 0.001\n</code></pre></p>"},{"location":"api/cli/#3-optimize","title":"3. optimize","text":"<p>Run portfolio optimizers.</p>"},{"location":"api/cli/#subcommands_1","title":"Subcommands","text":""},{"location":"api/cli/#optimize-dca","title":"optimize dca","text":"<p>Optimize dollar cost averaging allocations:</p> <pre><code>finbot optimize dca --tickers SPY TLT --start 2010-01-01\n</code></pre> <p>Options: - <code>--tickers TEXT...</code> (required): Asset tickers - <code>--start DATE</code>: Start date (default: 10 years ago) - <code>--end DATE</code>: End date (default: today) - <code>--investment FLOAT</code>: Monthly investment amount (default: 1000) - <code>--output PATH</code>: Save results to file</p> <p>Grid search across: - Asset allocation ratios (50-95% equity in 5% steps) - Investment durations (5-30 years) - Purchase frequencies (monthly, quarterly)</p> <p>Metrics computed: - Sharpe ratio - Sortino ratio - Calmar ratio - CAGR - Max drawdown - Standard deviation</p>"},{"location":"api/cli/#optimize-rebalance","title":"optimize rebalance","text":"<p>Optimize portfolio rebalancing ratios:</p> <pre><code>finbot optimize rebalance --tickers SPY TLT --start 2010-01-01\n</code></pre> <p>Options: - <code>--tickers TEXT...</code> (required): Asset tickers - <code>--start DATE</code>: Start date - <code>--end DATE</code>: End date - <code>--output PATH</code>: Save results to file</p> <p>Optimizer: Gradient descent-like search for optimal allocation ratios maximizing Sharpe ratio.</p>"},{"location":"api/cli/#4-update","title":"4. update","text":"<p>Run the daily data update pipeline.</p> <pre><code>finbot update\n</code></pre> <p>Pipeline: 1. Fetch latest YFinance price data 2. Fetch latest FRED economic data (yields, rates, CPI, etc.) 3. Fetch latest Google Finance index data 4. Fetch latest Shiller datasets 5. Run overnight LIBOR approximation 6. Run all index simulations 7. Run all fund simulations</p> <p>Requirements: - API keys (FRED, Google Finance service account) in environment variables - Internet connection - ~5-10 minutes runtime (first run or stale data) - ~30 seconds runtime (fresh data, incremental updates)</p> <p>Output: - Updated parquet files in <code>finbot/data/</code> subdirectories - Log messages showing progress - Success/failure status for each step</p>"},{"location":"api/cli/#5-status","title":"5. status","text":"<p>Check data freshness and health.</p> <pre><code>finbot status\n</code></pre> <p>Checks: - YFinance data age - FRED data age - Google Finance data age - Alpha Vantage data age - BLS data age - Shiller data age - Simulation data age</p> <p>Output: <pre><code>Data Source Status\n==================\nYFinance: \u2713 FRESH (0.2 days old, threshold: 1 day)\nFRED: \u2713 FRESH (0.5 days old, threshold: 7 days)\nGoogle Finance: \u26a0 STALE (8.3 days old, threshold: 7 days)\nSimulations: \u2713 FRESH (0.1 days old, threshold: 1 day)\n...\n</code></pre></p> <p>Status codes: - \u2713 FRESH: Age &lt; threshold (green) - \u26a0 STALE: Age \u2265 threshold (yellow) - \u2717 MISSING: No data files found (red)</p>"},{"location":"api/cli/#6-dashboard","title":"6. dashboard","text":"<p>Launch the Streamlit web dashboard.</p> <pre><code>finbot dashboard\n</code></pre> <p>Dashboard features: - 6 pages: Overview, Simulations, Backtesting, Optimizer, Monte Carlo, Data Status, Health Economics - Interactive charts: Plotly visualizations - Parameter controls: Sliders, dropdowns, date pickers - Real-time updates: Rerun analyses with new parameters - Export results: Download data as CSV</p> <p>Default: - Launches on http://localhost:8501 - Opens browser automatically - Streamlit serves from <code>finbot/dashboard/app.py</code></p>"},{"location":"api/cli/#examples","title":"Examples","text":""},{"location":"api/cli/#daily-update-workflow","title":"Daily Update Workflow","text":"<pre><code># Check current data status\nfinbot status\n\n# Run update pipeline\nfinbot update\n\n# Verify updates\nfinbot status\n</code></pre>"},{"location":"api/cli/#strategy-comparison-workflow","title":"Strategy Comparison Workflow","text":"<pre><code># Backtest multiple strategies\nfinbot backtest --strategy Rebalance --tickers SPY TLT --start 2010-01-01 --output rebalance.parquet\nfinbot backtest --strategy NoRebalance --tickers SPY TLT --start 2010-01-01 --output no_rebalance.parquet\nfinbot backtest --strategy DualMomentum --tickers SPY TLT --start 2010-01-01 --output dual_momentum.parquet\n\n# Analyze results in Python\nimport pandas as pd\n\nrebalance = pd.read_parquet('rebalance.parquet')\nno_rebalance = pd.read_parquet('no_rebalance.parquet')\ndual_momentum = pd.read_parquet('dual_momentum.parquet')\n\n# Compare returns\nprint(f\"Rebalance CAGR: {rebalance['cagr'][0]:.2%}\")\nprint(f\"No Rebalance CAGR: {no_rebalance['cagr'][0]:.2%}\")\nprint(f\"Dual Momentum CAGR: {dual_momentum['cagr'][0]:.2%}\")\n</code></pre>"},{"location":"api/cli/#fund-simulation-workflow","title":"Fund Simulation Workflow","text":"<pre><code># Simulate UPRO (3x S&amp;P 500)\nfinbot simulate fund UPRO --start 2010-01-01 --end 2024-01-01 --output upro.parquet\n\n# Simulate TQQQ (3x Nasdaq 100)\nfinbot simulate fund TQQQ --start 2010-01-01 --end 2024-01-01 --output tqqq.parquet\n\n# Simulate TMF (3x 20Y Treasury)\nfinbot simulate fund TMF --start 2010-01-01 --end 2024-01-01 --output tmf.parquet\n\n# Compare in Python\nimport pandas as pd\n\nupro = pd.read_parquet('upro.parquet')\ntqqq = pd.read_parquet('tqqq.parquet')\ntmf = pd.read_parquet('tmf.parquet')\n\n# Calculate total returns\nupro_return = (upro['Close'][-1] / upro['Close'][0] - 1) * 100\ntqqq_return = (tqqq['Close'][-1] / tqqq['Close'][0] - 1) * 100\ntmf_return = (tmf['Close'][-1] / tmf['Close'][0] - 1) * 100\n\nprint(f\"UPRO: {upro_return:.1f}%\")\nprint(f\"TQQQ: {tqqq_return:.1f}%\")\nprint(f\"TMF: {tmf_return:.1f}%\")\n</code></pre>"},{"location":"api/cli/#dca-optimization-workflow","title":"DCA Optimization Workflow","text":"<pre><code># Optimize SPY/TLT allocation\nfinbot optimize dca --tickers SPY TLT --start 2010-01-01 --investment 1000 --output dca_results.parquet\n\n# Analyze results in Python\nimport pandas as pd\n\nresults = pd.read_parquet('dca_results.parquet')\n\n# Find best Sharpe ratio\nbest = results.loc[results['sharpe'].idxmax()]\nprint(f\"Best allocation: {best['spy_allocation']:.0%} SPY / {best['tlt_allocation']:.0%} TLT\")\nprint(f\"Sharpe ratio: {best['sharpe']:.2f}\")\nprint(f\"CAGR: {best['cagr']:.2%}\")\nprint(f\"Max drawdown: {best['max_drawdown']:.2%}\")\n</code></pre>"},{"location":"api/cli/#error-handling","title":"Error Handling","text":"<p>The CLI provides helpful error messages:</p> <pre><code># Missing required argument\n$ finbot backtest --strategy Rebalance\nError: Missing option '--tickers'\n\n# Invalid strategy name\n$ finbot backtest --strategy InvalidStrategy --tickers SPY\nError: Unknown strategy 'InvalidStrategy'\nAvailable strategies: Rebalance, NoRebalance, SMACrossover, ...\n\n# Invalid date format\n$ finbot simulate fund UPRO --start 2010-13-01\nError: Invalid date format '2010-13-01'. Use YYYY-MM-DD\n\n# Missing API key\n$ finbot update\nError: FRED_API_KEY environment variable not set\nSet it in .env file or export FRED_API_KEY=your_key\n</code></pre>"},{"location":"api/cli/#environment-variables","title":"Environment Variables","text":"<p>Required for data collection features:</p> <pre><code>export DYNACONF_ENV=development  # or production\nexport FRED_API_KEY=your_key\nexport NASDAQ_DATA_LINK_API_KEY=your_key\nexport US_BUREAU_OF_LABOR_STATISTICS_API_KEY=your_key\nexport GOOGLE_FINANCE_SERVICE_ACCOUNT_CREDENTIALS_PATH=/path/to/credentials.json\n</code></pre> <p>Create <code>.env</code> file in <code>finbot/config/</code> for persistent configuration.</p>"},{"location":"api/cli/#performance","title":"Performance","text":"<p>CLI commands are designed for interactive use:</p> Command Typical Runtime Notes status &lt;1 second File system checks only simulate fund 1-2 seconds Single fund simulation simulate all 2-5 minutes All 15 funds + indexes backtest 2-5 seconds Single strategy optimize dca 30-60 seconds Grid search, parallel execution update 30 seconds - 10 minutes Depends on data staleness dashboard 2-3 seconds Streamlit startup"},{"location":"api/cli/#testing","title":"Testing","text":"<p>CLI has smoke tests:</p> <pre><code># Test CLI imports and --help\nuv run pytest tests/unit/test_imports.py::test_cli_import -v\n</code></pre>"},{"location":"api/cli/#see-also","title":"See Also","text":"<ul> <li>User Guide: Quick Start - CLI tutorial</li> <li>Configuration - Environment setup</li> <li>Data Quality - Status monitoring</li> <li>BacktestRunner - Backtest API</li> <li>DCA Optimizer - Optimizer API</li> </ul>"},{"location":"api/dashboard/","title":"Dashboard","text":"<p>The Finbot dashboard provides an interactive Streamlit web interface for running simulations, backtests, optimizations, and health economics analyses.</p>"},{"location":"api/dashboard/#overview","title":"Overview","text":"<p>The dashboard offers:</p> <ul> <li>6 specialized pages: Overview, Simulations, Backtesting, Optimizer, Monte Carlo, Data Status, Health Economics</li> <li>Interactive charts: Plotly visualizations with zoom, pan, hover</li> <li>Parameter controls: Sliders, dropdowns, date pickers for easy configuration</li> <li>Real-time results: Instant updates when parameters change</li> <li>Export functionality: Download results as CSV or images</li> </ul>"},{"location":"api/dashboard/#launching-the-dashboard","title":"Launching the Dashboard","text":""},{"location":"api/dashboard/#command-line","title":"Command Line","text":"<pre><code># Launch dashboard\nfinbot dashboard\n\n# Or directly with Streamlit\nuv run streamlit run finbot/dashboard/app.py\n</code></pre> <p>Default: Opens browser at http://localhost:8501</p>"},{"location":"api/dashboard/#docker","title":"Docker","text":"<pre><code># Launch dashboard in Docker container\nmake docker-dashboard\n\n# Or with docker-compose\ndocker-compose up dashboard\n</code></pre> <p>Access: http://localhost:8501</p>"},{"location":"api/dashboard/#dashboard-module","title":"Dashboard Module","text":"<p>Main dashboard entry point and app configuration:</p>"},{"location":"api/dashboard/#finbot.dashboard.app","title":"finbot.dashboard.app","text":"<p>Finbot Dashboard \u2014 Main entry point and home page.</p>"},{"location":"api/dashboard/#pages","title":"Pages","text":""},{"location":"api/dashboard/#1-overview-home","title":"1. Overview (Home)","text":"<p>Location: <code>finbot/dashboard/app.py</code> (main page)</p> <p>Features: - Project introduction and purpose - Quick navigation to all pages - System status indicators - Recent activity summary</p>"},{"location":"api/dashboard/#2-simulations","title":"2. Simulations","text":"<p>Location: <code>finbot/dashboard/pages/1_simulations.py</code></p> <p>Features: - Fund simulation interface (15 pre-configured funds) - Index simulation (S&amp;P 500, Nasdaq 100, Treasury indexes) - Custom parameter adjustment - Performance charts (price, returns, cumulative returns) - Comparison with actual ETF data (tracking error)</p> <p>Interactive controls: - Fund/index selector (dropdown) - Date range picker (start/end dates) - Leverage ratio slider (for custom simulations) - Expense ratio input - Display toggles (log scale, show actual vs simulated)</p> <p>Charts: - Price history line chart - Daily returns histogram - Cumulative returns comparison - Tracking error over time</p>"},{"location":"api/dashboard/#3-backtesting","title":"3. Backtesting","text":"<p>Location: <code>finbot/dashboard/pages/2_backtesting.py</code></p> <p>Features: - Strategy selection (12 strategies) - Multi-asset backtesting - Strategy parameter tuning - Performance metrics display - Trade log visualization</p> <p>Interactive controls: - Strategy selector (dropdown) - Asset tickers (multi-select) - Parameter inputs (strategy-specific) - Date range picker - Commission rate slider - Starting cash input</p> <p>Metrics displayed: - CAGR, Sharpe, Sortino, Calmar ratios - Max drawdown, volatility - Win rate, profit factor - Total trades, win/loss breakdown</p> <p>Charts: - Portfolio value over time - Drawdown chart - Monthly/yearly returns heatmap - Trade markers on price chart</p>"},{"location":"api/dashboard/#4-optimizer","title":"4. Optimizer","text":"<p>Location: <code>finbot/dashboard/pages/3_optimizer.py</code></p> <p>Features: - DCA optimization interface - Allocation ratio heatmaps - Multi-metric optimization (Sharpe, Sortino, Calmar, CAGR) - Efficient frontier visualization</p> <p>Interactive controls: - Asset tickers (multi-select) - Optimization metric selector (Sharpe, Sortino, Calmar, CAGR) - Investment amount slider - Duration range (min/max years) - Frequency selector (monthly, quarterly)</p> <p>Visualizations: - Heatmap: Allocation ratio vs. Sharpe ratio - Scatter plot: Risk vs. return (efficient frontier) - Bar chart: Top 10 allocation strategies - Table: Full optimization results (sortable)</p>"},{"location":"api/dashboard/#5-monte-carlo","title":"5. Monte Carlo","text":"<p>Location: <code>finbot/dashboard/pages/4_monte_carlo.py</code></p> <p>Features: - Risk simulation interface - Multi-asset Monte Carlo - Percentile projections (5th, 50th, 95th) - Distribution analysis</p> <p>Interactive controls: - Ticker selector - Number of trials slider (1,000 - 50,000) - Time horizon slider (1-50 years) - Initial investment input - Annual contribution input</p> <p>Charts: - Fan chart (percentile bands) - Histogram of final values - Probability of achieving target - Distribution statistics table</p>"},{"location":"api/dashboard/#6-data-status","title":"6. Data Status","text":"<p>Location: <code>finbot/dashboard/pages/5_data_status.py</code></p> <p>Features: - Real-time data freshness monitoring - Data source health dashboard - Refresh trigger buttons - Staleness alerts</p> <p>Status indicators: - \u2713 FRESH (green badge) - \u26a0 STALE (yellow badge) - \u2717 MISSING (red badge)</p> <p>Data sources tracked: - YFinance (1-day threshold) - FRED (7-day threshold) - Google Finance (7-day threshold) - Alpha Vantage (7-day threshold) - BLS (30-day threshold) - Shiller (90-day threshold) - Simulations (1-day threshold)</p> <p>Actions: - Refresh data source button (triggers update) - View last update timestamp - Check data file count - Navigate to data directory</p>"},{"location":"api/dashboard/#7-health-economics","title":"7. Health Economics","text":"<p>Location: <code>finbot/dashboard/pages/6_health_economics.py</code></p> <p>Features: - QALY simulation interface - Cost-effectiveness analysis (ICER, NMB, CEAC) - Treatment optimization - Clinical scenario selector</p> <p>Interactive controls: - Treatment parameters (cost, utility, mortality, duration) - Control parameters (cost, utility, mortality, duration) - Number of simulations slider (1,000 - 100,000) - WTP threshold slider ($0 - $200,000) - Clinical scenario selector (pre-configured scenarios)</p> <p>Clinical scenarios: - Type 2 Diabetes (Metformin vs. GLP-1) - Hypertension (Standard vs. Intensive BP control) - Hyperlipidemia (Statin vs. PCSK9 inhibitor) - Custom (user-defined parameters)</p> <p>Charts: - Cost-effectiveness plane (scatter plot) - CEAC (cost-effectiveness acceptability curve) - Distribution histograms (cost, QALYs, ICER, NMB) - Tornado diagram (sensitivity analysis)</p> <p>Metrics displayed: - ICER (\\(/QALY) - NMB (\\)) - Probability cost-effective (%) - Incremental cost ($) - Incremental QALYs</p> <p>Thresholds shown: - NICE: \u00a320,000 - \u00a330,000/QALY (~$25,000 - $37,500) - CADTH: $30,000 - \\(60,000 CAD/QALY (~\\)37,500 - $75,000 USD) - US: $50,000 - $150,000/QALY - WHO: 1-3\u00d7 GDP per capita</p>"},{"location":"api/dashboard/#reusable-components","title":"Reusable Components","text":"<p>The dashboard includes reusable chart components:</p> <p>Location: <code>finbot/dashboard/components/</code></p> <p>Common components: - Price chart with volume - Returns distribution histogram - Cumulative returns line chart - Drawdown area chart - Correlation heatmap - Performance metrics table - Parameter control sidebar</p>"},{"location":"api/dashboard/#customization","title":"Customization","text":""},{"location":"api/dashboard/#adding-a-new-page","title":"Adding a New Page","text":"<ol> <li> <p>Create file in <code>finbot/dashboard/pages/</code>:    <pre><code># finbot/dashboard/pages/7_my_page.py\nimport streamlit as st\n\nst.title(\"My Custom Page\")\nst.write(\"Page content here\")\n</code></pre></p> </li> <li> <p>Streamlit automatically adds to sidebar navigation</p> </li> <li> <p>Use naming convention: <code>N_page_name.py</code> (N = order)</p> </li> </ol>"},{"location":"api/dashboard/#styling","title":"Styling","text":"<p>The dashboard uses Streamlit's default Material Design theme with custom tweaks:</p> <pre><code># Custom CSS in app.py\nst.markdown(\"\"\"\n    &lt;style&gt;\n    .stMetric {\n        background-color: #f0f2f6;\n        padding: 10px;\n        border-radius: 5px;\n    }\n    &lt;/style&gt;\n\"\"\", unsafe_allow_html=True)\n</code></pre>"},{"location":"api/dashboard/#performance","title":"Performance","text":"<p>Dashboard optimizations:</p> <ul> <li>Caching: <code>@st.cache_data</code> for expensive computations</li> <li>Lazy loading: Data loaded only when page accessed</li> <li>Parquet storage: Fast data reads from cached results</li> <li>Incremental updates: Rerun only changed components</li> </ul>"},{"location":"api/dashboard/#examples","title":"Examples","text":""},{"location":"api/dashboard/#running-a-backtest","title":"Running a Backtest","text":"<ol> <li>Navigate to Backtesting page</li> <li>Select strategy (e.g., \"Rebalance\")</li> <li>Choose assets (e.g., SPY, TLT)</li> <li>Set date range (e.g., 2010-01-01 to 2024-01-01)</li> <li>Adjust parameters (e.g., rebalance_days: 30)</li> <li>Click \"Run Backtest\"</li> <li>Review results:</li> <li>Portfolio value chart</li> <li>Performance metrics</li> <li>Trade log</li> <li>Export results (Download CSV button)</li> </ol>"},{"location":"api/dashboard/#optimizing-dca-allocation","title":"Optimizing DCA Allocation","text":"<ol> <li>Navigate to Optimizer page</li> <li>Select assets (e.g., SPY, TLT)</li> <li>Set investment amount (e.g., $1,000/month)</li> <li>Choose optimization metric (e.g., Sharpe ratio)</li> <li>Set duration range (e.g., 10-30 years)</li> <li>Click \"Optimize\"</li> <li>Review heatmap for optimal allocation</li> <li>Export top strategies</li> </ol>"},{"location":"api/dashboard/#running-monte-carlo-simulation","title":"Running Monte Carlo Simulation","text":"<ol> <li>Navigate to Monte Carlo page</li> <li>Select ticker (e.g., SPY)</li> <li>Set number of trials (e.g., 10,000)</li> <li>Set time horizon (e.g., 30 years)</li> <li>Set initial investment (e.g., $100,000)</li> <li>Set annual contribution (e.g., $10,000)</li> <li>Click \"Run Simulation\"</li> <li>Review fan chart and distribution</li> <li>Check probability of achieving target</li> </ol>"},{"location":"api/dashboard/#deployment","title":"Deployment","text":""},{"location":"api/dashboard/#local-development","title":"Local Development","text":"<pre><code># Development mode (auto-reload)\nuv run streamlit run finbot/dashboard/app.py --server.runOnSave true\n</code></pre>"},{"location":"api/dashboard/#production-docker","title":"Production (Docker)","text":"<pre><code># Build and run with docker-compose\ndocker-compose up -d dashboard\n\n# Access at http://localhost:8501\n</code></pre>"},{"location":"api/dashboard/#streamlit-cloud-future","title":"Streamlit Cloud (Future)","text":"<ol> <li>Connect GitHub repo to Streamlit Cloud</li> <li>Configure secrets (API keys)</li> <li>Deploy from main branch</li> <li>Access at https://finbot.streamlit.app</li> </ol>"},{"location":"api/dashboard/#limitations","title":"Limitations","text":"<ul> <li>Single-user: Not designed for multi-tenancy</li> <li>No authentication: Open access (use behind firewall)</li> <li>In-memory state: Session state resets on refresh</li> <li>Limited concurrency: One simulation at a time per session</li> </ul>"},{"location":"api/dashboard/#troubleshooting","title":"Troubleshooting","text":""},{"location":"api/dashboard/#dashboard-wont-start","title":"Dashboard won't start","text":"<pre><code># Check Streamlit installation\nuv run streamlit --version\n\n# Check for port conflicts\nlsof -i :8501\n\n# Try different port\nuv run streamlit run finbot/dashboard/app.py --server.port 8502\n</code></pre>"},{"location":"api/dashboard/#slow-performance","title":"Slow performance","text":"<pre><code># Clear Streamlit cache\nuv run streamlit cache clear\n\n# Reduce simulation complexity (fewer trials, shorter horizon)\n\n# Check data file sizes (large parquet files slow loading)\n</code></pre>"},{"location":"api/dashboard/#page-not-updating","title":"Page not updating","text":"<pre><code># Force rerun: Press 'R' in browser\n\n# Check browser console for errors (F12 \u2192 Console tab)\n\n# Restart dashboard: Ctrl+C, then relaunch\n</code></pre>"},{"location":"api/dashboard/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command-line interface</li> <li>Backtesting Strategies - Strategy documentation</li> <li>DCA Optimizer - Optimization API</li> <li>Monte Carlo Simulator - Monte Carlo API</li> <li>Health Economics - Health economics API</li> </ul>"},{"location":"api/services/data-quality/","title":"Data Quality","text":"<p>The data quality module provides tools for monitoring data freshness, validating DataFrames, and tracking data source health.</p>"},{"location":"api/services/data-quality/#overview","title":"Overview","text":"<p>The data quality module supports:</p> <ul> <li>Data Freshness Monitoring: Track staleness of cached data sources</li> <li>DataFrame Validation: Lightweight schema and quality checks</li> <li>Data Source Registry: Centralized tracking of 7 data sources</li> <li>CLI Integration: <code>finbot status</code> command for quick health checks</li> </ul>"},{"location":"api/services/data-quality/#modules","title":"Modules","text":""},{"location":"api/services/data-quality/#data-source-registry","title":"Data Source Registry","text":"<p>Registry of data sources with staleness thresholds:</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.data_source_registry","title":"finbot.services.data_quality.data_source_registry","text":"<p>Registry of data sources with expected freshness thresholds.</p> <p>Defines all data sources tracked by finbot along with their storage locations, file patterns, and staleness thresholds. Used by the freshness checker and CLI status command.</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.data_source_registry.DataSource","title":"DataSource  <code>dataclass</code>","text":"<pre><code>DataSource(\n    name: str,\n    directory: Path,\n    pattern: str,\n    max_age_days: int,\n    description: str,\n)\n</code></pre> <p>A tracked data source with freshness metadata.</p>"},{"location":"api/services/data-quality/#data-freshness-checking","title":"Data Freshness Checking","text":"<p>Scans directories and reports freshness status:</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.check_data_freshness","title":"finbot.services.data_quality.check_data_freshness","text":"<p>Check freshness of all registered data sources.</p> <p>Scans data directories for parquet files, reports the most recent modification time, file count, and staleness status for each source.</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.check_data_freshness.DataSourceStatus","title":"DataSourceStatus  <code>dataclass</code>","text":"<pre><code>DataSourceStatus(\n    source: DataSource,\n    file_count: int,\n    oldest_file: datetime | None,\n    newest_file: datetime | None,\n    total_size_bytes: int,\n)\n</code></pre> <p>Freshness status for a single data source.</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.check_data_freshness.check_all_freshness","title":"check_all_freshness","text":"<pre><code>check_all_freshness() -&gt; list[DataSourceStatus]\n</code></pre> <p>Check freshness of all registered data sources.</p> Source code in <code>finbot/services/data_quality/check_data_freshness.py</code> <pre><code>def check_all_freshness() -&gt; list[DataSourceStatus]:\n    \"\"\"Check freshness of all registered data sources.\"\"\"\n    return [check_source_freshness(source) for source in DATA_SOURCES]\n</code></pre>"},{"location":"api/services/data-quality/#finbot.services.data_quality.check_data_freshness.check_source_freshness","title":"check_source_freshness","text":"<pre><code>check_source_freshness(\n    source: DataSource,\n) -&gt; DataSourceStatus\n</code></pre> <p>Check freshness of a single data source.</p> Source code in <code>finbot/services/data_quality/check_data_freshness.py</code> <pre><code>def check_source_freshness(source: DataSource) -&gt; DataSourceStatus:\n    \"\"\"Check freshness of a single data source.\"\"\"\n    files, total_size = _scan_directory(source.directory, source.pattern)\n\n    if not files:\n        return DataSourceStatus(\n            source=source,\n            file_count=0,\n            oldest_file=None,\n            newest_file=None,\n            total_size_bytes=0,\n        )\n\n    mtimes = [datetime.fromtimestamp(f.stat().st_mtime) for f in files]\n    return DataSourceStatus(\n        source=source,\n        file_count=len(files),\n        oldest_file=min(mtimes),\n        newest_file=max(mtimes),\n        total_size_bytes=total_size,\n    )\n</code></pre>"},{"location":"api/services/data-quality/#dataframe-validation","title":"DataFrame Validation","text":"<p>Validates DataFrame structure and content:</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.validate_dataframe","title":"finbot.services.data_quality.validate_dataframe","text":"<p>Validate DataFrame integrity after loading.</p> <p>Provides lightweight validation checks for DataFrames loaded from parquet files, catching common data quality issues like empty frames, missing dates, duplicate indices, and unexpected column schemas.</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.validate_dataframe.ValidationResult","title":"ValidationResult  <code>dataclass</code>","text":"<pre><code>ValidationResult(\n    file_path: Path,\n    is_valid: bool,\n    row_count: int,\n    col_count: int,\n    warnings: list[str] = list(),\n    errors: list[str] = list(),\n)\n</code></pre> <p>Result of a DataFrame validation check.</p>"},{"location":"api/services/data-quality/#finbot.services.data_quality.validate_dataframe.validate_dataframe","title":"validate_dataframe","text":"<pre><code>validate_dataframe(\n    df: DataFrame,\n    file_path: Path | str,\n    min_rows: int = 1,\n    expected_columns: list[str] | None = None,\n    check_duplicates: bool = True,\n    check_nulls: bool = False,\n) -&gt; ValidationResult\n</code></pre> <p>Validate a DataFrame for common data quality issues.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to validate.</p> required <code>file_path</code> <code>Path | str</code> <p>Source file path (for reporting).</p> required <code>min_rows</code> <code>int</code> <p>Minimum expected row count.</p> <code>1</code> <code>expected_columns</code> <code>list[str] | None</code> <p>If provided, check these columns exist.</p> <code>None</code> <code>check_duplicates</code> <code>bool</code> <p>Check for duplicate index entries.</p> <code>True</code> <code>check_nulls</code> <code>bool</code> <p>Warn if any null values present.</p> <code>False</code> <p>Returns:</p> Type Description <code>ValidationResult</code> <p>ValidationResult with errors and warnings.</p> Source code in <code>finbot/services/data_quality/validate_dataframe.py</code> <pre><code>def validate_dataframe(  # noqa: C901 - Validation functions are inherently branchy\n    df: pd.DataFrame,\n    file_path: Path | str,\n    min_rows: int = 1,\n    expected_columns: list[str] | None = None,\n    check_duplicates: bool = True,\n    check_nulls: bool = False,\n) -&gt; ValidationResult:\n    \"\"\"Validate a DataFrame for common data quality issues.\n\n    Args:\n        df: DataFrame to validate.\n        file_path: Source file path (for reporting).\n        min_rows: Minimum expected row count.\n        expected_columns: If provided, check these columns exist.\n        check_duplicates: Check for duplicate index entries.\n        check_nulls: Warn if any null values present.\n\n    Returns:\n        ValidationResult with errors and warnings.\n    \"\"\"\n    file_path = Path(file_path)\n    result = ValidationResult(\n        file_path=file_path,\n        is_valid=True,\n        row_count=len(df),\n        col_count=len(df.columns),\n    )\n\n    # Check empty\n    if df.empty:\n        result.errors.append(\"DataFrame is empty\")\n        result.is_valid = False\n        return result\n\n    # Check minimum rows\n    if len(df) &lt; min_rows:\n        result.errors.append(f\"Expected at least {min_rows} rows, got {len(df)}\")\n        result.is_valid = False\n\n    # Check expected columns\n    if expected_columns:\n        missing = set(expected_columns) - set(df.columns)\n        if missing:\n            result.errors.append(f\"Missing columns: {sorted(missing)}\")\n            result.is_valid = False\n\n    # Check duplicate indices\n    if check_duplicates and df.index.duplicated().any():\n        dup_count = df.index.duplicated().sum()\n        result.warnings.append(f\"{dup_count} duplicate index entries\")\n\n    # Check nulls\n    if check_nulls:\n        null_counts = df.isnull().sum()\n        null_cols = null_counts[null_counts &gt; 0]\n        if not null_cols.empty:\n            result.warnings.append(f\"Null values in {len(null_cols)} columns\")\n\n    # Log results\n    if not result.is_valid:\n        for err in result.errors:\n            logger.warning(f\"Validation error in {file_path.name}: {err}\")\n    for warn in result.warnings:\n        logger.debug(f\"Validation warning in {file_path.name}: {warn}\")\n\n    return result\n</code></pre>"},{"location":"api/services/data-quality/#quick-start","title":"Quick Start","text":""},{"location":"api/services/data-quality/#check-data-freshness","title":"Check Data Freshness","text":"<pre><code>from finbot.services.data_quality.check_data_freshness import check_all_data_sources\n\n# Check all data sources\nstatus = check_all_data_sources()\n\nfor source_name, source_status in status.items():\n    print(f\"{source_name}: {source_status['status']}\")\n    if source_status['status'] == 'STALE':\n        print(f\"  Age: {source_status['age_days']:.1f} days\")\n        print(f\"  Threshold: {source_status['threshold_days']} days\")\n</code></pre>"},{"location":"api/services/data-quality/#validate-dataframe","title":"Validate DataFrame","text":"<pre><code>from finbot.services.data_quality.validate_dataframe import validate_dataframe\nimport pandas as pd\n\n# Load data\ndf = pd.read_parquet('price_data.parquet')\n\n# Validate\nerrors = validate_dataframe(\n    df,\n    required_columns=['Open', 'High', 'Low', 'Close', 'Volume'],\n    allow_duplicates=False,\n    allow_nulls=False\n)\n\nif errors:\n    print(\"Validation errors:\")\n    for error in errors:\n        print(f\"  - {error}\")\nelse:\n    print(\"Data is valid\")\n</code></pre>"},{"location":"api/services/data-quality/#cli-usage","title":"CLI Usage","text":"<pre><code># Check data freshness from command line\nfinbot status\n\n# Example output:\n# Data Source Status\n# ==================\n# YFinance: \u2713 FRESH (0.2 days old, threshold: 1 day)\n# FRED: \u2713 FRESH (0.5 days old, threshold: 7 days)\n# Google Finance: \u26a0 STALE (8.3 days old, threshold: 7 days)\n# ...\n</code></pre>"},{"location":"api/services/data-quality/#data-source-registry_1","title":"Data Source Registry","text":"<p>The registry tracks 7 data sources:</p> Source Directory Threshold (days) Update Frequency YFinance <code>yfinance_data/</code> 1 Daily FRED <code>fred_data/</code> 7 Weekly Google Finance <code>google_finance_data/</code> 7 Weekly Alpha Vantage <code>alpha_vantage_data/</code> 7 Weekly BLS <code>bls_data/</code> 30 Monthly Shiller <code>shiller_data/</code> 90 Quarterly Simulations <code>simulations/</code> 1 Daily"},{"location":"api/services/data-quality/#freshness-status","title":"Freshness Status","text":"<p>Data sources are classified as:</p> <ul> <li>FRESH: Age &lt; threshold (\u2713 green)</li> <li>STALE: Age \u2265 threshold (\u26a0 yellow)</li> <li>MISSING: No data files found (\u2717 red)</li> </ul>"},{"location":"api/services/data-quality/#validation-checks","title":"Validation Checks","text":"<p>The DataFrame validator performs:</p> <ol> <li>Empty check: Ensures DataFrame is not empty</li> <li>Schema check: Validates required columns exist</li> <li>Duplicate check: Checks for duplicate rows (optional)</li> <li>Null check: Checks for missing values (optional)</li> </ol>"},{"location":"api/services/data-quality/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/services/data-quality/#custom-data-source","title":"Custom Data Source","text":"<pre><code>from finbot.services.data_quality.data_source_registry import DataSource, DATA_SOURCES\n\n# Add custom data source\ncustom_source = DataSource(\n    name='Custom API',\n    directory='custom_data',\n    staleness_threshold_days=3\n)\n\nDATA_SOURCES['custom'] = custom_source\n</code></pre>"},{"location":"api/services/data-quality/#detailed-freshness-report","title":"Detailed Freshness Report","text":"<pre><code>from finbot.services.data_quality.check_data_freshness import check_data_source_freshness\nfrom finbot.services.data_quality.data_source_registry import DATA_SOURCES\n\n# Check specific source\nsource = DATA_SOURCES['yfinance']\nstatus = check_data_source_freshness(source)\n\nprint(f\"Source: {status['name']}\")\nprint(f\"Status: {status['status']}\")\nprint(f\"Most recent file: {status['most_recent_file']}\")\nprint(f\"Age (days): {status['age_days']:.2f}\")\nprint(f\"Threshold (days): {status['threshold_days']}\")\nprint(f\"File count: {status['file_count']}\")\n</code></pre>"},{"location":"api/services/data-quality/#custom-validation-rules","title":"Custom Validation Rules","text":"<pre><code>from finbot.services.data_quality.validate_dataframe import validate_dataframe\n\ndef validate_price_data(df):\n    \"\"\"Validate price data with custom rules.\"\"\"\n    errors = []\n\n    # Standard validation\n    errors.extend(validate_dataframe(\n        df,\n        required_columns=['Open', 'High', 'Low', 'Close', 'Volume']\n    ))\n\n    # Custom rules\n    if (df['High'] &lt; df['Low']).any():\n        errors.append(\"High prices must be &gt;= Low prices\")\n\n    if (df['Close'] &lt; 0).any():\n        errors.append(\"Prices must be non-negative\")\n\n    if not df.index.is_monotonic_increasing:\n        errors.append(\"Index must be sorted chronologically\")\n\n    return errors\n</code></pre>"},{"location":"api/services/data-quality/#integration-with-update-pipeline","title":"Integration with Update Pipeline","text":"<p>The data quality module integrates with the daily update pipeline:</p> <pre><code># scripts/update_daily.py\nfrom finbot.services.data_quality.check_data_freshness import check_all_data_sources\n\n# Check data freshness before running simulations\nstatus = check_all_data_sources()\nstale_sources = [name for name, s in status.items() if s['status'] == 'STALE']\n\nif stale_sources:\n    logger.warning(f\"Stale data sources detected: {stale_sources}\")\n    # Proceed anyway or trigger updates\n</code></pre>"},{"location":"api/services/data-quality/#observability-features","title":"Observability Features","text":""},{"location":"api/services/data-quality/#logging","title":"Logging","text":"<p>All data quality checks are logged:</p> <pre><code>from finbot.config import logger\n\nlogger.info(\"Running data freshness check\")\nstatus = check_all_data_sources()\nlogger.info(f\"Checked {len(status)} data sources\")\n</code></pre>"},{"location":"api/services/data-quality/#metrics","title":"Metrics","text":"<p>Data quality metrics available:</p> <ul> <li>Age (days): Time since most recent update</li> <li>File count: Number of files in data directory</li> <li>Status: FRESH, STALE, or MISSING</li> <li>Threshold compliance: Age &lt; threshold</li> </ul>"},{"location":"api/services/data-quality/#best-practices","title":"Best Practices","text":"<ol> <li>Run daily: Check data freshness as part of daily pipeline</li> <li>Set appropriate thresholds: Balance freshness vs. API rate limits</li> <li>Monitor trends: Track staleness over time</li> <li>Validate early: Check data quality immediately after collection</li> <li>Log failures: Record validation errors for debugging</li> </ol>"},{"location":"api/services/data-quality/#limitations","title":"Limitations","text":"<ul> <li>File-based only: Checks file modification times, not content</li> <li>No content validation: Doesn't verify data correctness, only presence</li> <li>Simple schema checks: Basic column presence, not deep schema validation</li> <li>No automatic remediation: Detects issues but doesn't fix them</li> </ul>"},{"location":"api/services/data-quality/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements:</p> <ul> <li>Content-based freshness (check latest date in data, not file modification time)</li> <li>Deep schema validation with Pandera or Great Expectations</li> <li>Automatic data refresh triggers</li> <li>Alerting integration (email, Slack)</li> <li>Data quality dashboards</li> </ul>"},{"location":"api/services/data-quality/#see-also","title":"See Also","text":"<ul> <li>Data Quality Guide - Operations documentation</li> <li>CLI Reference - <code>finbot status</code> command</li> <li>Update Pipeline - Daily data update workflow</li> </ul>"},{"location":"api/services/health-economics/","title":"Health Economics","text":"<p>The health economics module provides tools for quality-adjusted life year (QALY) simulation, cost-effectiveness analysis, and treatment schedule optimization.</p>"},{"location":"api/services/health-economics/#overview","title":"Overview","text":"<p>The health economics module supports:</p> <ul> <li>QALY Simulation: Monte Carlo simulation with stochastic costs, utilities, and mortality</li> <li>Cost-Effectiveness Analysis: ICER, NMB, CEAC, cost-effectiveness planes</li> <li>Treatment Optimization: Grid-search optimization across treatment schedules</li> <li>Compliance with Standards: NICE, CADTH, WHO willingness-to-pay thresholds</li> </ul>"},{"location":"api/services/health-economics/#modules","title":"Modules","text":""},{"location":"api/services/health-economics/#qaly-simulator","title":"QALY Simulator","text":"<p>Simulates health economic outcomes using Monte Carlo methods:</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.qaly_simulator","title":"finbot.services.health_economics.qaly_simulator","text":"<p>Monte Carlo QALY (Quality-Adjusted Life Year) simulator.</p> <p>Models health intervention outcomes with probabilistic uncertainty using Monte Carlo simulation.  Generates distributions of costs and QALYs for downstream cost-effectiveness analysis.</p> <p>Standard health economics discounting (default 3% per WHO/NICE guidelines) is applied to both costs and health outcomes.</p> Typical usage <p>intervention = HealthIntervention(\"Drug A\", cost_per_year=5000, ...) results = simulate_qalys(intervention, n_sims=10000) median_qaly = results[\"total_qalys\"].median()</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.qaly_simulator.HealthIntervention","title":"HealthIntervention  <code>dataclass</code>","text":"<pre><code>HealthIntervention(\n    name: str,\n    cost_per_year: float = 0.0,\n    cost_std: float = 0.0,\n    utility_gain: float = 0.0,\n    utility_gain_std: float = 0.0,\n    mortality_reduction: float = 0.0,\n    mortality_reduction_std: float = 0.0,\n    metadata: dict[str, float] = dict(),\n)\n</code></pre> <p>Parameters defining a health intervention.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Human-readable intervention name.</p> <code>cost_per_year</code> <code>float</code> <p>Mean annual cost of the intervention.</p> <code>cost_std</code> <code>float</code> <p>Standard deviation of annual cost (0 = deterministic).</p> <code>utility_gain</code> <code>float</code> <p>Mean improvement in health utility per year (0-1 scale). E.g. 0.1 means the treatment improves quality of life by 0.1 QALYs/year.</p> <code>utility_gain_std</code> <code>float</code> <p>Standard deviation of annual utility gain.</p> <code>mortality_reduction</code> <code>float</code> <p>Mean reduction in annual mortality probability.</p> <code>mortality_reduction_std</code> <code>float</code> <p>Standard deviation of mortality reduction.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.qaly_simulator.simulate_qalys","title":"simulate_qalys","text":"<pre><code>simulate_qalys(\n    intervention: HealthIntervention,\n    baseline_utility: float = 0.7,\n    baseline_mortality: float = 0.02,\n    time_horizon: int = 10,\n    n_sims: int = 10000,\n    discount_rate: float = 0.03,\n    seed: int | None = None,\n) -&gt; dict[str, pd.Series | pd.DataFrame | float]\n</code></pre> <p>Simulate QALYs and costs for a health intervention via Monte Carlo.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.qaly_simulator.simulate_qalys--parameters","title":"Parameters","text":"<p>intervention : HealthIntervention     The intervention to simulate. baseline_utility : float     Health utility without intervention (0 = death, 1 = perfect health). baseline_mortality : float     Baseline annual mortality probability (0-1). time_horizon : int     Number of years to simulate (default 10). n_sims : int     Number of Monte Carlo trials (default 10 000). discount_rate : float     Annual discount rate for costs and QALYs (default 0.03 per guidelines). seed : int | None     Random seed for reproducibility.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.qaly_simulator.simulate_qalys--returns","title":"Returns","text":"<p>dict with keys:     <code>total_costs</code>      : pd.Series   \u2014 total discounted cost per simulation     <code>total_qalys</code>      : pd.Series   \u2014 total discounted QALYs per simulation     <code>annual_costs</code>     : pd.DataFrame \u2014 discounted costs by year (n_sims x time_horizon)     <code>annual_qalys</code>     : pd.DataFrame \u2014 discounted QALYs by year     <code>survival_curves</code>  : pd.DataFrame \u2014 survival probability by year     <code>mean_cost</code>        : float     <code>mean_qaly</code>        : float</p> Source code in <code>finbot/services/health_economics/qaly_simulator.py</code> <pre><code>def simulate_qalys(\n    intervention: HealthIntervention,\n    baseline_utility: float = 0.7,\n    baseline_mortality: float = 0.02,\n    time_horizon: int = 10,\n    n_sims: int = 10000,\n    discount_rate: float = 0.03,\n    seed: int | None = None,\n) -&gt; dict[str, pd.Series | pd.DataFrame | float]:\n    \"\"\"Simulate QALYs and costs for a health intervention via Monte Carlo.\n\n    Parameters\n    ----------\n    intervention : HealthIntervention\n        The intervention to simulate.\n    baseline_utility : float\n        Health utility without intervention (0 = death, 1 = perfect health).\n    baseline_mortality : float\n        Baseline annual mortality probability (0-1).\n    time_horizon : int\n        Number of years to simulate (default 10).\n    n_sims : int\n        Number of Monte Carlo trials (default 10 000).\n    discount_rate : float\n        Annual discount rate for costs and QALYs (default 0.03 per guidelines).\n    seed : int | None\n        Random seed for reproducibility.\n\n    Returns\n    -------\n    dict with keys:\n        ``total_costs``      : pd.Series   \u2014 total discounted cost per simulation\n        ``total_qalys``      : pd.Series   \u2014 total discounted QALYs per simulation\n        ``annual_costs``     : pd.DataFrame \u2014 discounted costs by year (n_sims x time_horizon)\n        ``annual_qalys``     : pd.DataFrame \u2014 discounted QALYs by year\n        ``survival_curves``  : pd.DataFrame \u2014 survival probability by year\n        ``mean_cost``        : float\n        ``mean_qaly``        : float\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    years = list(range(1, time_horizon + 1))\n\n    # --- Draw annual costs ---\n    if intervention.cost_std &gt; 0:\n        costs = np.abs(rng.normal(intervention.cost_per_year, intervention.cost_std, (n_sims, time_horizon)))\n    else:\n        costs = np.full((n_sims, time_horizon), intervention.cost_per_year)\n\n    # --- Draw utility gains ---\n    if intervention.utility_gain_std &gt; 0:\n        utility_gains = rng.normal(intervention.utility_gain, intervention.utility_gain_std, (n_sims, time_horizon))\n    else:\n        utility_gains = np.full((n_sims, time_horizon), intervention.utility_gain)\n\n    utilities = np.clip(baseline_utility + utility_gains, 0.0, 1.0)\n\n    # --- Draw mortality reductions ---\n    if intervention.mortality_reduction_std &gt; 0:\n        mort_reductions = rng.normal(\n            intervention.mortality_reduction,\n            intervention.mortality_reduction_std,\n            (n_sims, time_horizon),\n        )\n    else:\n        mort_reductions = np.full((n_sims, time_horizon), intervention.mortality_reduction)\n\n    annual_mortality = np.clip(baseline_mortality - mort_reductions, 0.0, 1.0)\n\n    # --- Survival and discounting ---\n    survival = np.cumprod(1 - annual_mortality, axis=1)\n    discount_factors = np.array([1.0 / (1.0 + discount_rate) ** t for t in range(time_horizon)])\n\n    qalys_annual = utilities * survival * discount_factors\n    costs_discounted = costs * survival * discount_factors\n\n    total_qalys = qalys_annual.sum(axis=1)\n    total_costs = costs_discounted.sum(axis=1)\n\n    return {\n        \"total_costs\": pd.Series(total_costs, name=\"Total Cost\"),\n        \"total_qalys\": pd.Series(total_qalys, name=\"Total QALYs\"),\n        \"annual_costs\": pd.DataFrame(costs_discounted, columns=years),\n        \"annual_qalys\": pd.DataFrame(qalys_annual, columns=years),\n        \"survival_curves\": pd.DataFrame(survival, columns=years),\n        \"mean_cost\": float(total_costs.mean()),\n        \"mean_qaly\": float(total_qalys.mean()),\n    }\n</code></pre>"},{"location":"api/services/health-economics/#cost-effectiveness-analysis","title":"Cost-Effectiveness Analysis","text":"<p>Computes incremental cost-effectiveness ratios and net monetary benefit:</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.cost_effectiveness","title":"finbot.services.health_economics.cost_effectiveness","text":"<p>Cost-effectiveness analysis (CEA) for comparing health interventions.</p> <p>Implements standard health economics tools: - Incremental Cost-Effectiveness Ratio (ICER) - Net Monetary Benefit (NMB) - Cost-Effectiveness Acceptability Curves (CEAC) - Cost-effectiveness plane scatter data</p> <p>Uses probabilistic sensitivity analysis (PSA) via Monte Carlo simulation results from the QALY simulator.</p> Typical usage <p>cea = cost_effectiveness_analysis(     sim_results={\"Drug A\": sim_a, \"No Treatment\": sim_baseline},     comparator=\"No Treatment\", ) print(f\"ICER: ${cea['icer']['ICER'].iloc[0]:,.0f}/QALY\")</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.cost_effectiveness.cost_effectiveness_analysis","title":"cost_effectiveness_analysis","text":"<pre><code>cost_effectiveness_analysis(\n    sim_results: dict[\n        str, dict[str, Series | DataFrame | float]\n    ],\n    comparator: str,\n    wtp_thresholds: list[float] | None = None,\n) -&gt; dict[str, pd.DataFrame | dict[str, pd.DataFrame]]\n</code></pre> <p>Run cost-effectiveness analysis comparing interventions to a comparator.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.cost_effectiveness.cost_effectiveness_analysis--parameters","title":"Parameters","text":"<p>sim_results : dict[str, dict]     Mapping of intervention name to simulation results from     :func:<code>simulate_qalys</code>.  Must contain at least the comparator and     one other intervention. comparator : str     Name of the comparator intervention (e.g. <code>\"No Treatment\"</code>). wtp_thresholds : list[float] | None     Willingness-to-pay thresholds for CEAC/NMB.     Defaults to $0 -- $200 000 in $5 000 steps.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.cost_effectiveness.cost_effectiveness_analysis--returns","title":"Returns","text":"<p>dict with keys:     <code>icer</code>     : pd.DataFrame \u2014 ICER for each intervention vs comparator     <code>nmb</code>      : pd.DataFrame \u2014 mean NMB at each WTP threshold     <code>ceac</code>     : pd.DataFrame \u2014 P(cost-effective) at each WTP threshold     <code>ce_plane</code> : dict[str, pd.DataFrame] \u2014 (\u0394Cost, \u0394QALY) per intervention     <code>summary</code>  : pd.DataFrame \u2014 summary statistics per intervention</p> Source code in <code>finbot/services/health_economics/cost_effectiveness.py</code> <pre><code>def cost_effectiveness_analysis(\n    sim_results: dict[str, dict[str, pd.Series | pd.DataFrame | float]],\n    comparator: str,\n    wtp_thresholds: list[float] | None = None,\n) -&gt; dict[str, pd.DataFrame | dict[str, pd.DataFrame]]:\n    \"\"\"Run cost-effectiveness analysis comparing interventions to a comparator.\n\n    Parameters\n    ----------\n    sim_results : dict[str, dict]\n        Mapping of intervention name to simulation results from\n        :func:`simulate_qalys`.  Must contain at least the comparator and\n        one other intervention.\n    comparator : str\n        Name of the comparator intervention (e.g. ``\"No Treatment\"``).\n    wtp_thresholds : list[float] | None\n        Willingness-to-pay thresholds for CEAC/NMB.\n        Defaults to $0 -- $200 000 in $5 000 steps.\n\n    Returns\n    -------\n    dict with keys:\n        ``icer``     : pd.DataFrame \u2014 ICER for each intervention vs comparator\n        ``nmb``      : pd.DataFrame \u2014 mean NMB at each WTP threshold\n        ``ceac``     : pd.DataFrame \u2014 P(cost-effective) at each WTP threshold\n        ``ce_plane`` : dict[str, pd.DataFrame] \u2014 (\u0394Cost, \u0394QALY) per intervention\n        ``summary``  : pd.DataFrame \u2014 summary statistics per intervention\n    \"\"\"\n    if comparator not in sim_results:\n        raise ValueError(f\"Comparator '{comparator}' not found in sim_results\")\n\n    if wtp_thresholds is None:\n        wtp_thresholds = [float(x) for x in range(0, 205_000, 5_000)]\n\n    comp = sim_results[comparator]\n    comp_costs = comp[\"total_costs\"].to_numpy()  # type: ignore[union-attr]\n    comp_qalys = comp[\"total_qalys\"].to_numpy()  # type: ignore[union-attr]\n\n    interventions = [k for k in sim_results if k != comparator]\n\n    # --- ICER table ---\n    icer_rows: list[dict[str, object]] = []\n    ce_plane_data: dict[str, pd.DataFrame] = {}\n\n    for name in interventions:\n        res = sim_results[name]\n        int_costs = res[\"total_costs\"].to_numpy()  # type: ignore[union-attr]\n        int_qalys = res[\"total_qalys\"].to_numpy()  # type: ignore[union-attr]\n\n        delta_cost = int_costs - comp_costs\n        delta_qaly = int_qalys - comp_qalys\n\n        mean_dc = float(delta_cost.mean())\n        mean_dq = float(delta_qaly.mean())\n        icer = mean_dc / mean_dq if abs(mean_dq) &gt; 1e-10 else float(\"inf\")\n\n        icer_rows.append(\n            {\n                \"Intervention\": name,\n                \"Mean Cost\": float(int_costs.mean()),\n                \"Mean QALYs\": float(int_qalys.mean()),\n                \"Incremental Cost\": mean_dc,\n                \"Incremental QALYs\": mean_dq,\n                \"ICER\": icer,\n            }\n        )\n\n        ce_plane_data[name] = pd.DataFrame({\"Delta Cost\": delta_cost, \"Delta QALYs\": delta_qaly})\n\n    icer_df = pd.DataFrame(icer_rows)\n\n    # --- NMB and CEAC across WTP thresholds ---\n    nmb_rows: list[dict[str, float]] = []\n    ceac_rows: list[dict[str, float]] = []\n\n    for wtp in wtp_thresholds:\n        # NMB for every intervention (including comparator)\n        all_nmbs: dict[str, np.ndarray] = {}\n        all_nmbs[comparator] = wtp * comp_qalys - comp_costs\n\n        nmb_row: dict[str, float] = {\"WTP\": wtp}\n        for name in interventions:\n            res = sim_results[name]\n            ic = res[\"total_costs\"].to_numpy()  # type: ignore[union-attr]\n            iq = res[\"total_qalys\"].to_numpy()  # type: ignore[union-attr]\n            nmb = wtp * iq - ic\n            all_nmbs[name] = nmb\n            nmb_row[name] = float(nmb.mean())\n        nmb_rows.append(nmb_row)\n\n        # CEAC: probability each intervention has highest NMB\n        nmb_matrix = np.column_stack(list(all_nmbs.values()))\n        best = nmb_matrix.argmax(axis=1)\n        ceac_row: dict[str, float] = {\"WTP\": wtp}\n        for i, iname in enumerate(all_nmbs):\n            ceac_row[iname] = float((best == i).mean())\n        ceac_rows.append(ceac_row)\n\n    nmb_df = pd.DataFrame(nmb_rows).set_index(\"WTP\")\n    nmb_df.index.name = \"WTP Threshold\"\n\n    ceac_df = pd.DataFrame(ceac_rows).set_index(\"WTP\")\n    ceac_df.index.name = \"WTP Threshold\"\n\n    # --- Summary table ---\n    summary_rows: list[dict[str, object]] = []\n    for name in [comparator, *interventions]:\n        res = sim_results[name]\n        tc = res[\"total_costs\"]\n        tq = res[\"total_qalys\"]\n        summary_rows.append(\n            {\n                \"Intervention\": name,\n                \"Mean Cost\": res[\"mean_cost\"],\n                \"Std Cost\": float(tc.std()),  # type: ignore[union-attr]\n                \"Mean QALYs\": res[\"mean_qaly\"],\n                \"Std QALYs\": float(tq.std()),  # type: ignore[union-attr]\n            }\n        )\n\n    summary_df = pd.DataFrame(summary_rows).set_index(\"Intervention\")\n\n    return {\n        \"icer\": icer_df,\n        \"nmb\": nmb_df,\n        \"ceac\": ceac_df,\n        \"ce_plane\": ce_plane_data,\n        \"summary\": summary_df,\n    }\n</code></pre>"},{"location":"api/services/health-economics/#treatment-optimizer","title":"Treatment Optimizer","text":"<p>Optimizes treatment schedules using grid search:</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.treatment_optimizer","title":"finbot.services.health_economics.treatment_optimizer","text":"<p>Treatment schedule optimizer using grid search.</p> <p>Adapts the DCA (Dollar Cost Averaging) optimization pattern to health economics: instead of optimizing investment timing, optimizes treatment schedules (dose frequency and duration) for cost-effectiveness.</p> <p>Grid-searches across treatment parameters and evaluates each combination using Monte Carlo simulation.  Ranks schedules by Net Monetary Benefit (NMB = WTP x incremental_QALYs - incremental_cost).</p> Typical usage <p>results = optimize_treatment(     cost_per_dose=1000.0,     qaly_gain_per_dose=0.02,     frequencies=[1, 2, 4, 12],     durations=[1, 2, 5, 10], ) best = results.iloc[0]  # highest NMB</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.treatment_optimizer.optimize_treatment","title":"optimize_treatment","text":"<pre><code>optimize_treatment(\n    cost_per_dose: float,\n    cost_per_dose_std: float = 0.0,\n    qaly_gain_per_dose: float = 0.02,\n    qaly_gain_per_dose_std: float = 0.0,\n    frequencies: list[int] | None = None,\n    durations: list[int] | None = None,\n    baseline_utility: float = 0.7,\n    baseline_mortality: float = 0.02,\n    mortality_reduction_per_dose: float = 0.0,\n    discount_rate: float = 0.03,\n    wtp_threshold: float = 50000.0,\n    n_sims: int = 5000,\n    seed: int | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Optimize treatment schedule via grid search over frequency and duration.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.treatment_optimizer.optimize_treatment--parameters","title":"Parameters","text":"<p>cost_per_dose : float     Mean cost per treatment dose. cost_per_dose_std : float     Std dev of cost per dose (0 = deterministic). qaly_gain_per_dose : float     QALY utility gain per dose per year.  Annual gain is     <code>qaly_gain_per_dose * frequency</code>, capped at <code>1 - baseline_utility</code>. qaly_gain_per_dose_std : float     Std dev of utility gain per dose. frequencies : list[int] | None     Doses per year to evaluate.  Defaults to <code>[1, 2, 4, 12, 26, 52]</code>. durations : list[int] | None     Treatment durations in years.  Defaults to <code>[1, 2, 3, 5, 10]</code>. baseline_utility : float     Health utility without treatment (0-1 scale). baseline_mortality : float     Baseline annual mortality probability. mortality_reduction_per_dose : float     Reduction in annual mortality per dose per year. discount_rate : float     Annual discount rate (default 0.03). wtp_threshold : float     Willingness-to-pay per QALY for NMB calculation (default $50 000). n_sims : int     Monte Carlo simulations per parameter combination (default 5000). seed : int | None     Random seed for reproducibility.</p>"},{"location":"api/services/health-economics/#finbot.services.health_economics.treatment_optimizer.optimize_treatment--returns","title":"Returns","text":"<p>pd.DataFrame     One row per (frequency, duration) combination.  Columns include     <code>Frequency</code>, <code>Duration</code>, <code>Annual_Cost</code>, <code>Total_Cost</code>,     <code>Total_QALYs</code>, <code>Incremental_Cost</code>, <code>Incremental_QALYs</code>,     <code>ICER</code>, <code>NMB</code>.  Sorted by NMB descending (best first).</p> Source code in <code>finbot/services/health_economics/treatment_optimizer.py</code> <pre><code>def optimize_treatment(\n    cost_per_dose: float,\n    cost_per_dose_std: float = 0.0,\n    qaly_gain_per_dose: float = 0.02,\n    qaly_gain_per_dose_std: float = 0.0,\n    frequencies: list[int] | None = None,\n    durations: list[int] | None = None,\n    baseline_utility: float = 0.7,\n    baseline_mortality: float = 0.02,\n    mortality_reduction_per_dose: float = 0.0,\n    discount_rate: float = 0.03,\n    wtp_threshold: float = 50_000.0,\n    n_sims: int = 5000,\n    seed: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Optimize treatment schedule via grid search over frequency and duration.\n\n    Parameters\n    ----------\n    cost_per_dose : float\n        Mean cost per treatment dose.\n    cost_per_dose_std : float\n        Std dev of cost per dose (0 = deterministic).\n    qaly_gain_per_dose : float\n        QALY utility gain per dose per year.  Annual gain is\n        ``qaly_gain_per_dose * frequency``, capped at ``1 - baseline_utility``.\n    qaly_gain_per_dose_std : float\n        Std dev of utility gain per dose.\n    frequencies : list[int] | None\n        Doses per year to evaluate.  Defaults to ``[1, 2, 4, 12, 26, 52]``.\n    durations : list[int] | None\n        Treatment durations in years.  Defaults to ``[1, 2, 3, 5, 10]``.\n    baseline_utility : float\n        Health utility without treatment (0-1 scale).\n    baseline_mortality : float\n        Baseline annual mortality probability.\n    mortality_reduction_per_dose : float\n        Reduction in annual mortality per dose per year.\n    discount_rate : float\n        Annual discount rate (default 0.03).\n    wtp_threshold : float\n        Willingness-to-pay per QALY for NMB calculation (default $50 000).\n    n_sims : int\n        Monte Carlo simulations per parameter combination (default 5000).\n    seed : int | None\n        Random seed for reproducibility.\n\n    Returns\n    -------\n    pd.DataFrame\n        One row per (frequency, duration) combination.  Columns include\n        ``Frequency``, ``Duration``, ``Annual_Cost``, ``Total_Cost``,\n        ``Total_QALYs``, ``Incremental_Cost``, ``Incremental_QALYs``,\n        ``ICER``, ``NMB``.  Sorted by NMB descending (best first).\n    \"\"\"\n    if frequencies is None:\n        frequencies = [1, 2, 4, 12, 26, 52]\n    if durations is None:\n        durations = [1, 2, 3, 5, 10]\n\n    rng = np.random.default_rng(seed)\n    max_horizon = max(durations)\n\n    # Pre-compute baseline (no-treatment) QALYs for each duration\n    discount_factors = np.array([1.0 / (1.0 + discount_rate) ** t for t in range(max_horizon)])\n    baseline_survival_annual = np.cumprod(np.full(max_horizon, 1.0 - baseline_mortality))\n    baseline_qalys_cum = np.cumsum(baseline_utility * baseline_survival_annual * discount_factors)\n\n    results: list[dict[str, float | int]] = []\n\n    for freq, dur in itertools.product(frequencies, durations):\n        # Annual aggregates (CLT for independent doses within a year)\n        annual_cost_mean = cost_per_dose * freq\n        annual_cost_std = cost_per_dose_std * np.sqrt(freq) if cost_per_dose_std &gt; 0 else 0.0\n\n        annual_utility_gain = min(qaly_gain_per_dose * freq, 1.0 - baseline_utility)\n        annual_utility_std = qaly_gain_per_dose_std * np.sqrt(freq) if qaly_gain_per_dose_std &gt; 0 else 0.0\n\n        mort_reduction = min(mortality_reduction_per_dose * freq, baseline_mortality)\n\n        # --- Monte Carlo for this (freq, dur) combination ---\n        if annual_cost_std &gt; 0:\n            sim_costs = np.abs(rng.normal(annual_cost_mean, annual_cost_std, (n_sims, dur)))\n        else:\n            sim_costs = np.full((n_sims, dur), annual_cost_mean)\n\n        if annual_utility_std &gt; 0:\n            sim_gains = rng.normal(annual_utility_gain, annual_utility_std, (n_sims, dur))\n        else:\n            sim_gains = np.full((n_sims, dur), annual_utility_gain)\n\n        sim_utility = np.clip(baseline_utility + sim_gains, 0.0, 1.0)\n\n        treated_mortality = max(baseline_mortality - mort_reduction, 0.0)\n        sim_survival = np.cumprod(np.full((n_sims, dur), 1.0 - treated_mortality), axis=1)\n\n        disc = discount_factors[:dur]\n        sim_qalys = (sim_utility * sim_survival * disc).sum(axis=1)\n        sim_total_costs = (sim_costs * sim_survival * disc).sum(axis=1)\n\n        baseline_qalys = float(baseline_qalys_cum[dur - 1])\n\n        mean_qalys = float(sim_qalys.mean())\n        mean_cost = float(sim_total_costs.mean())\n        incr_qalys = mean_qalys - baseline_qalys\n        incr_cost = mean_cost  # baseline has zero treatment cost\n\n        icer = incr_cost / incr_qalys if abs(incr_qalys) &gt; 1e-10 else float(\"inf\")\n        nmb = wtp_threshold * incr_qalys - incr_cost\n\n        results.append(\n            {\n                \"Frequency\": freq,\n                \"Duration\": dur,\n                \"Annual_Cost\": annual_cost_mean,\n                \"Total_Cost\": mean_cost,\n                \"Total_QALYs\": mean_qalys,\n                \"Baseline_QALYs\": baseline_qalys,\n                \"Incremental_Cost\": incr_cost,\n                \"Incremental_QALYs\": incr_qalys,\n                \"ICER\": icer,\n                \"NMB\": nmb,\n            }\n        )\n\n    df = pd.DataFrame(results)\n    return df.sort_values(\"NMB\", ascending=False).reset_index(drop=True)\n</code></pre>"},{"location":"api/services/health-economics/#quick-start","title":"Quick Start","text":""},{"location":"api/services/health-economics/#qaly-simulation-example","title":"QALY Simulation Example","text":"<pre><code>from finbot.services.health_economics.qaly_simulator import QALYSimulator\nimport numpy as np\n\n# Define treatment parameters\ntreatment_params = {\n    'cost_per_year': 5000,\n    'cost_std': 500,\n    'utility_per_year': 0.85,\n    'utility_std': 0.05,\n    'mortality_rate': 0.02,\n    'duration_years': 10\n}\n\ncontrol_params = {\n    'cost_per_year': 1000,\n    'cost_std': 100,\n    'utility_per_year': 0.70,\n    'utility_std': 0.05,\n    'mortality_rate': 0.03,\n    'duration_years': 10\n}\n\n# Run simulation\nsimulator = QALYSimulator()\ntreatment_results = simulator.simulate(treatment_params, n_simulations=10000)\ncontrol_results = simulator.simulate(control_params, n_simulations=10000)\n\nprint(f\"Treatment QALYs: {treatment_results['qalys'].mean():.2f}\")\nprint(f\"Treatment Cost: ${treatment_results['costs'].mean():,.0f}\")\n</code></pre>"},{"location":"api/services/health-economics/#cost-effectiveness-analysis-example","title":"Cost-Effectiveness Analysis Example","text":"<pre><code>from finbot.services.health_economics.cost_effectiveness import (\n    calculate_icer,\n    calculate_nmb,\n    calculate_ceac\n)\n\n# Calculate ICER\nicer = calculate_icer(\n    cost_treatment=treatment_results['costs'],\n    cost_control=control_results['costs'],\n    qaly_treatment=treatment_results['qalys'],\n    qaly_control=control_results['qalys']\n)\nprint(f\"ICER: ${icer:,.0f} per QALY\")\n\n# Calculate NMB at NICE threshold (\u00a320,000/QALY \u2248 $25,000 USD)\nnmb = calculate_nmb(\n    cost_treatment=treatment_results['costs'],\n    qaly_treatment=treatment_results['qalys'],\n    cost_control=control_results['costs'],\n    qaly_control=control_results['qalys'],\n    wtp_threshold=25000\n)\nprint(f\"Net Monetary Benefit: ${nmb.mean():,.0f}\")\n\n# Calculate CEAC across thresholds\nthresholds = np.linspace(0, 100000, 100)\nceac = calculate_ceac(\n    cost_treatment=treatment_results['costs'],\n    qaly_treatment=treatment_results['qalys'],\n    cost_control=control_results['costs'],\n    qaly_control=control_results['qalys'],\n    wtp_thresholds=thresholds\n)\n</code></pre>"},{"location":"api/services/health-economics/#treatment-optimization-example","title":"Treatment Optimization Example","text":"<pre><code>from finbot.services.health_economics.treatment_optimizer import optimize_treatment_schedule\n\n# Optimize treatment dose frequency and duration\nbest_schedule = optimize_treatment_schedule(\n    dose_frequencies=[1, 2, 4],  # doses per week\n    durations=[6, 12, 24],  # months\n    cost_per_dose=100,\n    utility_improvement_per_dose=0.01,\n    wtp_threshold=50000\n)\n\nprint(f\"Optimal frequency: {best_schedule['frequency']} doses/week\")\nprint(f\"Optimal duration: {best_schedule['duration']} months\")\nprint(f\"Expected NMB: ${best_schedule['nmb']:,.0f}\")\n</code></pre>"},{"location":"api/services/health-economics/#key-concepts","title":"Key Concepts","text":""},{"location":"api/services/health-economics/#quality-adjusted-life-years-qalys","title":"Quality-Adjusted Life Years (QALYs)","text":"<p>QALYs combine: - Survival time: Years of life gained - Quality of life: Utility scores (0 = death, 1 = perfect health)</p> <p>Calculation: <code>QALY = \u03a3(utility_i \u00d7 duration_i)</code></p>"},{"location":"api/services/health-economics/#incremental-cost-effectiveness-ratio-icer","title":"Incremental Cost-Effectiveness Ratio (ICER)","text":"<p>Measures cost per additional QALY gained:</p> <pre><code>ICER = (Cost_treatment - Cost_control) / (QALY_treatment - QALY_control)\n</code></pre> <p>Interpretation: - ICER &lt; $50,000/QALY: Highly cost-effective (US standard) - ICER &lt; $100,000/QALY: Cost-effective - ICER &lt; $150,000/QALY: Possibly cost-effective (varies by condition)</p>"},{"location":"api/services/health-economics/#net-monetary-benefit-nmb","title":"Net Monetary Benefit (NMB)","text":"<p>Converts health outcomes to monetary terms:</p> <pre><code>NMB = (QALY_treatment - QALY_control) \u00d7 WTP - (Cost_treatment - Cost_control)\n</code></pre> <p>Interpretation: - NMB &gt; 0: Treatment is cost-effective at the given WTP threshold - NMB &lt; 0: Treatment is not cost-effective</p>"},{"location":"api/services/health-economics/#cost-effectiveness-acceptability-curve-ceac","title":"Cost-Effectiveness Acceptability Curve (CEAC)","text":"<p>Shows probability that treatment is cost-effective across different willingness-to-pay thresholds.</p>"},{"location":"api/services/health-economics/#international-thresholds","title":"International Thresholds","text":"Country/Region Threshold (USD/QALY) Organization UK $25,000 - $37,500 NICE Canada $37,500 - $75,000 CADTH US $50,000 - $150,000 Common practice WHO 1-3\u00d7 GDP per capita WHO-CHOICE"},{"location":"api/services/health-economics/#clinical-applications","title":"Clinical Applications","text":""},{"location":"api/services/health-economics/#type-2-diabetes-management","title":"Type 2 Diabetes Management","text":"<p>Compare metformin vs. GLP-1 agonists:</p> <pre><code># Metformin (control)\nmetformin = {\n    'cost_per_year': 500,\n    'utility_per_year': 0.75,\n    'mortality_rate': 0.025\n}\n\n# GLP-1 agonist (treatment)\nglp1 = {\n    'cost_per_year': 5000,\n    'utility_per_year': 0.80,\n    'mortality_rate': 0.020\n}\n</code></pre>"},{"location":"api/services/health-economics/#hypertension-treatment","title":"Hypertension Treatment","text":"<p>Compare standard vs. intensive blood pressure control:</p> <pre><code># Standard control\nstandard_bp = {\n    'cost_per_year': 800,\n    'utility_per_year': 0.82,\n    'mortality_rate': 0.018\n}\n\n# Intensive control\nintensive_bp = {\n    'cost_per_year': 2000,\n    'utility_per_year': 0.85,\n    'mortality_rate': 0.014\n}\n</code></pre>"},{"location":"api/services/health-economics/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>The module supports probabilistic sensitivity analysis (PSA):</p> <pre><code># Vary parameters across distributions\nresults = []\nfor _ in range(1000):\n    cost_multiplier = np.random.uniform(0.8, 1.2)\n    utility_bonus = np.random.uniform(0.03, 0.07)\n\n    params = {\n        'cost_per_year': 5000 * cost_multiplier,\n        'utility_per_year': 0.75 + utility_bonus,\n        'mortality_rate': 0.02\n    }\n\n    sim_result = simulator.simulate(params, n_simulations=1000)\n    results.append(sim_result)\n</code></pre>"},{"location":"api/services/health-economics/#validation","title":"Validation","text":"<p>The module has been validated against: - Published health economics literature - WHO-CHOICE methodology guidelines - NICE technology appraisal guidance</p>"},{"location":"api/services/health-economics/#limitations","title":"Limitations","text":"<ul> <li>Simplified mortality modeling: Constant hazard rates (not age-dependent)</li> <li>No discounting: Future costs/QALYs not discounted to present value</li> <li>Independent distributions: Costs and utilities assumed independent</li> <li>No indirect costs: Productivity losses not included</li> <li>No adverse events: Treatment side effects not modeled</li> </ul> <p>See Health Economics Methodology for detailed discussion.</p>"},{"location":"api/services/health-economics/#see-also","title":"See Also","text":"<ul> <li>Health Economics Tutorial - Step-by-step guide</li> <li>Health Economics Methodology - Research documentation</li> <li>Example Notebook 06 - Interactive examples</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/","title":"BacktestRunner","text":"<p>The <code>BacktestRunner</code> class is the main orchestrator for running backtests in Finbot. It wraps Backtrader's Cerebro engine and provides a simplified interface for testing trading strategies.</p>"},{"location":"api/services/backtesting/backtest-runner/#overview","title":"Overview","text":"<p><code>BacktestRunner</code> provides:</p> <ul> <li>Strategy initialization with parameters</li> <li>Data feed management (multiple assets)</li> <li>Broker configuration (cash, commission)</li> <li>Custom analyzers for performance tracking</li> <li>Results processing and statistics computation</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.backtesting.backtest_runner import BacktestRunner\nimport pandas as pd\n\n# Load price data\nspy_data = pd.read_parquet('spy_prices.parquet')\ntlt_data = pd.read_parquet('tlt_prices.parquet')\n\n# Create backtest runner\nrunner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy_data, 'TLT': tlt_data},\n    strategy_params={'rebalance_days': 30},\n    cash=100000,\n    commission=0.001\n)\n\n# Run backtest\nresults = runner.run()\n\n# Get statistics\nstats = runner.get_stats()\nprint(f\"CAGR: {stats['CAGR']:.2%}\")\nprint(f\"Sharpe: {stats['Sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['Max Drawdown']:.2%}\")\n</code></pre>"},{"location":"api/services/backtesting/backtest-runner/#class-backtestrunner","title":"Class: BacktestRunner","text":"<p>Location: <code>finbot.services.backtesting.backtest_runner</code></p>"},{"location":"api/services/backtesting/backtest-runner/#constructor","title":"Constructor","text":"<pre><code>BacktestRunner(\n    strategy: str,\n    data_feeds: dict[str, pd.DataFrame],\n    strategy_params: dict[str, Any] = None,\n    cash: float = 100000,\n    commission: float = 0.001\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>strategy</code> (str): Strategy name (Rebalance, SMACrossover, etc.)</li> <li><code>data_feeds</code> (dict): Dictionary mapping tickers to DataFrames</li> <li><code>strategy_params</code> (dict, optional): Strategy-specific parameters</li> <li><code>cash</code> (float, optional): Starting cash amount (default: 100000)</li> <li><code>commission</code> (float, optional): Commission rate (default: 0.001)</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/#methods","title":"Methods","text":""},{"location":"api/services/backtesting/backtest-runner/#run","title":"run()","text":"<p>Execute the backtest and return results.</p> <pre><code>results = runner.run()\n</code></pre> <p>Returns: Dictionary with backtest results including portfolio values, returns, and analyzer data.</p>"},{"location":"api/services/backtesting/backtest-runner/#get_stats","title":"get_stats()","text":"<p>Calculate performance statistics.</p> <pre><code>stats = runner.get_stats()\n</code></pre> <p>Returns: Dictionary with performance metrics: - CAGR: Compound annual growth rate - Sharpe: Sharpe ratio - Sortino: Sortino ratio - Calmar: Calmar ratio - Max Drawdown: Maximum drawdown percentage - Win Rate: Percentage of winning trades - Volatility: Annualized volatility</p>"},{"location":"api/services/backtesting/backtest-runner/#supported-strategies","title":"Supported Strategies","text":"<ul> <li>Rebalance: Periodic portfolio rebalancing</li> <li>NoRebalance: Buy and hold</li> <li>SMACrossover: Simple moving average crossover</li> <li>SMACrossoverDouble: Dual SMA crossover</li> <li>SMACrossoverTriple: Triple SMA crossover</li> <li>MACDSingle: MACD-based strategy</li> <li>MACDDual: Dual MACD strategy</li> <li>DipBuySMA: Buy dips with SMA filter</li> <li>DipBuyStdev: Buy dips with standard deviation filter</li> <li>SMARebalMix: Mixed SMA + rebalance approach</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/#performance-metrics","title":"Performance Metrics","text":"<p>The backtest computes the following metrics using quantstats:</p> Metric Description CAGR Compound Annual Growth Rate Sharpe Ratio Risk-adjusted return (Rf = 2%) Sortino Ratio Downside risk-adjusted return Calmar Ratio CAGR / Max Drawdown Max Drawdown Largest peak-to-trough decline Win Rate Percentage of winning trades Kelly Criterion Optimal position sizing Volatility Annualized standard deviation"},{"location":"api/services/backtesting/backtest-runner/#examples","title":"Examples","text":""},{"location":"api/services/backtesting/backtest-runner/#basic-rebalance-strategy","title":"Basic Rebalance Strategy","text":"<pre><code>runner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy, 'TLT': tlt},\n    strategy_params={\n        'rebalance_days': 30,\n        'target_allocations': {'SPY': 0.6, 'TLT': 0.4}\n    }\n)\nresults = runner.run()\n</code></pre>"},{"location":"api/services/backtesting/backtest-runner/#sma-crossover-with-custom-parameters","title":"SMA Crossover with Custom Parameters","text":"<pre><code>runner = BacktestRunner(\n    strategy='SMACrossover',\n    data_feeds={'SPY': spy},\n    strategy_params={\n        'fast_period': 50,\n        'slow_period': 200\n    },\n    cash=100000,\n    commission=0.001\n)\nresults = runner.run()\n</code></pre>"},{"location":"api/services/backtesting/backtest-runner/#see-also","title":"See Also","text":"<ul> <li>run_backtest Function - Single backtest execution</li> <li>compute_stats Function - Performance metrics</li> <li>User Guide: Backtesting - Tutorial</li> </ul>"},{"location":"api/services/backtesting/strategies/","title":"Trading Strategies","text":"<p>The strategies module implements 12 systematic trading strategies spanning portfolio management, timing, momentum, and mean reversion approaches.</p>"},{"location":"api/services/backtesting/strategies/#overview","title":"Overview","text":"<p>Finbot includes:</p> <ul> <li>12 battle-tested strategies: Rebalance, SMA crossover, MACD, dip buying, dual momentum, risk parity</li> <li>Backtrader integration: All strategies compatible with Backtrader framework</li> <li>Comprehensive backtesting: Validated across 15 years of S&amp;P 500 data (2009-2024)</li> <li>Performance metrics: CAGR, Sharpe, Sortino, Calmar, max drawdown, win rate</li> </ul>"},{"location":"api/services/backtesting/strategies/#strategy-categories","title":"Strategy Categories","text":""},{"location":"api/services/backtesting/strategies/#portfolio-management-passive","title":"Portfolio Management (Passive)","text":"Strategy Description Key Parameters Rebalance Periodic portfolio rebalancing <code>rebalance_days</code>, <code>target_allocations</code> NoRebalance Buy and hold None RiskParity Inverse-volatility weighting <code>lookback_days</code>, <code>rebalance_days</code>"},{"location":"api/services/backtesting/strategies/#timing-strategies-technical-indicators","title":"Timing Strategies (Technical Indicators)","text":"Strategy Description Key Parameters SMACrossover Single SMA crossover <code>fast_period</code>, <code>slow_period</code> SMACrossoverDouble Dual SMA crossover <code>fast1</code>, <code>slow1</code>, <code>fast2</code>, <code>slow2</code> SMACrossoverTriple Triple SMA crossover <code>fast</code>, <code>medium</code>, <code>slow</code> SMARebalMix SMA signals + periodic rebalance <code>sma_period</code>, <code>rebalance_days</code>"},{"location":"api/services/backtesting/strategies/#momentum-strategies","title":"Momentum Strategies","text":"Strategy Description Key Parameters MACDSingle MACD crossover <code>fast_ema</code>, <code>slow_ema</code>, <code>signal_ema</code> MACDDual Dual MACD system <code>fast1</code>, <code>slow1</code>, <code>signal1</code>, <code>fast2</code>, <code>slow2</code>, <code>signal2</code> DualMomentum Absolute + relative momentum <code>lookback_period</code>, <code>safe_asset</code>"},{"location":"api/services/backtesting/strategies/#mean-reversion-strategies","title":"Mean Reversion Strategies","text":"Strategy Description Key Parameters DipBuySMA Buy dips below SMA <code>sma_period</code>, <code>dip_threshold</code> DipBuyStdev Buy dips &gt; N std devs <code>lookback_period</code>, <code>stdev_threshold</code>"},{"location":"api/services/backtesting/strategies/#strategy-modules","title":"Strategy Modules","text":""},{"location":"api/services/backtesting/strategies/#rebalance","title":"Rebalance","text":"<p>Periodic portfolio rebalancing to target allocations:</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.rebalance","title":"finbot.services.backtesting.strategies.rebalance","text":""},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.rebalance.Rebalance","title":"Rebalance","text":"<pre><code>Rebalance(rebal_proportions, rebal_interval)\n</code></pre> <p>               Bases: <code>Strategy</code></p> <p>Rebalance multiple stocks with configurable proportions and interval.</p> Source code in <code>finbot/services/backtesting/strategies/rebalance.py</code> <pre><code>def __init__(self, rebal_proportions, rebal_interval):\n    self.rebal_proportions = rebal_proportions\n    self.rebal_interval = rebal_interval\n    self.periods_since_last_rebal = rebal_interval\n    self.dataclose = self.datas[0].close\n    self.order = None\n</code></pre>"},{"location":"api/services/backtesting/strategies/#no-rebalance","title":"No Rebalance","text":"<p>Buy and hold strategy:</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.no_rebalance","title":"finbot.services.backtesting.strategies.no_rebalance","text":""},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.no_rebalance.NoRebalance","title":"NoRebalance","text":"<pre><code>NoRebalance(equity_proportions)\n</code></pre> <p>               Bases: <code>Strategy</code></p> <p>Basic buy and hold strategy with no rebalancing.</p> Source code in <code>finbot/services/backtesting/strategies/no_rebalance.py</code> <pre><code>def __init__(self, equity_proportions):\n    self.equity_proportions = equity_proportions\n    self.dataclose = self.datas[0].close\n    self.order = None\n</code></pre>"},{"location":"api/services/backtesting/strategies/#sma-crossover","title":"SMA Crossover","text":"<p>Simple moving average crossover:</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.sma_crossover","title":"finbot.services.backtesting.strategies.sma_crossover","text":""},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.sma_crossover.SMACrossover","title":"SMACrossover","text":"<pre><code>SMACrossover(fast_ma, slow_ma)\n</code></pre> <p>               Bases: <code>Strategy</code></p> <p>Single stock SMA crossover strategy.</p> Source code in <code>finbot/services/backtesting/strategies/sma_crossover.py</code> <pre><code>def __init__(self, fast_ma, slow_ma):\n    self.fast_ma = fast_ma\n    self.slow_ma = slow_ma\n    self.dataclose = self.datas[0].close\n    self.order = None\n    self.fast_sma = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.fast_ma)\n    self.slow_sma = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.slow_ma)\n</code></pre>"},{"location":"api/services/backtesting/strategies/#macd-single","title":"MACD Single","text":"<p>MACD-based timing:</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.macd_single","title":"finbot.services.backtesting.strategies.macd_single","text":""},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.macd_single.MACDSingle","title":"MACDSingle","text":"<pre><code>MACDSingle(fast_ma, slow_ma, signal_period)\n</code></pre> <p>               Bases: <code>Strategy</code></p> <p>Single equity MACD crossover strategy.</p> Source code in <code>finbot/services/backtesting/strategies/macd_single.py</code> <pre><code>def __init__(self, fast_ma, slow_ma, signal_period):\n    self.fast_ma = fast_ma\n    self.slow_ma = slow_ma\n    self.signal_period = signal_period\n    self.dataclose = self.datas[0].close\n    self.order = None\n    self.macd = bt.indicators.MACD(\n        self.data,\n        period_me1=self.fast_ma,\n        period_me2=self.slow_ma,\n        period_signal=self.signal_period,\n    )\n    self.mcross = bt.indicators.CrossOver(self.macd.macd, self.macd.signal)\n</code></pre>"},{"location":"api/services/backtesting/strategies/#dual-momentum","title":"Dual Momentum","text":"<p>Absolute + relative momentum:</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.dual_momentum","title":"finbot.services.backtesting.strategies.dual_momentum","text":"<p>Dual momentum strategy combining absolute and relative momentum.</p> <p>Implements Gary Antonacci's dual momentum approach: 1. Absolute momentum: Is the primary asset's return over the lookback    period positive? If not, stay in cash. 2. Relative momentum: Among available assets, which has the highest    return over the lookback? Invest in the strongest.</p> <p>Requires at least 2 data feeds: the primary asset(s) and a safe asset (e.g., bonds or T-bills) used as the fallback when absolute momentum is negative.</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.dual_momentum.DualMomentum","title":"DualMomentum","text":"<pre><code>DualMomentum(lookback: int = 252, rebal_interval: int = 21)\n</code></pre> <p>               Bases: <code>Strategy</code></p> <p>Dual momentum: absolute + relative momentum with safe-asset fallback.</p> <p>Parameters:</p> Name Type Description Default <code>lookback</code> <code>int</code> <p>Number of periods for momentum calculation (default 252 = ~1 year).</p> <code>252</code> <code>rebal_interval</code> <code>int</code> <p>Periods between rebalance checks (default 21 = ~1 month).</p> <code>21</code> Data feeds <p>datas[0]: Primary asset (e.g., SPY) datas[1]: Alternative/safe asset (e.g., TLT, IEF, SHY)</p> Source code in <code>finbot/services/backtesting/strategies/dual_momentum.py</code> <pre><code>def __init__(self, lookback: int = 252, rebal_interval: int = 21):\n    self.lookback = lookback\n    self.rebal_interval = rebal_interval\n    self.periods_elapsed = 0\n    self.order = None\n</code></pre>"},{"location":"api/services/backtesting/strategies/#risk-parity","title":"Risk Parity","text":"<p>Inverse-volatility weighting:</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.risk_parity","title":"finbot.services.backtesting.strategies.risk_parity","text":"<p>Risk parity strategy that allocates inversely proportional to volatility.</p> <p>Each asset receives a weight inversely proportional to its rolling standard deviation of returns, so that each contributes roughly equal risk to the portfolio.  Rebalances periodically.</p> <p>Requires at least 2 data feeds.</p>"},{"location":"api/services/backtesting/strategies/#finbot.services.backtesting.strategies.risk_parity.RiskParity","title":"RiskParity","text":"<pre><code>RiskParity(vol_window: int = 63, rebal_interval: int = 21)\n</code></pre> <p>               Bases: <code>Strategy</code></p> <p>Risk parity: inverse-volatility weighting with periodic rebalance.</p> <p>Parameters:</p> Name Type Description Default <code>vol_window</code> <code>int</code> <p>Rolling window for volatility calculation (default 63 = ~3 months).</p> <code>63</code> <code>rebal_interval</code> <code>int</code> <p>Periods between rebalances (default 21 = ~1 month).</p> <code>21</code> Source code in <code>finbot/services/backtesting/strategies/risk_parity.py</code> <pre><code>def __init__(self, vol_window: int = 63, rebal_interval: int = 21):\n    self.vol_window = vol_window\n    self.rebal_interval = rebal_interval\n    self.periods_elapsed = 0\n    self.order = None\n\n    # Track close prices for volatility calculation\n    self.returns: dict[int, list[float]] = {i: [] for i in range(len(self.datas))}\n    self.prev_close: dict[int, float | None] = dict.fromkeys(range(len(self.datas)))\n</code></pre>"},{"location":"api/services/backtesting/strategies/#quick-start","title":"Quick Start","text":""},{"location":"api/services/backtesting/strategies/#running-a-strategy-backtest","title":"Running a Strategy Backtest","text":"<pre><code>from finbot.services.backtesting.run_backtest import run_backtest\nimport pandas as pd\n\n# Load data\nspy = pd.read_parquet('spy_prices.parquet')\ntlt = pd.read_parquet('tlt_prices.parquet')\n\n# Run rebalance strategy\nresults = run_backtest(\n    strategy_name='Rebalance',\n    data_feeds={'SPY': spy, 'TLT': tlt},\n    strategy_params={\n        'rebalance_days': 30,\n        'target_allocations': {'SPY': 0.6, 'TLT': 0.4}\n    },\n    cash=100000,\n    commission=0.001\n)\n\nprint(f\"CAGR: {results['cagr']:.2%}\")\nprint(f\"Sharpe: {results['sharpe']:.2f}\")\nprint(f\"Max Drawdown: {results['max_drawdown']:.2%}\")\n</code></pre>"},{"location":"api/services/backtesting/strategies/#strategy-comparison","title":"Strategy Comparison","text":"<pre><code>from finbot.services.backtesting.backtest_batch import run_batch_backtests\n\nstrategies = [\n    {'name': 'NoRebalance', 'params': {}},\n    {'name': 'Rebalance', 'params': {'rebalance_days': 30}},\n    {'name': 'SMACrossover', 'params': {'fast_period': 50, 'slow_period': 200}},\n    {'name': 'DualMomentum', 'params': {'lookback_period': 252}}\n]\n\nresults = run_batch_backtests(\n    strategies=strategies,\n    data_feeds={'SPY': spy, 'TLT': tlt},\n    cash=100000,\n    commission=0.001\n)\n\n# Compare performance\nfor strategy, result in results.items():\n    print(f\"{strategy}: Sharpe={result['sharpe']:.2f}, CAGR={result['cagr']:.2%}\")\n</code></pre>"},{"location":"api/services/backtesting/strategies/#strategy-details","title":"Strategy Details","text":""},{"location":"api/services/backtesting/strategies/#1-rebalance","title":"1. Rebalance","text":"<p>Concept: Periodically reset portfolio to target allocations (e.g., 60/40).</p> <p>Benefits: - Enforces buy-low-sell-high discipline - Reduces portfolio drift - Lowers volatility</p> <p>Research Results (2009-2024): - CAGR: 10.8% - Sharpe: 0.87 - Max DD: -23.5%</p>"},{"location":"api/services/backtesting/strategies/#2-no-rebalance-buy-and-hold","title":"2. No Rebalance (Buy and Hold)","text":"<p>Concept: Buy initial allocations and hold without rebalancing.</p> <p>Benefits: - Lowest transaction costs - Tax-efficient (fewer trades) - Simplest implementation</p> <p>Research Results: - CAGR: 11.1% - Sharpe: 0.78 - Max DD: -33.8%</p>"},{"location":"api/services/backtesting/strategies/#3-sma-crossover","title":"3. SMA Crossover","text":"<p>Concept: Buy when fast SMA crosses above slow SMA, sell on cross below.</p> <p>Parameters: - <code>fast_period</code>: 50 days (default) - <code>slow_period</code>: 200 days (default)</p> <p>Research Results: - CAGR: 9.2% - Sharpe: 0.71 - Max DD: -18.3%</p>"},{"location":"api/services/backtesting/strategies/#4-macd-single","title":"4. MACD Single","text":"<p>Concept: Buy when MACD line crosses signal line from below, sell on cross down.</p> <p>Parameters: - <code>fast_ema</code>: 12 days - <code>slow_ema</code>: 26 days - <code>signal_ema</code>: 9 days</p> <p>Research Results: - CAGR: 8.8% - Sharpe: 0.69 - Max DD: -19.5%</p>"},{"location":"api/services/backtesting/strategies/#5-dual-momentum","title":"5. Dual Momentum","text":"<p>Concept: Combine absolute momentum (asset vs. cash) and relative momentum (asset vs. safe asset).</p> <p>Parameters: - <code>lookback_period</code>: 252 days (12 months) - <code>safe_asset</code>: 'TLT' (default)</p> <p>Benefits: - Trend-following - Downside protection (switches to safe asset) - Works across asset classes</p> <p>Research Results: - CAGR: 10.5% - Sharpe: 0.82 - Max DD: -15.2%</p>"},{"location":"api/services/backtesting/strategies/#6-risk-parity","title":"6. Risk Parity","text":"<p>Concept: Weight assets inversely to their volatility (lower vol \u2192 higher weight).</p> <p>Parameters: - <code>lookback_days</code>: 60 days - <code>rebalance_days</code>: 30 days</p> <p>Benefits: - Balances risk contribution - Reduces concentration risk - Diversifies across volatility regimes</p> <p>Research Results: - CAGR: 10.3% - Sharpe: 0.85 - Max DD: -20.1%</p>"},{"location":"api/services/backtesting/strategies/#7-dip-buy-sma","title":"7. Dip Buy SMA","text":"<p>Concept: Buy when price drops below SMA by threshold percentage.</p> <p>Parameters: - <code>sma_period</code>: 50 days - <code>dip_threshold</code>: 0.05 (5%)</p> <p>Research Results: - CAGR: 9.5% - Sharpe: 0.73 - Max DD: -25.8%</p>"},{"location":"api/services/backtesting/strategies/#8-dip-buy-stdev","title":"8. Dip Buy Stdev","text":"<p>Concept: Buy when price drops &gt; N standard deviations below mean.</p> <p>Parameters: - <code>lookback_period</code>: 60 days - <code>stdev_threshold</code>: 2.0</p> <p>Research Results: - CAGR: 9.1% - Sharpe: 0.70 - Max DD: -27.3%</p>"},{"location":"api/services/backtesting/strategies/#performance-comparison-2009-2024","title":"Performance Comparison (2009-2024)","text":"<p>Ranked by Sharpe ratio:</p> Strategy CAGR Sharpe Sortino Calmar Max DD Rebalance 10.8% 0.87 1.21 0.46 -23.5% Risk Parity 10.3% 0.85 1.18 0.51 -20.1% Dual Momentum 10.5% 0.82 1.15 0.69 -15.2% No Rebalance 11.1% 0.78 1.08 0.33 -33.8% Dip Buy SMA 9.5% 0.73 1.01 0.37 -25.8% SMA Crossover 9.2% 0.71 0.98 0.50 -18.3% Dip Buy Stdev 9.1% 0.70 0.96 0.33 -27.3% MACD Single 8.8% 0.69 0.95 0.45 -19.5% <p>Key Findings: - Periodic rebalancing improved Sharpe by 12% vs. buy-and-hold - Dual momentum achieved best drawdown control (-15.2%) - No single strategy dominated all metrics - Risk-adjusted returns matter more than absolute returns</p>"},{"location":"api/services/backtesting/strategies/#strategy-parameters","title":"Strategy Parameters","text":""},{"location":"api/services/backtesting/strategies/#optimizing-parameters","title":"Optimizing Parameters","text":"<p>Use grid search to find optimal parameters:</p> <pre><code>from finbot.services.backtesting.backtest_batch import run_batch_backtests\n\n# Test multiple SMA periods\nstrategies = []\nfor fast in [20, 50, 100]:\n    for slow in [100, 200, 300]:\n        if fast &lt; slow:\n            strategies.append({\n                'name': 'SMACrossover',\n                'params': {'fast_period': fast, 'slow_period': slow}\n            })\n\nresults = run_batch_backtests(strategies, data_feeds={'SPY': spy})\n\n# Find best Sharpe ratio\nbest = max(results.items(), key=lambda x: x[1]['sharpe'])\nprint(f\"Best params: {best[0]}, Sharpe: {best[1]['sharpe']:.2f}\")\n</code></pre>"},{"location":"api/services/backtesting/strategies/#parameter-sensitivity","title":"Parameter Sensitivity","text":"<p>Common parameter ranges:</p> Strategy Parameter Typical Range Impact Rebalance rebalance_days 30-90 Higher = lower turnover, higher drift SMA Crossover fast_period 20-100 Lower = more responsive, more whipsaws SMA Crossover slow_period 100-300 Higher = slower trend changes MACD fast_ema 8-16 Lower = more signals MACD slow_ema 20-32 Higher = smoother signals Dual Momentum lookback_period 126-378 Higher = slower momentum detection Risk Parity lookback_days 30-120 Higher = slower volatility adaptation"},{"location":"api/services/backtesting/strategies/#implementation-notes","title":"Implementation Notes","text":""},{"location":"api/services/backtesting/strategies/#backtrader-integration","title":"Backtrader Integration","text":"<p>All strategies extend <code>bt.Strategy</code>:</p> <pre><code>import backtrader as bt\n\nclass MyStrategy(bt.Strategy):\n    params = (\n        ('my_param', 50),\n    )\n\n    def __init__(self):\n        self.indicator = bt.indicators.SMA(period=self.params.my_param)\n\n    def next(self):\n        if self.data.close[0] &gt; self.indicator[0]:\n            self.buy()\n        else:\n            self.sell()\n</code></pre>"},{"location":"api/services/backtesting/strategies/#testing-strategies","title":"Testing Strategies","text":"<p>All strategies have unit tests:</p> <pre><code># Run strategy tests\nuv run pytest tests/unit/test_strategies.py -v\n\n# Run parametrized tests\nuv run pytest tests/unit/test_strategies_parametrized.py -v\n</code></pre>"},{"location":"api/services/backtesting/strategies/#limitations","title":"Limitations","text":"<ul> <li>Overfitting risk: Parameters optimized on historical data may not generalize</li> <li>Transaction costs: 0.1% commission assumed, real costs vary</li> <li>Slippage ignored: Assumes perfect execution at close prices</li> <li>Survivorship bias: Backtests use current index constituents</li> <li>Regime dependency: Performance varies by market regime (bull/bear/sideways)</li> </ul> <p>See Strategy Backtest Results for detailed analysis.</p>"},{"location":"api/services/backtesting/strategies/#see-also","title":"See Also","text":"<ul> <li>BacktestRunner - Main backtesting orchestrator</li> <li>Compute Stats - Performance metrics</li> <li>Strategy Backtest Results - Research documentation</li> <li>Example Notebook 03 - Interactive examples</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/","title":"DCA Optimizer","text":"<p>The DCA (Dollar Cost Averaging) optimizer performs grid search across asset allocation ratios, DCA durations, and purchase intervals to find optimal portfolio strategies.</p>"},{"location":"api/services/optimization/dca-optimizer/#overview","title":"Overview","text":"<p>The optimizer:</p> <ul> <li>Tests combinations of allocation ratios, DCA durations, and purchase intervals</li> <li>Calculates CAGR, Sharpe ratio, Sortino ratio, max drawdown, and std dev for each</li> <li>Uses multiprocessing for parallel evaluation (~70-80 combinations/second)</li> <li>Returns results ranked by Sharpe ratio</li> <li>Supports 2-asset portfolios (extensible to N assets)</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.optimization.dca_optimizer import dca_optimizer\nimport pandas as pd\n\n# Load price data\nspy = pd.read_parquet('spy_prices.parquet')['Close']\ntlt = pd.read_parquet('tlt_prices.parquet')['Close']\n\n# Merge on common dates\ncombined = pd.DataFrame({'SPY': spy, 'TLT': tlt}).dropna()\n\n# Run optimizer\nresults = dca_optimizer(\n    price_history=combined,\n    ratio_linspace=(0.50, 0.95, 10),  # Test 50% to 95% in SPY (10 values)\n    dca_duration_days=365 * 5,  # 5-year DCA period\n    dca_step_days=30,  # Monthly purchases\n    trial_duration_days=365 * 10,  # 10-year trial period\n    starting_cash=100000\n)\n\n# View top results\nprint(results.head())\nprint(f\"Optimal allocation: {results.iloc[0]['ratio']:.0%} SPY / {1-results.iloc[0]['ratio']:.0%} TLT\")\nprint(f\"Optimal Sharpe: {results.iloc[0]['sharpe']:.2f}\")\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#api-reference","title":"API Reference","text":""},{"location":"api/services/optimization/dca-optimizer/#finbot.services.optimization.dca_optimizer.dca_optimizer","title":"finbot.services.optimization.dca_optimizer.dca_optimizer","text":"<pre><code>dca_optimizer(\n    price_history: Series,\n    ticker: str | None = None,\n    ratio_range: tuple = (1, 1.5, 2, 3, 5, 10),\n    dca_durations: tuple = tuple(\n        (round(n))\n        for n in (\n            1,\n            5,\n            252 / 12,\n            252 / 4,\n            252 / 2,\n            252,\n            252 * 2,\n            252 * 3,\n        )\n    ),\n    dca_steps: tuple = tuple(\n        (round(n)) for n in (1, 5, 10, 252 / 12, 252 / 4)\n    ),\n    trial_durations: tuple = tuple(\n        (round(n)) for n in (252 * 3, 252 * 5)\n    ),\n    starting_cash: float = 1000,\n    start_step: int = 5,\n    save_df: bool = True,\n    analyze_results: bool = True,\n) -&gt; pd.DataFrame | tuple[pd.DataFrame, pd.DataFrame]\n</code></pre> <p>Run DCA optimization across many parameter combinations.</p>"},{"location":"api/services/optimization/dca-optimizer/#finbot.services.optimization.dca_optimizer.dca_optimizer--parameters","title":"Parameters","text":"<p>price_history : pd.Series     Series of \"Adj Close\" or \"Close\" float values. ticker : str, optional     Ticker symbol for labeling output. ratio_range : tuple     Ratios of amount to invest on first DCA day over last DCA day. dca_durations : tuple     Number of periods to DCA over. dca_steps : tuple     Number of periods between DCA purchases. trial_durations : tuple     Total number of periods per trial. starting_cash : float     Starting cash amount. start_step : int     Periods to advance trial starting point between trials. save_df : bool     Whether to save results to parquet. analyze_results : bool     Whether to return analyzed results or raw DataFrame.</p>"},{"location":"api/services/optimization/dca-optimizer/#finbot.services.optimization.dca_optimizer.dca_optimizer--raises","title":"Raises","text":"<p>ValueError     If price_history is None or empty.</p> Source code in <code>finbot/services/optimization/dca_optimizer.py</code> <pre><code>def dca_optimizer(\n    price_history: pd.Series,\n    ticker: str | None = None,\n    ratio_range: tuple = (1, 1.5, 2, 3, 5, 10),\n    dca_durations: tuple = tuple(round(n) for n in (1, 5, 252 / 12, 252 / 4, 252 / 2, 252, 252 * 2, 252 * 3)),\n    dca_steps: tuple = tuple(round(n) for n in (1, 5, 10, 252 / 12, 252 / 4)),\n    trial_durations: tuple = tuple(round(n) for n in (252 * 3, 252 * 5)),\n    starting_cash: float = 1000,\n    start_step: int = 5,\n    save_df: bool = True,\n    analyze_results: bool = True,\n) -&gt; pd.DataFrame | tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Run DCA optimization across many parameter combinations.\n\n    Parameters\n    ----------\n    price_history : pd.Series\n        Series of \"Adj Close\" or \"Close\" float values.\n    ticker : str, optional\n        Ticker symbol for labeling output.\n    ratio_range : tuple\n        Ratios of amount to invest on first DCA day over last DCA day.\n    dca_durations : tuple\n        Number of periods to DCA over.\n    dca_steps : tuple\n        Number of periods between DCA purchases.\n    trial_durations : tuple\n        Total number of periods per trial.\n    starting_cash : float\n        Starting cash amount.\n    start_step : int\n        Periods to advance trial starting point between trials.\n    save_df : bool\n        Whether to save results to parquet.\n    analyze_results : bool\n        Whether to return analyzed results or raw DataFrame.\n\n    Raises\n    ------\n    ValueError\n        If price_history is None or empty.\n    \"\"\"\n    # Input validation\n    if price_history is None or price_history.empty:\n        raise ValueError(\"price_history cannot be None or empty\")\n\n    closes = tuple(price_history)\n    start_idxs = tuple(start_step * n for n in range((len(price_history) - max(trial_durations)) // start_step))\n\n    # Create DCAParameters objects for each combination\n    params_list = [\n        DCAParameters(\n            start_idx=start_idx,\n            ratio=ratio,\n            dca_duration=dca_duration,\n            dca_step=dca_step,\n            trial_duration=trial_duration,\n            closes=closes,\n            starting_cash=starting_cash,\n        )\n        for start_idx, ratio, dca_duration, dca_step, trial_duration in itertools.product(\n            start_idxs, ratio_range, dca_durations, dca_steps, trial_durations\n        )\n    ]\n\n    n_combs = len(params_list)\n    data = process_map(_mp_helper, params_list, total=n_combs, chunksize=1000, desc=f\"Running DCA Optimizer - {ticker}\")\n\n    price_hist_idxs = price_history.index\n    df = _convert_to_df(data, price_hist_idxs)\n    if save_df:\n        file_name = f\"{ticker if ticker else str(pd.Timestamp.now())} - DCA Optimizer.parquet\"\n        df.to_parquet(BACKTESTS_DATA_DIR / file_name)\n\n    if analyze_results:\n        return analyze_results_helper(df)\n    return df\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#parameters-explained","title":"Parameters Explained","text":""},{"location":"api/services/optimization/dca-optimizer/#ratio_linspace","title":"ratio_linspace","text":"<p>Defines the range of allocation ratios to test: - Format: <code>(start, stop, num_points)</code> - Example: <code>(0.5, 0.95, 10)</code> tests 50%, 55%, 60%, ..., 95% in asset 1 - Interpretation: <code>ratio</code> is allocation to first asset, <code>1-ratio</code> is allocation to second</p>"},{"location":"api/services/optimization/dca-optimizer/#dca_duration_days","title":"dca_duration_days","text":"<p>How long the DCA accumulation period lasts: - Short (1-2 years): Better for fast-moving bull markets - Medium (3-5 years): Balanced, averages out volatility - Long (7-10 years): Better for volatile markets, maximum cost averaging</p>"},{"location":"api/services/optimization/dca-optimizer/#dca_step_days","title":"dca_step_days","text":"<p>Frequency of purchases during DCA period: - Daily (1): Maximum cost averaging, high transaction costs - Weekly (7): Good balance - Monthly (30): Standard DCA approach, realistic for most investors - Quarterly (90): Minimal transactions, less cost averaging benefit</p>"},{"location":"api/services/optimization/dca-optimizer/#trial_duration_days","title":"trial_duration_days","text":"<p>Total time horizon for evaluation (must be &gt; dca_duration_days): - Should be 2-3x dca_duration_days for meaningful results - Includes both accumulation (DCA) and hold period - Example: 5-year DCA + 5-year hold = 10-year trial</p>"},{"location":"api/services/optimization/dca-optimizer/#optimization-metrics","title":"Optimization Metrics","text":"<p>The optimizer calculates these metrics for each combination:</p> Metric Description Interpretation CAGR Compound Annual Growth Rate Higher is better (growth) Sharpe Risk-adjusted return (Rf=2%) Higher is better (&gt;1 good, &gt;2 excellent) Sortino Downside risk-adjusted return Higher is better (focuses on negative volatility) Max Drawdown Largest peak-to-trough decline Lower is better (risk metric) Std Dev Annualized volatility Lower is better (risk metric) <p>Results are sorted by Sharpe ratio (best risk-adjusted return).</p>"},{"location":"api/services/optimization/dca-optimizer/#performance","title":"Performance","text":"<p>Based on comprehensive benchmarks:</p> Test Case Combinations Time (s) Rate (comb/s) Simple 500 7.10 70.4 Medium 1,000 13.22 75.6 Large 2,000 26.45 75.6 <p>Key Findings: - Consistent ~70-80 combinations/second across data sizes - Multiprocessing scales well with parameter space - Can evaluate 1,000 strategies in ~13 seconds</p>"},{"location":"api/services/optimization/dca-optimizer/#examples","title":"Examples","text":""},{"location":"api/services/optimization/dca-optimizer/#classic-6040-validation","title":"Classic 60/40 Validation","text":"<p>Test if 60/40 SPY/TLT is optimal:</p> <pre><code>results = dca_optimizer(\n    price_history=spy_tlt_combined,\n    ratio_linspace=(0.4, 0.8, 9),  # Test 40% to 80% SPY\n    dca_duration_days=365 * 5,\n    dca_step_days=30,\n    trial_duration_days=365 * 15\n)\n\n# Find 60/40 allocation\nrow_60_40 = results[abs(results['ratio'] - 0.6) &lt; 0.01]\nprint(f\"60/40 Sharpe: {row_60_40.iloc[0]['sharpe']:.2f}\")\nprint(f\"Best Sharpe: {results.iloc[0]['sharpe']:.2f}\")\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#leveraged-portfolio-optimization","title":"Leveraged Portfolio Optimization","text":"<p>Optimize UPRO/TMF allocation:</p> <pre><code>upro = get_history('UPRO')['Close']\ntmf = get_history('TMF')['Close']\ncombined = pd.DataFrame({'UPRO': upro, 'TMF': tmf}).dropna()\n\nresults = dca_optimizer(\n    price_history=combined,\n    ratio_linspace=(0.3, 0.7, 9),  # Test 30% to 70% UPRO\n    dca_duration_days=365 * 3,  # Shorter for leveraged\n    dca_step_days=30,\n    trial_duration_days=365 * 10\n)\n\nprint(f\"Optimal UPRO allocation: {results.iloc[0]['ratio']:.0%}\")\nprint(f\"Expected CAGR: {results.iloc[0]['cagr']:.2%}\")\nprint(f\"Expected Max DD: {results.iloc[0]['max_dd']:.2%}\")\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#dca-duration-sensitivity","title":"DCA Duration Sensitivity","text":"<p>Test impact of DCA duration:</p> <pre><code>durations = [365, 365*2, 365*3, 365*5, 365*7]\nduration_results = []\n\nfor duration in durations:\n    results = dca_optimizer(\n        price_history=combined,\n        ratio_linspace=(0.6, 0.6, 1),  # Fixed 60% allocation\n        dca_duration_days=duration,\n        dca_step_days=30,\n        trial_duration_days=duration * 2\n    )\n    duration_results.append({\n        'duration_years': duration / 365,\n        'sharpe': results.iloc[0]['sharpe'],\n        'cagr': results.iloc[0]['cagr']\n    })\n\nduration_df = pd.DataFrame(duration_results)\nprint(duration_df)\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#purchase-frequency-comparison","title":"Purchase Frequency Comparison","text":"<p>Test daily vs weekly vs monthly purchases:</p> <pre><code>frequencies = [1, 7, 30, 90]  # Daily, weekly, monthly, quarterly\nfreq_results = []\n\nfor freq in frequencies:\n    results = dca_optimizer(\n        price_history=combined,\n        ratio_linspace=(0.6, 0.6, 1),\n        dca_duration_days=365 * 5,\n        dca_step_days=freq,\n        trial_duration_days=365 * 10\n    )\n    freq_results.append({\n        'frequency': f\"Every {freq} days\",\n        'sharpe': results.iloc[0]['sharpe'],\n        'num_purchases': 365 * 5 // freq\n    })\n\nfreq_df = pd.DataFrame(freq_results)\nprint(freq_df)\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#results-dataframe","title":"Results DataFrame","text":"<p>The optimizer returns a pandas DataFrame with these columns:</p> <pre><code>&gt;&gt;&gt; results.columns\nIndex(['start_idx', 'ratio', 'cagr', 'sharpe', 'sortino', 'max_dd', 'std'], dtype='object')\n\n&gt;&gt;&gt; results.dtypes\nstart_idx      int64\nratio        float64\ncagr         float64\nsharpe       float64\nsortino      float64\nmax_dd       float64\nstd          float64\ndtype: object\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#column-descriptions","title":"Column Descriptions","text":"<ul> <li>start_idx: Starting index in price history for this trial</li> <li>ratio: Allocation ratio to first asset (0-1)</li> <li>cagr: Compound annual growth rate (decimal, e.g., 0.12 = 12%)</li> <li>sharpe: Sharpe ratio with 2% risk-free rate</li> <li>sortino: Sortino ratio (downside risk only)</li> <li>max_dd: Maximum drawdown (decimal, e.g., -0.20 = -20%)</li> <li>std: Annualized standard deviation (volatility)</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/#multiprocessing","title":"Multiprocessing","text":"<p>The optimizer uses <code>multiprocessing.Pool</code> to parallelize trials:</p> <pre><code># Automatically uses all available CPU cores minus 1\nnum_workers = multiprocessing.cpu_count() - 1\n\nwith Pool(num_workers) as pool:\n    results = pool.map(_mp_helper, parameter_combinations)\n</code></pre> <p>Benefits: - Linear speedup with CPU cores (4 cores \u2248 4x faster) - Evaluates independent trials in parallel - Automatically chunks work across processes</p> <p>Considerations: - Overhead for small parameter spaces (&lt;100 combinations) - Memory usage scales with number of workers - Not compatible with Jupyter notebooks (use <code>if __name__ == '__main__'</code>)</p>"},{"location":"api/services/optimization/dca-optimizer/#limitations","title":"Limitations","text":"<ul> <li>Two assets only: Current implementation supports 2-asset portfolios</li> <li>Equal purchase amounts: Buys equal dollar amounts at each step</li> <li>No transaction costs: Assumes zero trading fees</li> <li>Historical data: Optimizes on past data (risk of overfitting)</li> <li>Static allocation: Doesn't consider dynamic rebalancing during DCA</li> <li>No dividends: Price appreciation only</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/#best-practices","title":"Best Practices","text":"<ol> <li>Use sufficient trial duration: At least 2x DCA duration</li> <li>Test multiple periods: Don't rely on single historical period</li> <li>Consider transaction costs: Adjust for your broker's fees</li> <li>Validate on out-of-sample data: Test on recent data not used for optimization</li> <li>Use Monte Carlo: Complement with forward-looking simulations</li> <li>Consider taxes: Optimize after-tax returns if relevant</li> </ol>"},{"location":"api/services/optimization/dca-optimizer/#see-also","title":"See Also","text":"<ul> <li>Research: DCA Optimization Findings - Detailed research results</li> <li>Monte Carlo Simulator - Forward-looking risk analysis</li> <li>Rebalance Optimizer - Post-accumulation rebalancing</li> <li>Performance Benchmarks - Optimization performance analysis</li> </ul>"},{"location":"api/services/simulation/bond-ladder/","title":"Bond Ladder Simulator","text":"<p>The bond ladder simulator models fixed-income portfolios with staggered maturities, accounting for yield curves, reinvestment, and present value calculations.</p>"},{"location":"api/services/simulation/bond-ladder/#overview","title":"Overview","text":"<p>The bond ladder simulator provides:</p> <ul> <li>Bond modeling: Individual bond cash flows with coupon payments</li> <li>Ladder construction: Portfolios with staggered maturities (e.g., 1-10 years)</li> <li>Yield curve integration: Historical yield data from FRED</li> <li>Present value calculation: Using <code>numpy_financial.pv()</code></li> <li>Reinvestment simulation: Maturing bonds reinvested at current yields</li> </ul>"},{"location":"api/services/simulation/bond-ladder/#modules","title":"Modules","text":""},{"location":"api/services/simulation/bond-ladder/#bond-ladder-simulator_1","title":"Bond Ladder Simulator","text":"<p>Main simulation orchestrator:</p>"},{"location":"api/services/simulation/bond-ladder/#finbot.services.simulation.bond_ladder.bond_ladder_simulator","title":"finbot.services.simulation.bond_ladder.bond_ladder_simulator","text":"<p>Bond ladder simulator \u2014 replaces numba typed.Dict/List with plain Python.</p>"},{"location":"api/services/simulation/bond-ladder/#finbot.services.simulation.bond_ladder.bond_ladder_simulator.bond_ladder_simulator","title":"bond_ladder_simulator","text":"<pre><code>bond_ladder_simulator(\n    min_maturity_years: int,\n    max_maturity_years: int,\n    yield_history: DataFrame | None = None,\n    save_db: bool = True,\n) -&gt; pd.DataFrame\n</code></pre> <p>Simulate a bond ladder fund.</p> <p>Sources: https://www.bogleheads.org/forum/viewtopic.php?f=10&amp;t=179425 https://github.com/hoostus/prime-harvesting/blob/master/Bond%20Fund%20Simulator.ipynb</p> Source code in <code>finbot/services/simulation/bond_ladder/bond_ladder_simulator.py</code> <pre><code>def bond_ladder_simulator(\n    min_maturity_years: int,\n    max_maturity_years: int,\n    yield_history: pd.DataFrame | None = None,\n    save_db: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulate a bond ladder fund.\n\n    Sources:\n    https://www.bogleheads.org/forum/viewtopic.php?f=10&amp;t=179425\n    https://github.com/hoostus/prime-harvesting/blob/master/Bond%20Fund%20Simulator.ipynb\n    \"\"\"\n    print(\"Getting yield_history for bond fund/index simulator...\")\n    if yield_history is None:\n        yield_history = get_yield_history()\n\n    print(f\"Simulating {min_maturity_years}-{max_maturity_years} bond ladder fund...\")\n    periods_per_year = get_periods_per_year(yield_history)\n    first_yh_row = yield_history.iloc[0]\n\n    # Bootstrap initial rates\n    bootstrap_rates = pd.DataFrame([first_yh_row for _ in range(periods_per_year - 1)])\n    yield_history_concat = pd.concat((bootstrap_rates, yield_history), axis=0)\n\n    min_periods = min_maturity_years * periods_per_year\n    max_periods = max_maturity_years * periods_per_year\n\n    # Convert first row to dict for build_yield_curve\n    first_rates_dict: dict[str, float] = {str(k): float(v) for k, v in first_yh_row.to_dict().items()}\n    initial_yields = build_yield_curve(first_rates_dict, max_periods, periods_per_year)\n    ladder = make_annual_ladder(max_periods, min_periods, initial_yields, periods_per_year)\n\n    # Convert yield history to list of (timestamp, rates_dict) tuples\n    yield_history_rows = [(idx, row.to_dict()) for idx, row in yield_history_concat.iterrows()]\n\n    sim_closes = loop(ladder, yield_history_rows, max_periods, periods_per_year)\n\n    fund_indexes = list(sim_closes.keys())\n    fund_closes = pd.Series(list(sim_closes.values()))\n    fund_closes *= 1 / fund_closes.iloc[0]  # Scale fund to start at 1\n    fund_changes = fund_closes.pct_change()\n\n    fund = pd.DataFrame({\"Close\": fund_closes.values, \"Change\": fund_changes.values})\n    assert len(fund) == len(fund_closes) == len(fund_indexes) == len(yield_history)\n    fund.index = fund_indexes\n\n    if save_db:\n        _save_fund_to_db(fund)\n\n    return fund\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#bond-class","title":"Bond Class","text":"<p>Individual bond representation:</p>"},{"location":"api/services/simulation/bond-ladder/#finbot.services.simulation.bond_ladder.bond","title":"finbot.services.simulation.bond_ladder.bond","text":"<p>Bond class \u2014 replaces numba @jitclass with plain Python class.</p>"},{"location":"api/services/simulation/bond-ladder/#ladder-class","title":"Ladder Class","text":"<p>Bond ladder portfolio:</p>"},{"location":"api/services/simulation/bond-ladder/#finbot.services.simulation.bond_ladder.ladder","title":"finbot.services.simulation.bond_ladder.ladder","text":"<p>BondLadder class \u2014 replaces numba @jitclass with plain Python.</p>"},{"location":"api/services/simulation/bond-ladder/#yield-curve-builder","title":"Yield Curve Builder","text":"<p>Constructs yield curves from FRED data:</p>"},{"location":"api/services/simulation/bond-ladder/#finbot.services.simulation.bond_ladder.build_yield_curve","title":"finbot.services.simulation.bond_ladder.build_yield_curve","text":"<p>Build yield curve \u2014 replaces numba @njit with plain numpy.</p>"},{"location":"api/services/simulation/bond-ladder/#finbot.services.simulation.bond_ladder.build_yield_curve.build_yield_curve","title":"build_yield_curve","text":"<pre><code>build_yield_curve(\n    raw_rates: dict[str, float],\n    yield_curve_size: int,\n    periods_per_year: int,\n) -&gt; np.ndarray\n</code></pre> <p>Splice different raw rates together to build a yield curve.</p> Source code in <code>finbot/services/simulation/bond_ladder/build_yield_curve.py</code> <pre><code>def build_yield_curve(raw_rates: dict[str, float], yield_curve_size: int, periods_per_year: int) -&gt; np.ndarray:\n    \"\"\"Splice different raw rates together to build a yield curve.\"\"\"\n    ordered_rates_names = [\n        \"DGS1\",\n        \"DGS2\",\n        \"DGS3\",\n        \"DGS5\",\n        \"DGS7\",\n        \"DGS10\",\n        \"DGS20\",\n        \"DGS30\",\n        \"GS1\",\n        \"One-Year Interest Rate\",\n        \"Long Interest Rate GS10\",\n        \"GS2\",\n        \"GS3\",\n        \"GS5\",\n        \"GS7\",\n        \"GS10\",\n        \"GS20\",\n        \"GS30\",\n        \"TB4WK\",\n        \"CD1M\",\n        \"TB3MS\",\n        \"M1329AUSM193NNBR\",\n        \"TB6MS\",\n    ]\n    ordered_rates = [raw_rates.get(name, np.nan) for name in ordered_rates_names]\n    ordered_rate_maturities = [\n        n * periods_per_year - 1\n        for n in (\n            1,\n            2,\n            3,\n            5,\n            7,\n            10,\n            20,\n            30,\n            1,\n            1,\n            10,\n            2,\n            3,\n            5,\n            7,\n            10,\n            20,\n            30,\n            round(4 / 52),\n            round(1 / 12),\n            round(3 / 12),\n            round(3 / 12),\n            round(6 / 12),\n        )\n    ]\n\n    assert len(ordered_rates) == len(ordered_rate_maturities)\n\n    yield_curve = _splice_rates(yield_curve_size, ordered_rates, ordered_rate_maturities)\n    return yield_curve\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#quick-start","title":"Quick Start","text":""},{"location":"api/services/simulation/bond-ladder/#basic-bond-ladder","title":"Basic Bond Ladder","text":"<pre><code>from finbot.services.simulation.bond_ladder.bond_ladder_simulator import simulate_bond_ladder\nfrom finbot.services.simulation.bond_ladder.build_yield_curve import build_yield_curve\nimport pandas as pd\n\n# Build yield curve from FRED data\nyield_curve = build_yield_curve(\n    start_date='2010-01-01',\n    end_date='2024-01-01'\n)\n\n# Simulate 10-year ladder with $100,000\nresults = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    yield_curve=yield_curve,\n    coupon_frequency='semiannual'\n)\n\nprint(f\"Total value: ${results['total_value'][-1]:,.0f}\")\nprint(f\"Total return: {(results['total_value'][-1] / 100000 - 1) * 100:.2f}%\")\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#custom-ladder-configuration","title":"Custom Ladder Configuration","text":"<pre><code># 5-year ladder with quarterly coupons\nresults = simulate_bond_ladder(\n    initial_investment=50000,\n    ladder_years=5,\n    yield_curve=yield_curve,\n    coupon_frequency='quarterly',\n    reinvestment_strategy='extend_ladder'\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#ladder-strategies","title":"Ladder Strategies","text":""},{"location":"api/services/simulation/bond-ladder/#traditional-ladder","title":"Traditional Ladder","text":"<p>Equal amounts invested across maturities:</p> <pre><code># $100,000 across 10 bonds (1-10 years)\n# Each bond: $10,000\nladder = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    allocation='equal'\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#barbell-ladder","title":"Barbell Ladder","text":"<p>Concentrated at short and long maturities:</p> <pre><code># 50% in 1-year, 50% in 10-year\nladder = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    allocation='barbell',\n    short_weight=0.5,\n    long_weight=0.5\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#bullet-ladder","title":"Bullet Ladder","text":"<p>Concentrated at specific maturity:</p> <pre><code># All maturing in year 5\nladder = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=5,\n    allocation='bullet',\n    target_year=5\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#bond-mechanics","title":"Bond Mechanics","text":""},{"location":"api/services/simulation/bond-ladder/#coupon-payments","title":"Coupon Payments","text":"<p>Bonds pay periodic interest:</p> <pre><code>from finbot.services.simulation.bond_ladder.bond import Bond\n\n# 5-year bond with 3% coupon, semiannual payments\nbond = Bond(\n    face_value=10000,\n    coupon_rate=0.03,\n    years_to_maturity=5,\n    coupon_frequency='semiannual'\n)\n\n# Get cash flows\ncash_flows = bond.get_cash_flows()\n# Returns: [(0.5 years, $150), (1.0 years, $150), ..., (5.0 years, $10,150)]\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#present-value","title":"Present Value","text":"<p>Bonds are valued using discount rates:</p> <pre><code>import numpy_financial as npf\n\n# Present value of 5-year bond with 3% coupon at 4% discount rate\npv = npf.pv(\n    rate=0.04 / 2,  # Semiannual discounting\n    nper=10,  # 5 years \u00d7 2 periods/year\n    pmt=150,  # $150 coupon payment\n    fv=10000  # $10,000 face value\n)\n\nprint(f\"Present value: ${-pv:,.2f}\")  # Negative because it's a cost\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#yield-curve","title":"Yield Curve","text":"<p>Historical yields from FRED:</p> <pre><code>from finbot.services.simulation.bond_ladder.get_yield_history import get_yield_history\n\n# Get 10-year Treasury yields\nyields_10y = get_yield_history(\n    symbol='DGS10',  # FRED symbol for 10-year constant maturity\n    start_date='2010-01-01',\n    end_date='2024-01-01'\n)\n\nprint(f\"Average 10Y yield: {yields_10y.mean():.2%}\")\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#reinvestment-strategies","title":"Reinvestment Strategies","text":""},{"location":"api/services/simulation/bond-ladder/#extend-ladder","title":"Extend Ladder","text":"<p>Reinvest maturing bonds at longest maturity:</p> <pre><code># When 1-year bond matures, buy new 10-year bond\nresults = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    reinvestment_strategy='extend_ladder'\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#maintain-maturity","title":"Maintain Maturity","text":"<p>Reinvest at same maturity:</p> <pre><code># When 1-year bond matures, buy new 1-year bond\nresults = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    reinvestment_strategy='maintain_maturity'\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#roll-down","title":"Roll Down","text":"<p>Reinvest at next shorter maturity:</p> <pre><code># When 1-year bond matures, take cash (exit ladder)\nresults = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    reinvestment_strategy='roll_down'\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#advanced-features","title":"Advanced Features","text":""},{"location":"api/services/simulation/bond-ladder/#interest-rate-sensitivity","title":"Interest Rate Sensitivity","text":"<p>Measure duration and convexity:</p> <pre><code># Duration: sensitivity to interest rate changes\nduration = calculate_duration(bond, yield_rate=0.03)\nprint(f\"Macaulay duration: {duration:.2f} years\")\n\n# Price change for 1% rate increase\nprice_change = -duration * 0.01 * bond.present_value\nprint(f\"Expected price change: ${price_change:,.2f}\")\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#total-return-analysis","title":"Total Return Analysis","text":"<p>Decompose returns into components:</p> <pre><code>results = simulate_bond_ladder(...)\n\n# Components:\n# - Coupon income\n# - Price appreciation/depreciation\n# - Reinvestment income\n\ntotal_return = results['total_value'][-1] / results['total_value'][0] - 1\ncoupon_return = results['coupon_income'].sum() / results['total_value'][0]\ncapital_return = total_return - coupon_return\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#data-requirements","title":"Data Requirements","text":""},{"location":"api/services/simulation/bond-ladder/#yield-curve-data","title":"Yield Curve Data","text":"<p>Required FRED symbols for complete yield curve:</p> Maturity FRED Symbol Description 1 month DGS1MO 1-Month Treasury 3 months DGS3MO 3-Month Treasury 6 months DGS6MO 6-Month Treasury 1 year DGS1 1-Year Treasury 2 years DGS2 2-Year Treasury 3 years DGS3 3-Year Treasury 5 years DGS5 5-Year Treasury 7 years DGS7 7-Year Treasury 10 years DGS10 10-Year Treasury 20 years DGS20 20-Year Treasury 30 years DGS30 30-Year Treasury"},{"location":"api/services/simulation/bond-ladder/#performance","title":"Performance","text":"<p>The bond ladder simulator:</p> <ul> <li>Processes 16,000+ trading days in seconds</li> <li>Uses vectorized NumPy operations</li> <li>Replaced numba <code>@jitclass</code> with plain Python classes</li> <li>Uses <code>numpy_financial.pv()</code> for present value calculations</li> </ul>"},{"location":"api/services/simulation/bond-ladder/#limitations","title":"Limitations","text":"<ul> <li>No default risk: Assumes all bonds pay as promised (Treasury assumption)</li> <li>No callability: Bonds cannot be called early</li> <li>No inflation protection: Nominal yields, not TIPS</li> <li>Simplified taxes: No tax modeling</li> <li>No transaction costs: Assumes frictionless reinvestment</li> </ul>"},{"location":"api/services/simulation/bond-ladder/#use-cases","title":"Use Cases","text":""},{"location":"api/services/simulation/bond-ladder/#retirement-income","title":"Retirement Income","text":"<p>Create predictable cash flow stream:</p> <pre><code># Retiree needing $50,000/year for 20 years\nladder = simulate_bond_ladder(\n    initial_investment=1000000,\n    ladder_years=20,\n    target_annual_income=50000\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#liability-matching","title":"Liability Matching","text":"<p>Match bond maturities to known future expenses:</p> <pre><code># College expenses: $30k/year for years 1-4\nladder = simulate_bond_ladder(\n    initial_investment=120000,\n    ladder_years=4,\n    allocation=[30000, 30000, 30000, 30000]\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#interest-rate-hedging","title":"Interest Rate Hedging","text":"<p>Diversify reinvestment risk across maturities:</p> <pre><code># 10-year ladder reduces timing risk\nladder = simulate_bond_ladder(\n    initial_investment=100000,\n    ladder_years=10,\n    allocation='equal'\n)\n</code></pre>"},{"location":"api/services/simulation/bond-ladder/#see-also","title":"See Also","text":"<ul> <li>Fund Simulator - Leveraged ETF simulation</li> <li>Monte Carlo - Risk analysis with simulated data</li> <li>FRED Data Collection - Yield data retrieval</li> <li>Example Notebook 05 - Interactive examples</li> </ul>"},{"location":"api/services/simulation/fund-simulator/","title":"Fund Simulator","text":"<p>The fund simulator models leveraged ETFs with realistic fees, borrowing costs, and spread expenses. It uses vectorized NumPy operations for high performance.</p>"},{"location":"api/services/simulation/fund-simulator/#overview","title":"Overview","text":"<p>The fund simulator:</p> <ul> <li>Simulates leveraged fund returns from underlying index data</li> <li>Accounts for expense ratios, borrowing costs (LIBOR), and spread</li> <li>Uses adjustment constants calibrated to real ETF data</li> <li>Processes 40 years of data in ~110ms (92,000 trading days/second)</li> <li>Validates against actual ETF performance with 2-5% tracking error</li> </ul>"},{"location":"api/services/simulation/fund-simulator/#key-functions","title":"Key Functions","text":""},{"location":"api/services/simulation/fund-simulator/#simulate_fund","title":"simulate_fund","text":"<p>Generic fund simulation function that looks up configuration from registry:</p>"},{"location":"api/services/simulation/fund-simulator/#finbot.services.simulation.sim_specific_funds.simulate_fund","title":"finbot.services.simulation.sim_specific_funds.simulate_fund","text":"<pre><code>simulate_fund(\n    ticker: str,\n    underlying=None,\n    libor_yield_df=None,\n    save_sim: bool = True,\n    force_update: bool = False,\n    adj=None,\n    overwrite_sim_with_fund: bool | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Simulate any fund by ticker using configuration registry.</p> <p>This is the new recommended way to simulate funds. It uses a data-driven configuration approach that's easier to maintain and extend.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Fund ticker symbol (e.g., \"SPY\", \"UPRO\", \"TQQQ\")</p> required <code>underlying</code> <p>Pre-computed underlying index price history (optional)</p> <code>None</code> <code>libor_yield_df</code> <p>LIBOR yield data for swap cost calculation (optional)</p> <code>None</code> <code>save_sim</code> <code>bool</code> <p>Whether to save simulation to disk (default: True)</p> <code>True</code> <code>force_update</code> <code>bool</code> <p>Force regeneration even if cached version exists (default: False)</p> <code>False</code> <code>adj</code> <p>Override additive constant (default: use config value)</p> <code>None</code> <code>overwrite_sim_with_fund</code> <code>bool | None</code> <p>Override config setting for actual data merge</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with simulated fund price history (columns: \"Close\", \"Change\")</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If ticker is not in FUND_CONFIGS registry</p> Example <p>spy_sim = simulate_fund(\"SPY\") upro_sim = simulate_fund(\"UPRO\", force_update=True)</p> Source code in <code>finbot/services/simulation/sim_specific_funds.py</code> <pre><code>def simulate_fund(\n    ticker: str,\n    underlying=None,\n    libor_yield_df=None,\n    save_sim: bool = True,\n    force_update: bool = False,\n    adj=None,\n    overwrite_sim_with_fund: bool | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Simulate any fund by ticker using configuration registry.\n\n    This is the new recommended way to simulate funds. It uses a data-driven\n    configuration approach that's easier to maintain and extend.\n\n    Parameters:\n        ticker: Fund ticker symbol (e.g., \"SPY\", \"UPRO\", \"TQQQ\")\n        underlying: Pre-computed underlying index price history (optional)\n        libor_yield_df: LIBOR yield data for swap cost calculation (optional)\n        save_sim: Whether to save simulation to disk (default: True)\n        force_update: Force regeneration even if cached version exists (default: False)\n        adj: Override additive constant (default: use config value)\n        overwrite_sim_with_fund: Override config setting for actual data merge\n\n    Returns:\n        DataFrame with simulated fund price history (columns: \"Close\", \"Change\")\n\n    Raises:\n        ValueError: If ticker is not in FUND_CONFIGS registry\n\n    Example:\n        &gt;&gt;&gt; spy_sim = simulate_fund(\"SPY\")\n        &gt;&gt;&gt; upro_sim = simulate_fund(\"UPRO\", force_update=True)\n    \"\"\"\n    ticker_upper = ticker.upper()\n    if ticker_upper not in FUND_CONFIGS:\n        available = \", \".join(sorted(FUND_CONFIGS.keys()))\n        raise ValueError(f\"Unknown fund ticker: {ticker}. Available funds: {available}\")\n\n    config = FUND_CONFIGS[ticker_upper]\n\n    # Use config's overwrite setting unless explicitly overridden\n    overwrite = config.overwrite_sim_with_fund if overwrite_sim_with_fund is None else overwrite_sim_with_fund\n\n    return _sim_fund(\n        config.name,\n        config.underlying_func,\n        config.leverage_mult,\n        config.annual_er_pct,\n        config.percent_daily_spread_cost,\n        config.fund_swap_pct,\n        config.additive_constant,\n        underlying,\n        libor_yield_df,\n        save_sim,\n        force_update,\n        adj,\n        overwrite,\n    )\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#fund_simulator","title":"fund_simulator","text":"<p>Core simulation function with full parameter control:</p>"},{"location":"api/services/simulation/fund-simulator/#finbot.services.simulation.fund_simulator.fund_simulator","title":"finbot.services.simulation.fund_simulator.fund_simulator","text":"<pre><code>fund_simulator(\n    price_df: DataFrame,\n    leverage_mult: float = 1,\n    annual_er_pct: float = 0.5 / 100,\n    percent_daily_spread_cost: float = 0,\n    fund_swap_pct: float = 0,\n    periods_per_year: int = 250,\n    multiplicative_constant: float = 1,\n    additive_constant: float = 0,\n    libor_yield_df: DataFrame | Series | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Returns a pd.DataFrame fund simulation with \"Close\" and percent \"Change\" values.</p> <p>Parameters:</p> Name Type Description Default <code>price_df</code> <code>DataFrame</code> <p>DataFrame with Timestamp index and \"Close\" or \"Adj Close\" column.</p> required <code>leverage_mult</code> <code>float</code> <p>Leverage multiplier applied to underlying daily pct change.</p> <code>1</code> <code>annual_er_pct</code> <code>float</code> <p>Annual expense ratio (decimal form).</p> <code>0.5 / 100</code> <code>percent_daily_spread_cost</code> <code>float</code> <p>Spread cost (decimal form) on the current fund date.</p> <code>0</code> <code>fund_swap_pct</code> <code>float</code> <p>Fraction of fund allocated to swap contracts.</p> <code>0</code> <code>periods_per_year</code> <code>int</code> <p>Number of compounding periods per year.</p> <code>250</code> <code>multiplicative_constant</code> <code>float</code> <p>Multiplicative curve fitting constant (1 = no effect).</p> <code>1</code> <code>additive_constant</code> <code>float</code> <p>Additive curve fitting constant (0 = no effect).</p> <code>0</code> <code>libor_yield_df</code> <code>DataFrame | Series | None</code> <p>DataFrame/Series with Timestamp index and \"Yield\" column.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with simulated \"Close\" and percent \"Change\" values.</p> Source code in <code>finbot/services/simulation/fund_simulator.py</code> <pre><code>def fund_simulator(\n    price_df: pd.DataFrame,\n    leverage_mult: float = 1,\n    annual_er_pct: float = 0.5 / 100,\n    percent_daily_spread_cost: float = 0,\n    fund_swap_pct: float = 0,\n    periods_per_year: int = 250,\n    multiplicative_constant: float = 1,\n    additive_constant: float = 0,\n    libor_yield_df: pd.DataFrame | pd.Series | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a pd.DataFrame fund simulation with \"Close\" and percent \"Change\" values.\n\n    Args:\n        price_df: DataFrame with Timestamp index and \"Close\" or \"Adj Close\" column.\n        leverage_mult: Leverage multiplier applied to underlying daily pct change.\n        annual_er_pct: Annual expense ratio (decimal form).\n        percent_daily_spread_cost: Spread cost (decimal form) on the current fund date.\n        fund_swap_pct: Fraction of fund allocated to swap contracts.\n        periods_per_year: Number of compounding periods per year.\n        multiplicative_constant: Multiplicative curve fitting constant (1 = no effect).\n        additive_constant: Additive curve fitting constant (0 = no effect).\n        libor_yield_df: DataFrame/Series with Timestamp index and \"Yield\" column.\n\n    Returns:\n        DataFrame with simulated \"Close\" and percent \"Change\" values.\n    \"\"\"\n    # Data validation\n    if (\n        libor_yield_df is not None\n        and hasattr(libor_yield_df, \"index\")\n        and libor_yield_df.index.dtype.name != \"datetime64[ns]\"\n    ):\n        raise ValueError(\n            f\"libor_yield_df must be indexed with dates of dtype datetime64[ns], not {libor_yield_df.index.dtype.name}\"\n        )\n    if price_df.index.dtype.name != \"datetime64[ns]\":\n        raise ValueError(\n            f\"price_df must be indexed with dates of dtype datetime64[ns], not {price_df.index.dtype.name}\"\n        )\n    casefold_cols = [n.casefold() for n in price_df.columns]\n    if \"close\" not in casefold_cols and \"adj close\" not in casefold_cols:\n        raise ValueError(\"price_df must contain 'Close' column or 'Adj Close' column\")\n\n    # Get/generate approximate overnight lending rate\n    if libor_yield_df is None:\n        libor_yield_df = approximate_overnight_libor()\n    # Ensure a \"Yield\" column or Series\n    if isinstance(libor_yield_df, pd.Series):\n        libor_yield_df = (\n            libor_yield_df.to_frame(name=\"Yield\") if libor_yield_df.name != \"Yield\" else libor_yield_df.to_frame()\n        )\n\n    # Ensure all dates in price_df are also in libor_yield_df\n    if not set(price_df.index).issubset(set(libor_yield_df.index)):\n        libor_yield_df = pd.concat([libor_yield_df, price_df], axis=1, join=\"outer\")\n        libor_yield_df = pd.DataFrame(libor_yield_df[\"Yield\"]).interpolate().bfill()\n\n    logger.info(\"Building fund simulation...\")\n    # Get the close column to use (\"Adj Close\" has priority)\n    close_col = \"Adj Close\" if \"Adj Close\" in price_df.columns else \"Close\"\n    underlying_changes = price_df[close_col].pct_change().to_numpy()\n    underlying_changes[0] = 0\n    period_libor_yield_percents = libor_yield_df.loc[price_df.index, \"Yield\"].to_numpy() / 100\n\n    # Vectorized computation replacing numba @jit loop\n    changes = _compute_sim_changes(\n        underlying_changes=underlying_changes,\n        period_libor_yield_percents=period_libor_yield_percents,\n        leverage_mult=leverage_mult,\n        annual_er_pct=annual_er_pct,\n        percent_daily_spread_cost=percent_daily_spread_cost,\n        fund_swap_pct=fund_swap_pct,\n        periods_per_year=periods_per_year,\n        multiplicative_constant=multiplicative_constant,\n        additive_constant=additive_constant,\n    )\n\n    # Compute close values\n    mults = changes + 1\n    closes = mults.cumprod()\n\n    # Check for zero value event\n    zero_value_indexes = np.where(closes &lt;= 0)[0]\n    if len(zero_value_indexes):\n        zero_idx = zero_value_indexes[0]\n        closes = np.concatenate((closes[:zero_idx], np.zeros(len(closes[zero_idx:]))))\n\n    # Construct and return final df\n    fund_df = pd.DataFrame({\"Close\": closes, \"Change\": changes})\n    fund_df.index = price_df.index\n    return fund_df\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#simulation-equation","title":"Simulation Equation","text":"<p>The core simulation equation is:</p> <pre><code>simulated_return = (underlying_change * leverage - daily_expenses) * mult_constant + add_constant\n</code></pre> <p>Where: - <code>underlying_change</code>: Daily return of the underlying index - <code>leverage</code>: Leverage ratio (1x, 2x, 3x, -1x, -2x, -3x) - <code>daily_expenses</code>: Expense ratio + swap rate + spread + borrowing costs (LIBOR) - <code>mult_constant</code>: Multiplicative adjustment factor (typically 1.0) - <code>add_constant</code>: Additive adjustment factor (calibrated to real data)</p>"},{"location":"api/services/simulation/fund-simulator/#expense-components","title":"Expense Components","text":""},{"location":"api/services/simulation/fund-simulator/#expense-ratio","title":"Expense Ratio","text":"<p>Annual management fee charged by the fund: - SPY: 0.0945% (very low, index fund) - UPRO: 0.91% (leveraged, higher management) - TQQQ: 0.86% (leveraged)</p>"},{"location":"api/services/simulation/fund-simulator/#swap-rate-overnight-borrowing","title":"Swap Rate (Overnight Borrowing)","text":"<p>Cost to maintain leveraged positions overnight: - Approximated using overnight LIBOR rates - Applied as <code>LIBOR * leverage_factor</code> for leveraged funds - Zero for 1x funds</p>"},{"location":"api/services/simulation/fund-simulator/#spread","title":"Spread","text":"<p>Bid-ask spread and trading friction: - Default: 0.05% (5 basis points) - Higher for less liquid funds</p>"},{"location":"api/services/simulation/fund-simulator/#borrowing-costs","title":"Borrowing Costs","text":"<p>Additional costs for short positions and leverage beyond swap: - Zero for long-only 1x funds - Increases with leverage ratio</p>"},{"location":"api/services/simulation/fund-simulator/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.simulation.fund_simulator import simulate_fund\nfrom finbot.utils.data_collection_utils.yfinance import get_history\n\n# Simulate UPRO (3x leveraged S&amp;P 500)\nupro_sim = simulate_fund('UPRO', start_date='2010-01-01', end_date='2024-01-01')\n\n# Access simulation results\nprint(upro_sim.columns)  # ['Open', 'High', 'Low', 'Close', 'Volume', 'Dividends', 'Stock Splits']\nprint(f\"Total return: {(upro_sim['Close'][-1] / upro_sim['Close'][0] - 1) * 100:.2f}%\")\n\n# Custom parameters\ncustom_sim = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=2.0,\n    expense_ratio=0.01,\n    spread=0.0005,\n    swap_rate_df=libor_data,\n    mult_constant=1.0,\n    add_constant=0.0\n)\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#pre-configured-funds","title":"Pre-configured Funds","text":"<p>Finbot includes pre-configured simulations for 15 popular funds:</p>"},{"location":"api/services/simulation/fund-simulator/#stock-funds","title":"Stock Funds","text":"Fund Underlying Leverage Expense Ratio SPY S&amp;P 500 1x 0.0945% SSO S&amp;P 500 2x 0.91% UPRO S&amp;P 500 3x 0.91% QQQ Nasdaq 100 1x 0.20% QLD Nasdaq 100 2x 0.95% TQQQ Nasdaq 100 3x 0.86%"},{"location":"api/services/simulation/fund-simulator/#bond-funds","title":"Bond Funds","text":"Fund Underlying Leverage Expense Ratio TLT 20Y Treasury 1x 0.15% UBT 20Y Treasury 2x 0.95% TMF 20Y Treasury 3x 1.09% IEF 7-10Y Treasury 1x 0.15% UST 7-10Y Treasury 2x 0.95% TYD 7-10Y Treasury 3x 1.09% SHY 1-3Y Treasury 1x 0.15%"},{"location":"api/services/simulation/fund-simulator/#hybrid-funds","title":"Hybrid Funds","text":"Fund Underlying Composition NTSX 90% S&amp;P 500 + 60% Treasury futures 1.5x effective leverage"},{"location":"api/services/simulation/fund-simulator/#performance","title":"Performance","text":"<p>Based on comprehensive benchmarks:</p> Data Size Time (ms) Throughput (days/sec) 1 month (21 days) 91.67 \u00b1 10.52 ~230 1 year (252 days) 91.83 \u00b1 9.67 ~2,744 5 years (1,260 days) 93.22 \u00b1 9.93 ~13,517 10 years (2,520 days) 95.84 \u00b1 10.64 ~26,289 20 years (5,040 days) 101.80 \u00b1 11.48 ~49,500 40 years (10,080 days) 109.79 \u00b1 12.77 ~91,818 <p>Key Findings: - Sub-linear O(n) scaling: 480x data \u2192 1.2x time - Vectorized NumPy is faster than numba JIT compilation - Processes 40 years of daily data in ~110ms</p>"},{"location":"api/services/simulation/fund-simulator/#tracking-accuracy","title":"Tracking Accuracy","text":"<p>Simulations validate against actual ETF data:</p> Fund Tracking Error Sample Period UPRO 2-4% 2010-2024 TQQQ 3-5% 2010-2024 TMF 2-3% 2010-2024 <p>Tracking error sources: - LIBOR approximation (overnight vs 3-month) - Rebalancing timing differences - Dividend reinvestment assumptions - Intraday volatility (using daily data)</p>"},{"location":"api/services/simulation/fund-simulator/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/services/simulation/fund-simulator/#historical-extension","title":"Historical Extension","text":"<p>Simulate funds before their inception:</p> <pre><code># UPRO launched in 2009, simulate back to 1990\nupro_extended = simulate_fund('UPRO', start_date='1990-01-01', end_date='2024-01-01')\n\n# Compare to actual data\nactual_upro = get_history('UPRO', start='2009-06-25')\nsimulated_overlap = upro_extended.loc['2009-06-25':]\n\n# Calculate tracking error\ntracking_error = (simulated_overlap['Close'] / actual_upro['Close'] - 1).std()\nprint(f\"Tracking error: {tracking_error:.2%}\")\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#custom-fund-creation","title":"Custom Fund Creation","text":"<p>Create hypothetical funds with custom parameters:</p> <pre><code># Hypothetical 5x leveraged S&amp;P 500\nextreme_leverage = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=5.0,\n    expense_ratio=0.015,  # 1.5% expense ratio\n    spread=0.001,  # 10 bps spread\n    swap_rate_df=libor_data,\n    mult_constant=1.0,\n    add_constant=0.0\n)\n\n# Inverse leveraged fund\ninverse_fund = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=-2.0,  # 2x inverse\n    expense_ratio=0.0095,\n    spread=0.0005,\n    swap_rate_df=libor_data\n)\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>Test impact of different expense assumptions:</p> <pre><code>base_sim = simulate_fund('UPRO')\n\n# Higher expenses\nhigh_expense = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=3.0,\n    expense_ratio=0.02,  # 2% vs 0.91% actual\n    spread=0.001,\n    swap_rate_df=libor_data\n)\n\n# Compare performance\nbase_return = (base_sim['Close'][-1] / base_sim['Close'][0] - 1)\nhigh_expense_return = (high_expense['Close'][-1] / high_expense['Close'][0] - 1)\nexpense_drag = base_return - high_expense_return\nprint(f\"Expense drag: {expense_drag:.2%}\")\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#data-requirements","title":"Data Requirements","text":""},{"location":"api/services/simulation/fund-simulator/#price-data-format","title":"Price Data Format","text":"<p>Input <code>price_df</code> must be a pandas DataFrame with: - Index: DatetimeIndex (daily frequency) - Columns: <code>Open</code>, <code>High</code>, <code>Low</code>, <code>Close</code>, <code>Volume</code> - Format: Decimal (not percentage) prices</p>"},{"location":"api/services/simulation/fund-simulator/#libor-data-format","title":"LIBOR Data Format","text":"<p>Input <code>swap_rate_df</code> must be a pandas DataFrame with: - Index: DatetimeIndex matching price_df - Column: Interest rates as decimal (0.02 = 2%) - Source: Approximated overnight LIBOR from <code>approximate_overnight_libor()</code></p>"},{"location":"api/services/simulation/fund-simulator/#implementation-details","title":"Implementation Details","text":"<p>The simulator uses: - Vectorized NumPy: All operations vectorized for performance - Daily rebalancing: Leveraged positions rebalanced at close - Compound returns: Accurate multi-day return calculation - Missing data handling: Forward-fill for gaps in LIBOR data</p>"},{"location":"api/services/simulation/fund-simulator/#see-also","title":"See Also","text":"<ul> <li>Specific Funds - Pre-configured fund simulations</li> <li>Bond Ladder - Bond portfolio simulation</li> <li>Monte Carlo - Risk analysis with simulated data</li> <li>Performance Benchmarks - Detailed performance analysis</li> </ul>"},{"location":"api/services/simulation/monte-carlo/","title":"Monte Carlo Simulator","text":"<p>The Monte Carlo simulator generates probabilistic forecasts of portfolio performance using historical return distributions and random sampling.</p>"},{"location":"api/services/simulation/monte-carlo/#overview","title":"Overview","text":"<p>The Monte Carlo simulator:</p> <ul> <li>Generates thousands of possible future return paths</li> <li>Samples from historical return distributions</li> <li>Accounts for portfolio volatility and correlations</li> <li>Provides percentile analysis (5th, 25th, 50th, 75th, 95th)</li> <li>Tests withdrawal sustainability and retirement planning</li> <li>Visualizes probability distributions and confidence bands</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.simulation.monte_carlo.monte_carlo_simulator import monte_carlo_simulator\nimport pandas as pd\n\n# Load historical returns\nspy_returns = pd.read_parquet('spy_prices.parquet')['Close'].pct_change()\n\n# Run Monte Carlo simulation\nresults = monte_carlo_simulator(\n    returns_series=spy_returns,\n    num_trials=10000,\n    num_periods=252 * 30,  # 30 years of daily returns\n    starting_value=100000\n)\n\n# Analyze results\nprint(f\"Median final value: ${results['final_values'].median():,.0f}\")\nprint(f\"5th percentile: ${results['final_values'].quantile(0.05):,.0f}\")\nprint(f\"95th percentile: ${results['final_values'].quantile(0.95):,.0f}\")\n\n# Calculate probability of doubling investment\nprob_double = (results['final_values'] &gt;= 200000).sum() / len(results['final_values'])\nprint(f\"Probability of doubling: {prob_double:.1%}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#api-reference","title":"API Reference","text":""},{"location":"api/services/simulation/monte-carlo/#finbot.services.simulation.monte_carlo.monte_carlo_simulator.monte_carlo_simulator","title":"finbot.services.simulation.monte_carlo.monte_carlo_simulator.monte_carlo_simulator","text":"<pre><code>monte_carlo_simulator(\n    equity_data: DataFrame,\n    equity_start: Timestamp = _DEFAULT_EQUITY_START,\n    equity_end: Timestamp | None = None,\n    sim_periods: int = 252,\n    n_sims: int = 10000,\n    start_price: float | None = None,\n) -&gt; pd.DataFrame\n</code></pre> Source code in <code>finbot/services/simulation/monte_carlo/monte_carlo_simulator.py</code> <pre><code>def monte_carlo_simulator(\n    equity_data: pd.DataFrame,\n    equity_start: pd.Timestamp = _DEFAULT_EQUITY_START,\n    equity_end: pd.Timestamp | None = None,\n    sim_periods: int = 252,\n    n_sims: int = 10000,\n    start_price: float | None = None,\n) -&gt; pd.DataFrame:\n    if equity_end is None:\n        equity_end = pd.Timestamp.now()\n    equity_data = equity_data.truncate(before=equity_start, after=equity_end)\n\n    closes = equity_data[\"Adj Close\" if \"Adj Close\" in equity_data.columns else \"Close\"]\n    changes = closes.pct_change()\n    start_price = (\n        closes.iloc[-(sim_periods if len(closes) &gt;= sim_periods else 1)] if start_price is None else start_price\n    )\n    mu = changes.dropna().mean()\n    sigma = changes.dropna().std()\n\n    trials = np.array(\n        [\n            sim_type_nd(\n                sim_periods=sim_periods,\n                n_sims=n_sims,\n                start_price=start_price,\n                mu=mu,\n                sigma=sigma,\n                cov_matrix=None,\n            )\n            for _ in tqdm(range(n_sims), desc=\"Performing monte carlo simulation\")\n        ]\n    )\n\n    trials_df = pd.DataFrame(trials)\n    trials_df.index.name = \"Trials\"\n    trials_df.columns.name = \"Periods\"\n\n    return trials_df\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#simulation-types","title":"Simulation Types","text":""},{"location":"api/services/simulation/monte-carlo/#normal-distribution","title":"Normal Distribution","text":"<p>Assumes returns follow a normal distribution: - Mean = historical mean return - Std dev = historical volatility - Fastest method, but ignores skewness and kurtosis</p>"},{"location":"api/services/simulation/monte-carlo/#finbot.services.simulation.monte_carlo.sim_types.sim_type_nd","title":"finbot.services.simulation.monte_carlo.sim_types.sim_type_nd","text":"<pre><code>sim_type_nd(**kwargs) -&gt; np.ndarray\n</code></pre> <p>Normal distribution Monte Carlo simulation.</p> Source code in <code>finbot/services/simulation/monte_carlo/sim_types.py</code> <pre><code>def sim_type_nd(**kwargs) -&gt; np.ndarray:\n    \"\"\"Normal distribution Monte Carlo simulation.\"\"\"\n    sim_periods = kwargs[\"sim_periods\"]\n    start_price = kwargs[\"start_price\"]\n    mu = kwargs[\"mu\"]\n    sigma = kwargs[\"sigma\"]\n\n    daily_changes = np.random.normal(loc=mu + 1, scale=sigma, size=sim_periods)\n    daily_changes[0] = 1\n    cum_changes = np.cumprod(daily_changes)\n    price_array = cum_changes * start_price\n    return price_array\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#historical-bootstrap","title":"Historical Bootstrap","text":"<p>Randomly samples actual historical returns: - Preserves real return distribution - Captures fat tails and skewness - Requires sufficient historical data (&gt;1000 observations)</p>"},{"location":"api/services/simulation/monte-carlo/#output-structure","title":"Output Structure","text":"<p>The simulator returns a dictionary containing:</p> <pre><code>{\n    'trials': np.ndarray,  # Shape: (num_trials, num_periods)\n    'final_values': np.ndarray,  # Shape: (num_trials,)\n    'mean_path': np.ndarray,  # Shape: (num_periods,)\n    'percentiles': {\n        5: np.ndarray,  # 5th percentile path\n        25: np.ndarray,  # 25th percentile path\n        50: np.ndarray,  # 50th percentile (median)\n        75: np.ndarray,  # 75th percentile path\n        95: np.ndarray  # 95th percentile path\n    }\n}\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#examples","title":"Examples","text":""},{"location":"api/services/simulation/monte-carlo/#retirement-planning","title":"Retirement Planning","text":"<p>Test 4% withdrawal rule:</p> <pre><code># 60/40 portfolio returns\nportfolio_returns = 0.6 * spy_returns + 0.4 * tlt_returns\n\n# Run simulation with withdrawals\nstarting_value = 1_000_000\nannual_withdrawal = 40_000  # 4% rule\nyears = 30\n\nresults = monte_carlo_simulator(\n    returns_series=portfolio_returns,\n    num_trials=10000,\n    num_periods=252 * years,\n    starting_value=starting_value\n)\n\n# Simulate withdrawals\nwithdrawal_per_day = annual_withdrawal / 252\ntrials_with_withdrawals = results['trials'].copy()\n\nfor i in range(trials_with_withdrawals.shape[1]):\n    trials_with_withdrawals[:, i] -= withdrawal_per_day\n\n# Calculate success rate (portfolio doesn't deplete)\nfinal_values_with_withdrawal = trials_with_withdrawals[:, -1]\nsuccess_rate = (final_values_with_withdrawal &gt; 0).sum() / len(final_values_with_withdrawal)\n\nprint(f\"4% rule success rate: {success_rate:.1%}\")\nprint(f\"Median final value: ${np.median(final_values_with_withdrawal):,.0f}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#value-at-risk-var","title":"Value at Risk (VaR)","text":"<p>Calculate probability of specific losses:</p> <pre><code>results = monte_carlo_simulator(\n    returns_series=portfolio_returns,\n    num_trials=10000,\n    num_periods=252 * 1,  # 1 year\n    starting_value=100000\n)\n\n# Calculate VaR at different confidence levels\nlosses = 100000 - results['final_values']\nvar_95 = np.percentile(losses, 95)\nvar_99 = np.percentile(losses, 99)\n\nprint(f\"VaR (95%): ${var_95:,.0f} maximum loss\")\nprint(f\"VaR (99%): ${var_99:,.0f} maximum loss\")\n\n# Conditional VaR (CVaR / Expected Shortfall)\ncvar_95 = losses[losses &gt;= var_95].mean()\nprint(f\"CVaR (95%): ${cvar_95:,.0f} expected loss if VaR exceeded\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#multi-asset-portfolio","title":"Multi-Asset Portfolio","text":"<p>Simulate correlated assets:</p> <pre><code>import numpy as np\n\n# Calculate correlation matrix\nreturns_df = pd.DataFrame({\n    'SPY': spy_returns,\n    'TLT': tlt_returns,\n    'GLD': gld_returns\n})\ncorrelation_matrix = returns_df.corr()\n\n# Cholesky decomposition for correlated sampling\nL = np.linalg.cholesky(correlation_matrix)\n\n# Generate correlated returns\nnum_trials = 10000\nnum_periods = 252 * 10\n\nuncorrelated_returns = np.random.normal(\n    loc=returns_df.mean().values,\n    scale=returns_df.std().values,\n    size=(num_trials, num_periods, 3)\n)\n\n# Apply correlation\ncorrelated_returns = uncorrelated_returns @ L.T\n\n# Simulate portfolio (equal weight)\nweights = np.array([0.33, 0.33, 0.34])\nportfolio_returns = (correlated_returns * weights).sum(axis=2)\n\n# Calculate final values\ncumulative_returns = (1 + portfolio_returns).cumprod(axis=1)\nfinal_values = 100000 * cumulative_returns[:, -1]\n\nprint(f\"Median final value: ${np.median(final_values):,.0f}\")\nprint(f\"5th percentile: ${np.percentile(final_values, 5):,.0f}\")\nprint(f\"95th percentile: ${np.percentile(final_values, 95):,.0f}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#leveraged-portfolio-risk","title":"Leveraged Portfolio Risk","text":"<p>Analyze risk of leveraged strategies:</p> <pre><code># UPRO (3x leveraged S&amp;P 500) returns\nupro_returns = spy_returns * 3  # Simplified for illustration\n\nresults_spy = monte_carlo_simulator(spy_returns, 10000, 252*10, 100000)\nresults_upro = monte_carlo_simulator(upro_returns, 10000, 252*10, 100000)\n\n# Compare distributions\nprint(\"SPY Simulation:\")\nprint(f\"  Median: ${results_spy['final_values'].median():,.0f}\")\nprint(f\"  5th percentile: ${np.percentile(results_spy['final_values'], 5):,.0f}\")\n\nprint(\"\\nUPRO Simulation:\")\nprint(f\"  Median: ${results_upro['final_values'].median():,.0f}\")\nprint(f\"  5th percentile: ${np.percentile(results_upro['final_values'], 5):,.0f}\")\n\n# Calculate probability of loss\nprob_loss_spy = (results_spy['final_values'] &lt; 100000).sum() / 10000\nprob_loss_upro = (results_upro['final_values'] &lt; 100000).sum() / 10000\n\nprint(f\"\\nProbability of loss after 10 years:\")\nprint(f\"  SPY: {prob_loss_spy:.1%}\")\nprint(f\"  UPRO: {prob_loss_upro:.1%}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#visualization","title":"Visualization","text":""},{"location":"api/services/simulation/monte-carlo/#plot-trials","title":"Plot Trials","text":"<pre><code>from finbot.services.simulation.monte_carlo.visualization import plot_trials\n\nplot_trials(\n    results['trials'],\n    results['percentiles'],\n    title=\"Monte Carlo Simulation: 10,000 Trials\",\n    xlabel=\"Trading Days\",\n    ylabel=\"Portfolio Value ($)\"\n)\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#plot-distribution","title":"Plot Distribution","text":"<pre><code>from finbot.services.simulation.monte_carlo.visualization import plot_distribution\n\nplot_distribution(\n    results['final_values'],\n    title=\"Final Value Distribution After 30 Years\",\n    xlabel=\"Final Portfolio Value ($)\",\n    initial_value=100000\n)\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#key-assumptions","title":"Key Assumptions","text":""},{"location":"api/services/simulation/monte-carlo/#what-monte-carlo-captures","title":"What Monte Carlo Captures","text":"<ul> <li>Historical return distribution (mean, volatility)</li> <li>Random variation and uncertainty</li> <li>Compound return effects</li> <li>Path-dependent outcomes</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#what-monte-carlo-doesnt-capture","title":"What Monte Carlo Doesn't Capture","text":"<ul> <li>Regime changes: Market conditions may differ from historical</li> <li>Structural breaks: Economic crises not in historical data</li> <li>Fat tails: May underestimate extreme events</li> <li>Time-varying volatility: Assumes constant volatility</li> <li>Mean reversion: Doesn't model market cycles</li> <li>Autocorrelation: Assumes independent returns</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#best-practices","title":"Best Practices","text":"<ol> <li>Use sufficient trials: At least 10,000 for stable percentiles</li> <li>Historical data quality: Minimum 5-10 years of data</li> <li>Include multiple scenarios: Test bull, bear, and sideways markets separately</li> <li>Stress test: Add extreme scenarios not in historical data</li> <li>Validate assumptions: Check if normal distribution is appropriate</li> <li>Combine with fundamentals: Don't rely solely on historical returns</li> <li>Update regularly: Re-run with latest historical data</li> </ol>"},{"location":"api/services/simulation/monte-carlo/#limitations","title":"Limitations","text":"<ul> <li>Backward-looking: Based entirely on past performance</li> <li>Distribution assumptions: Normal distribution may not capture reality</li> <li>Independence assumption: Ignores serial correlation</li> <li>No structural change: Assumes future like past</li> <li>Overfitting risk: Historical period may not be representative</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#see-also","title":"See Also","text":"<ul> <li>Research: Monte Carlo Risk Analysis - Detailed findings</li> <li>Notebook: Monte Carlo Demo - Interactive examples</li> <li>Visualization - Plotting functions</li> <li>DCA Optimizer - Complementary optimization approach</li> </ul>"},{"location":"api/utils/finance-utils/","title":"Finance Utilities","text":"<p>The <code>finance_utils</code> module provides 19 financial calculation and analysis functions for returns, drawdowns, time series statistics, and economic data.</p>"},{"location":"api/utils/finance-utils/#overview","title":"Overview","text":"<p>Key capabilities:</p> <ul> <li>Returns Calculation: Compound growth rate (CGR), percentage change</li> <li>Risk Metrics: Drawdown analysis, volatility, time series statistics</li> <li>Time Period Analysis: Detect data frequency, calculate periods per year</li> <li>Price Adjustments: Inflation adjustment, merge overlapping price series</li> <li>Economic Cycles: US GDP recession dates and classifications</li> <li>Trend Analysis: Bull/bear/sideways market classification</li> </ul>"},{"location":"api/utils/finance-utils/#quick-reference","title":"Quick Reference","text":"Function Purpose Location <code>get_cgr</code> Compound growth rate (CAGR) <code>finbot.utils.finance_utils.get_cgr</code> <code>get_pct_change</code> Percentage change between values <code>finbot.utils.finance_utils.get_pct_change</code> <code>get_drawdown</code> Calculate drawdown from price series <code>finbot.utils.finance_utils.get_drawdown</code> <code>get_periods_per_year</code> Detect data frequency (daily, weekly, monthly) <code>finbot.utils.finance_utils.get_periods_per_year</code> <code>get_risk_free_rate</code> Fetch current risk-free rate from FRED <code>finbot.utils.finance_utils.get_risk_free_rate</code> <code>merge_price_histories</code> Merge overlapping price series <code>finbot.utils.finance_utils.merge_price_histories</code> <code>get_timeseries_stats</code> Comprehensive statistics (mean, std, Sharpe, etc.) <code>finbot.utils.finance_utils.get_timeseries_stats</code> <code>get_theta_decay</code> Calculate leveraged ETF decay <code>finbot.utils.finance_utils.get_theta_decay</code> <code>get_inflation_adjusted_value</code> Adjust for CPI inflation <code>finbot.utils.finance_utils.get_inflation_adjusted_value</code> <code>get_price_trend_classifications</code> Classify bull/bear/sideways periods <code>finbot.utils.finance_utils.get_price_trend_classifications</code>"},{"location":"api/utils/finance-utils/#core-functions","title":"Core Functions","text":""},{"location":"api/utils/finance-utils/#get_cgr","title":"get_cgr","text":"<p>Calculate compound annual growth rate.</p> <p>Location: <code>finbot.utils.finance_utils.get_cgr</code></p> <pre><code>def get_cgr(\n    initial_value: float,\n    final_value: float,\n    years: float\n) -&gt; float\n</code></pre> <p>Parameters: - <code>initial_value</code> (float): Starting value - <code>final_value</code> (float): Ending value - <code>years</code> (float): Time period in years</p> <p>Returns: Compound annual growth rate as decimal (0.10 = 10%)</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_cgr import get_cgr\n\n# Calculate CAGR for 5-year investment\ninitial_value = 100000\nfinal_value = 150000\nyears = 5\n\ncagr = get_cgr(initial_value, final_value, years)\nprint(f\"CAGR: {cagr:.2%}\")  # Output: CAGR: 8.45%\n</code></pre>"},{"location":"api/utils/finance-utils/#get_drawdown","title":"get_drawdown","text":"<p>Calculate drawdown from peak.</p> <p>Location: <code>finbot.utils.finance_utils.get_drawdown</code></p> <pre><code>def get_drawdown(prices: pd.Series) -&gt; pd.Series\n</code></pre> <p>Parameters: - <code>prices</code> (pd.Series): Price series with DatetimeIndex</p> <p>Returns: Series of drawdown percentages (negative values)</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_drawdown import get_drawdown\nimport pandas as pd\n\n# Load price history\nprices = pd.read_parquet('spy_prices.parquet')['Close']\n\n# Calculate drawdown\ndrawdown = get_drawdown(prices)\n\n# Analyze\nmax_dd = drawdown.min()\nprint(f\"Maximum drawdown: {max_dd:.2%}\")\n\n# Find max drawdown date\nmax_dd_date = drawdown.idxmin()\nprint(f\"Occurred on: {max_dd_date}\")\n</code></pre>"},{"location":"api/utils/finance-utils/#get_periods_per_year","title":"get_periods_per_year","text":"<p>Detect data frequency.</p> <p>Location: <code>finbot.utils.finance_utils.get_periods_per_year</code></p> <pre><code>def get_periods_per_year(data: pd.Series | pd.DataFrame) -&gt; int\n</code></pre> <p>Parameters: - <code>data</code> (pd.Series | pd.DataFrame): Time series data with DatetimeIndex</p> <p>Returns: Number of periods per year (252 for daily, 52 for weekly, 12 for monthly)</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_periods_per_year import get_periods_per_year\n\n# Detect frequency of price data\nperiods = get_periods_per_year(daily_prices)\nprint(f\"Periods per year: {periods}\")  # Output: 252 (trading days)\n\n# Use for annualization\ndaily_returns = daily_prices.pct_change()\nannual_volatility = daily_returns.std() * np.sqrt(periods)\n</code></pre>"},{"location":"api/utils/finance-utils/#merge_price_histories","title":"merge_price_histories","text":"<p>Merge overlapping price series with priority control.</p> <p>Location: <code>finbot.utils.finance_utils.merge_price_histories</code></p> <pre><code>def merge_price_histories(\n    df1: pd.DataFrame,\n    df2: pd.DataFrame,\n    priority: str = 'second'\n) -&gt; pd.DataFrame\n</code></pre> <p>Parameters: - <code>df1</code> (pd.DataFrame): First price DataFrame - <code>df2</code> (pd.DataFrame): Second price DataFrame - <code>priority</code> (str): Which DataFrame takes precedence ('first' or 'second')</p> <p>Returns: Merged DataFrame with overlapping dates resolved by priority</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.merge_price_histories import merge_price_histories\n\n# Merge simulated pre-inception data with actual ETF data\nsimulated = simulate_fund('UPRO', start='1990-01-01', end='2009-06-24')\nactual = get_history('UPRO', start='2009-06-25')\n\n# Merge with priority to actual data\nmerged = merge_price_histories(simulated, actual, priority='second')\n\n# Result: 1990-2009 from simulation, 2009+ from actual\n</code></pre>"},{"location":"api/utils/finance-utils/#get_risk_free_rate","title":"get_risk_free_rate","text":"<p>Fetch current risk-free rate from FRED.</p> <p>Location: <code>finbot.utils.finance_utils.get_risk_free_rate</code></p> <pre><code>def get_risk_free_rate(fallback: float = 0.02) -&gt; float\n</code></pre> <p>Parameters: - <code>fallback</code> (float, optional): Fallback rate if FRED unavailable (default: 0.02)</p> <p>Returns: Risk-free rate as decimal</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_risk_free_rate import get_risk_free_rate\n\n# Get latest 3-month T-bill rate from FRED\nrf_rate = get_risk_free_rate()\nprint(f\"Risk-free rate: {rf_rate:.2%}\")\n\n# Use in Sharpe ratio calculation\nsharpe = (portfolio_return - rf_rate) / portfolio_std\n</code></pre>"},{"location":"api/utils/finance-utils/#complete-function-list","title":"Complete Function List","text":""},{"location":"api/utils/finance-utils/#returns-and-growth","title":"Returns and Growth","text":"<ul> <li><code>get_cgr</code>: Compound growth rate</li> <li><code>get_pct_change</code>: Percentage change</li> <li><code>get_open_close_percent_change</code>: Open-to-close change</li> </ul>"},{"location":"api/utils/finance-utils/#risk-metrics","title":"Risk Metrics","text":"<ul> <li><code>get_drawdown</code>: Drawdown from peak</li> <li><code>get_theta_decay</code>: Leveraged ETF decay</li> <li><code>get_timeseries_stats</code>: Comprehensive statistics</li> </ul>"},{"location":"api/utils/finance-utils/#time-and-frequency","title":"Time and Frequency","text":"<ul> <li><code>get_periods_per_year</code>: Detect data frequency</li> <li><code>get_investment_event_horizon</code>: Calculate holding period</li> </ul>"},{"location":"api/utils/finance-utils/#price-operations","title":"Price Operations","text":"<ul> <li><code>merge_price_histories</code>: Merge overlapping series</li> <li><code>get_inflation_adjusted_value</code>: CPI adjustment</li> <li><code>get_series_adjusted_for_inflation</code>: Series-wide inflation adjustment</li> </ul>"},{"location":"api/utils/finance-utils/#market-analysis","title":"Market Analysis","text":"<ul> <li><code>get_price_trend_classifications</code>: Bull/bear/sideways classification</li> <li><code>get_us_gdp_recession_dates</code>: Recession periods</li> <li><code>get_us_gdp_non_recession_dates</code>: Expansion periods</li> <li><code>get_us_gdp_cycle_dates</code>: Full cycle dates</li> <li><code>get_us_gdp_recessions_bools</code>: Boolean recession indicators</li> </ul>"},{"location":"api/utils/finance-utils/#data-and-utilities","title":"Data and Utilities","text":"<ul> <li><code>get_risk_free_rate</code>: Fetch from FRED</li> <li><code>get_mult_from_suffix</code>: Parse K/M/B/T multipliers</li> <li><code>get_number_from_suffix</code>: Convert formatted strings to numbers</li> </ul>"},{"location":"api/utils/finance-utils/#see-also","title":"See Also","text":"<ul> <li>Datetime Utilities - Time period calculations</li> <li>Pandas Utilities - DataFrame operations</li> <li>Data Science Utilities - Statistical analysis</li> </ul>"},{"location":"research/","title":"Research Documentation","text":"<p>This section contains research findings and analysis from Finbot simulations and backtests.</p>"},{"location":"research/#published-research","title":"Published Research","text":""},{"location":"research/#leveraged-etf-simulation-accuracy","title":"Leveraged ETF Simulation Accuracy","text":"<p>Analysis of how well the fund simulator tracks real ETF returns.</p> <p>Key Findings: - 2-5% tracking error for leveraged funds - Suitable for historical backtesting and extension - LIBOR approximation accounts for ~1% of error</p> <p>Read Full Report</p>"},{"location":"research/#dca-optimization-findings","title":"DCA Optimization Findings","text":"<p>Optimal dollar-cost averaging strategies across multiple portfolios.</p> <p>Key Findings: - 60/40 SPY/TLT validated for non-leveraged portfolios - 45/55 UPRO/TMF optimal for leveraged portfolios - 5-year DCA duration balances risk and return</p> <p>Read Full Report</p>"},{"location":"research/#strategy-backtest-results","title":"Strategy Backtest Results","text":"<p>Comparison of 10 trading strategies on S&amp;P 500 data.</p> <p>Key Findings: - Rebalancing outperforms buy-and-hold for multi-asset portfolios - SMA crossovers effective in trending markets - Transaction costs matter for frequent-trading strategies</p> <p>Read Full Report</p>"},{"location":"research/#research-notebooks","title":"Research Notebooks","text":"<p>Interactive Jupyter notebooks with full analysis:</p> <ol> <li>Fund Simulation Demo</li> <li>DCA Optimization Results</li> <li>Backtest Strategy Comparison</li> <li>Monte Carlo Risk Analysis</li> <li>Bond Ladder Analysis</li> </ol>"},{"location":"research/#methodology","title":"Methodology","text":"<p>All research uses: - Historical data from Yahoo Finance and FRED - Simulated data from Finbot's fund simulator - Backtrader-based backtesting engine - Quantstats for performance metrics</p>"},{"location":"research/#limitations","title":"Limitations","text":"<ul> <li>Historical data (past performance \u2260 future results)</li> <li>Simulation assumptions (constant expense ratios, LIBOR approximation)</li> <li>No transaction costs in some analyses</li> <li>Survivorship bias (analyzing successful ETFs)</li> </ul>"},{"location":"research/#citation","title":"Citation","text":"<p>If you use Finbot's research in academic work:</p> <pre><code>@software{finbot2026,\n  author = {Dawson, Jeremy},\n  title = {Finbot: Financial Simulation and Backtesting Platform},\n  year = {2026},\n  url = {https://github.com/jerdaw/finbot}\n}\n</code></pre>"},{"location":"user-guide/cli-reference/","title":"CLI Reference","text":"<p>Complete command-line interface documentation for Finbot.</p>"},{"location":"user-guide/cli-reference/#global-options","title":"Global Options","text":"<pre><code>finbot [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Global Options: - <code>--version</code>: Show version and exit - <code>--verbose</code>, <code>-v</code>: Enable verbose output - <code>--help</code>: Show help message</p>"},{"location":"user-guide/cli-reference/#commands","title":"Commands","text":""},{"location":"user-guide/cli-reference/#finbot-simulate","title":"finbot simulate","text":"<p>Simulate leveraged funds:</p> <pre><code>finbot simulate --fund FUND_TICKER [OPTIONS]\n</code></pre> <p>Required: - <code>--fund TEXT</code>: Fund ticker (SPY, UPRO, TQQQ, etc.)</p> <p>Optional: - <code>--start TEXT</code>: Start date (YYYY-MM-DD) - <code>--end TEXT</code>: End date (YYYY-MM-DD) - <code>--output PATH</code>: Save results (CSV, parquet, JSON) - <code>--plot</code>: Show interactive plot</p> <p>Examples:</p> <pre><code># Basic simulation\nfinbot simulate --fund UPRO\n\n# Historical extension\nfinbot simulate --fund TQQQ --start 1990-01-01 --end 2024-01-01\n\n# Save and plot\nfinbot simulate --fund TMF --output results/tmf.parquet --plot\n</code></pre>"},{"location":"user-guide/cli-reference/#finbot-backtest","title":"finbot backtest","text":"<p>Run strategy backtests:</p> <pre><code>finbot backtest --strategy STRATEGY --asset ASSETS [OPTIONS]\n</code></pre> <p>Required: - <code>--strategy TEXT</code>: Strategy name (Rebalance, SMACrossover, etc.) - <code>--asset TEXT</code>: Comma-separated tickers (SPY,TLT)</p> <p>Optional: - <code>--start TEXT</code>: Start date - <code>--end TEXT</code>: End date - <code>--cash FLOAT</code>: Starting cash (default: 100000) - <code>--commission FLOAT</code>: Commission rate (default: 0.001) - <code>--output PATH</code>: Save results - <code>--plot</code>: Show portfolio value chart</p> <p>Examples:</p> <pre><code># 60/40 portfolio\nfinbot backtest --strategy Rebalance --asset SPY,TLT\n\n# Custom parameters\nfinbot backtest --strategy SMACrossover --asset QQQ \\\n  --start 2010-01-01 --cash 50000 --commission 0.0005 --plot\n</code></pre>"},{"location":"user-guide/cli-reference/#finbot-optimize","title":"finbot optimize","text":"<p>Portfolio optimization:</p> <pre><code>finbot optimize --method METHOD --assets ASSETS [OPTIONS]\n</code></pre> <p>Required: - <code>--method TEXT</code>: Optimization method (dca) - <code>--assets TEXT</code>: Comma-separated tickers</p> <p>Optional: - <code>--duration INTEGER</code>: DCA duration in days - <code>--interval INTEGER</code>: Purchase interval in days - <code>--ratios TEXT</code>: Ratio range (start,stop,num) - <code>--output PATH</code>: Save results - <code>--plot</code>: Show optimization charts</p> <p>Examples:</p> <pre><code># Default optimization\nfinbot optimize --method dca --assets SPY,TLT\n\n# Custom parameters\nfinbot optimize --method dca --assets UPRO,TMF \\\n  --duration 1095 --interval 30 --ratios 0.3,0.7,9 --plot\n</code></pre>"},{"location":"user-guide/cli-reference/#finbot-update","title":"finbot update","text":"<p>Update all data:</p> <pre><code>finbot update [OPTIONS]\n</code></pre> <p>Optional: - <code>--dry-run</code>: Show what would be updated - <code>--skip-prices</code>: Skip price history updates - <code>--skip-simulations</code>: Skip simulation updates</p> <p>Examples:</p> <pre><code># Full update\nfinbot update\n\n# Dry run (no changes)\nfinbot update --dry-run\n\n# Update prices only\nfinbot update --skip-simulations\n</code></pre>"},{"location":"user-guide/cli-reference/#output-formats","title":"Output Formats","text":"<p>Specify output format via file extension:</p> <ul> <li><code>.csv</code>: Comma-separated values</li> <li><code>.parquet</code>: Apache Parquet (recommended)</li> <li><code>.json</code>: JSON format</li> </ul>"},{"location":"user-guide/cli-reference/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Installation and setup</li> <li>Configuration - Advanced settings</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Advanced configuration options for Finbot.</p>"},{"location":"user-guide/configuration/#configuration-system","title":"Configuration System","text":"<p>Finbot uses Dynaconf for environment-aware configuration. Settings are loaded from YAML files based on the <code>DYNACONF_ENV</code> environment variable.</p>"},{"location":"user-guide/configuration/#configuration-files","title":"Configuration Files","text":"<p>Located in <code>config/</code> directory:</p> <ul> <li><code>settings.yaml</code>: Base settings (all environments)</li> <li><code>development.yaml</code>: Development overrides</li> <li><code>production.yaml</code>: Production overrides</li> <li><code>.env</code>: Environment variables (gitignored)</li> </ul>"},{"location":"user-guide/configuration/#environment-selection","title":"Environment Selection","text":"<pre><code># Development (default)\nexport DYNACONF_ENV=development\n\n# Production\nexport DYNACONF_ENV=production\n</code></pre>"},{"location":"user-guide/configuration/#common-settings","title":"Common Settings","text":""},{"location":"user-guide/configuration/#threading","title":"Threading","text":"<pre><code># config/development.yaml\nthreading:\n  min_threads: 1\n  max_threads: null  # Auto-detect\n  reserved_threads: 2  # Leave 2 cores for system\n</code></pre>"},{"location":"user-guide/configuration/#logging","title":"Logging","text":"<pre><code>logging:\n  level: INFO  # DEBUG, INFO, WARNING, ERROR\n  json_output: true\n  file_rotation_mb: 5\n  file_backup_count: 3\n</code></pre>"},{"location":"user-guide/configuration/#api-keys","title":"API Keys","text":"<p>Store API keys in <code>config/.env</code>:</p> <pre><code># config/.env\nALPHA_VANTAGE_API_KEY=your_key_here\nNASDAQ_DATA_LINK_API_KEY=your_key_here\nUS_BUREAU_OF_LABOR_STATISTICS_API_KEY=your_key_here\nGOOGLE_FINANCE_SERVICE_ACCOUNT_CREDENTIALS_PATH=/path/to/creds.json\n</code></pre> <p>Keys are loaded lazily (only when needed).</p>"},{"location":"user-guide/configuration/#python-api","title":"Python API","text":"<p>Access settings in code:</p> <pre><code>from config import settings, settings_accessors\n\n# Get threading config\nmax_threads = settings_accessors.MAX_THREADS\n\n# Get API key (raises OSError if not set)\napi_key = settings_accessors.get_alpha_vantage_api_key()\n\n# Access any setting\nlog_level = settings.logging.level\n</code></pre>"},{"location":"user-guide/configuration/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic setup</li> <li>config Module - Configuration API reference</li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with Finbot for financial simulation, backtesting, and portfolio optimization.</p>"},{"location":"user-guide/getting-started/#what-is-finbot","title":"What is Finbot?","text":"<p>Finbot is a comprehensive platform for:</p> <ul> <li>Data Collection: Automated fetching from 6+ data sources</li> <li>Simulation: Model leveraged ETFs, bond ladders, and Monte Carlo scenarios</li> <li>Backtesting: Test 10 trading strategies with detailed performance metrics</li> <li>Optimization: Find optimal portfolios using DCA and rebalancing strategies</li> </ul>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":""},{"location":"user-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python &gt;=3.11, &lt;3.15</li> <li>uv (recommended) or pip</li> <li>Optional: API keys for data sources</li> </ul>"},{"location":"user-guide/getting-started/#install-with-uv-recommended","title":"Install with uv (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install dependencies\nuv sync\n\n# Activate virtual environment (optional, uv creates .venv automatically)\nsource .venv/bin/activate  # On Linux/Mac\n.venv\\Scripts\\activate     # On Windows\n\n# Set environment (development or production)\nexport DYNACONF_ENV=development\n\n# Verify installation\nfinbot --version\n</code></pre>"},{"location":"user-guide/getting-started/#install-with-pip","title":"Install with pip","text":"<pre><code># Clone the repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in editable mode\npip install -e .\n\n# Verify installation\nfinbot --version\n</code></pre>"},{"location":"user-guide/getting-started/#configuration","title":"Configuration","text":""},{"location":"user-guide/getting-started/#environment-setup","title":"Environment Setup","text":"<p>Finbot uses Dynaconf for environment-aware configuration. Create a <code>.env</code> file in the <code>config/</code> directory:</p> <pre><code># config/.env\nDYNACONF_ENV=development\n\n# Optional: API keys for data collection\nALPHA_VANTAGE_API_KEY=your_key_here\nNASDAQ_DATA_LINK_API_KEY=your_key_here\nUS_BUREAU_OF_LABOR_STATISTICS_API_KEY=your_key_here\nGOOGLE_FINANCE_SERVICE_ACCOUNT_CREDENTIALS_PATH=/path/to/credentials.json\n</code></pre>"},{"location":"user-guide/getting-started/#configuration-files","title":"Configuration Files","text":"<p>Finbot loads settings from YAML files based on <code>DYNACONF_ENV</code>:</p> <ul> <li><code>config/settings.yaml</code>: Base settings (shared across all environments)</li> <li><code>config/development.yaml</code>: Development-specific settings</li> <li><code>config/production.yaml</code>: Production-specific settings</li> </ul> <p>Example development configuration:</p> <pre><code># config/development.yaml\nthreading:\n  min_threads: 1\n  max_threads: null  # Auto-detect CPU cores\n  reserved_threads: 2  # Reserve 2 cores for system\n\nlogging:\n  level: INFO\n  json_output: true\n</code></pre>"},{"location":"user-guide/getting-started/#first-steps","title":"First Steps","text":""},{"location":"user-guide/getting-started/#1-run-tests","title":"1. Run Tests","text":"<p>Verify your installation by running the test suite:</p> <pre><code># Run all tests\nuv run pytest\n\n# Run with verbose output\nuv run pytest -v\n\n# Run specific test file\nuv run pytest tests/unit/test_imports.py\n</code></pre> <p>Expected output: <code>80 passed</code> (all tests should pass)</p>"},{"location":"user-guide/getting-started/#2-update-data","title":"2. Update Data","text":"<p>Fetch the latest data from all sources:</p> <pre><code># Run full update (requires API keys)\nfinbot update\n\n# Dry run (shows what would be updated)\nfinbot update --dry-run\n\n# Skip price updates\nfinbot update --skip-prices\n\n# Skip simulations\nfinbot update --skip-simulations\n</code></pre> <p>This will: - Fetch Yahoo Finance and Google Finance price histories - Update FRED economic data - Download Shiller datasets - Re-run overnight LIBOR approximation - Regenerate all index and fund simulations</p>"},{"location":"user-guide/getting-started/#3-run-your-first-simulation","title":"3. Run Your First Simulation","text":"<p>Simulate a leveraged fund:</p> <pre><code># Simulate UPRO (3x leveraged S&amp;P 500)\nfinbot simulate --fund UPRO --start 2010-01-01 --plot\n\n# Save results to file\nfinbot simulate --fund UPRO --start 2010-01-01 --output results/upro_sim.parquet\n\n# See all available funds\nfinbot simulate --help\n</code></pre> <p>Available funds: SPY, SSO, UPRO, QQQ, QLD, TQQQ, TLT, UBT, TMF, IEF, UST, TYD, SHY, NTSX</p>"},{"location":"user-guide/getting-started/#4-run-your-first-backtest","title":"4. Run Your First Backtest","text":"<p>Test a trading strategy:</p> <pre><code># Backtest rebalancing strategy on 60/40 portfolio\nfinbot backtest --strategy Rebalance --asset SPY,TLT --plot\n\n# Backtest with custom parameters\nfinbot backtest --strategy Rebalance --asset SPY,TLT \\\n  --cash 100000 --commission 0.001 --output results/backtest.csv\n\n# See all available strategies\nfinbot backtest --help\n</code></pre> <p>Available strategies: Rebalance, NoRebalance, SMACrossover, SMACrossoverDouble, SMACrossoverTriple, MACDSingle, MACDDual, DipBuySMA, DipBuyStdev, SMARebalMix</p>"},{"location":"user-guide/getting-started/#5-optimize-a-portfolio","title":"5. Optimize a Portfolio","text":"<p>Find optimal asset allocation:</p> <pre><code># Optimize SPY/TLT allocation with DCA strategy\nfinbot optimize --method dca --assets SPY,TLT --plot\n\n# Custom optimization parameters\nfinbot optimize --method dca --assets SPY,TLT \\\n  --duration 1825 --interval 30 --ratios 0.5,0.95,10 \\\n  --output results/optimization.parquet\n</code></pre>"},{"location":"user-guide/getting-started/#python-api-usage","title":"Python API Usage","text":""},{"location":"user-guide/getting-started/#simulate-a-fund","title":"Simulate a Fund","text":"<pre><code>from finbot.services.simulation.fund_simulator import simulate_fund\n\n# Simulate TQQQ (3x leveraged Nasdaq 100)\ntqqq_sim = simulate_fund('TQQQ', start_date='2010-02-11', end_date='2024-01-01')\n\n# Access results\nprint(tqqq_sim.head())\nprint(f\"Total return: {(tqqq_sim['Close'][-1] / tqqq_sim['Close'][0] - 1) * 100:.2f}%\")\n</code></pre>"},{"location":"user-guide/getting-started/#run-a-backtest","title":"Run a Backtest","text":"<pre><code>from finbot.services.backtesting.backtest_runner import BacktestRunner\nfrom finbot.utils.data_collection_utils.yfinance import get_history\n\n# Load data\nspy = get_history('SPY', start='2010-01-01')\ntlt = get_history('TLT', start='2010-01-01')\n\n# Create backtest runner\nrunner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy, 'TLT': tlt},\n    strategy_params={'rebalance_days': 30, 'target_allocations': {'SPY': 0.6, 'TLT': 0.4}},\n    cash=100000,\n    commission=0.001\n)\n\n# Run backtest\nresults = runner.run()\nstats = runner.get_stats()\n\nprint(f\"CAGR: {stats['CAGR']:.2%}\")\nprint(f\"Sharpe: {stats['Sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['Max Drawdown']:.2%}\")\n</code></pre>"},{"location":"user-guide/getting-started/#optimize-dca-strategy","title":"Optimize DCA Strategy","text":"<pre><code>from finbot.services.optimization.dca_optimizer import dca_optimizer\nimport pandas as pd\n\n# Load and merge price data\nspy = get_history('SPY')['Close']\ntlt = get_history('TLT')['Close']\ncombined = pd.DataFrame({'SPY': spy, 'TLT': tlt}).dropna()\n\n# Run optimizer\nresults = dca_optimizer(\n    price_history=combined,\n    ratio_linspace=(0.50, 0.95, 10),\n    dca_duration_days=365 * 5,\n    dca_step_days=30,\n    trial_duration_days=365 * 10,\n    starting_cash=100000\n)\n\n# View best allocation\nprint(results.head())\nprint(f\"Optimal: {results.iloc[0]['ratio']:.0%} SPY / {1-results.iloc[0]['ratio']:.0%} TLT\")\nprint(f\"Expected Sharpe: {results.iloc[0]['sharpe']:.2f}\")\n</code></pre>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide: Detailed walkthrough of common tasks</li> <li>CLI Reference: Complete command-line interface documentation</li> <li>API Reference: Detailed API documentation for all modules</li> <li>Configuration Guide: Advanced configuration options</li> <li>Example Notebooks: Jupyter notebooks with analysis examples</li> </ul>"},{"location":"user-guide/getting-started/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/getting-started/#import-errors","title":"Import Errors","text":"<p>If you see import errors, ensure you've installed all dependencies:</p> <pre><code>uv sync\n# or\npip install -e .\n</code></pre>"},{"location":"user-guide/getting-started/#api-key-errors","title":"API Key Errors","text":"<p>If data collection fails with \"OSError: API key not found\":</p> <ol> <li>Create <code>config/.env</code> file</li> <li>Add the relevant API key (see Configuration section)</li> <li>Restart your shell / reload environment</li> </ol>"},{"location":"user-guide/getting-started/#no-data-available","title":"No Data Available","text":"<p>If simulations fail with \"no data available\":</p> <ol> <li>Run <code>finbot update</code> to fetch data</li> <li>Check that <code>finbot/data/</code> subdirectories are populated</li> <li>Verify API keys are configured correctly</li> </ol>"},{"location":"user-guide/getting-started/#permission-errors","title":"Permission Errors","text":"<p>If you see permission errors on <code>finbot/data/</code> directories:</p> <pre><code># Linux/Mac\nchmod -R 755 finbot/data\n\n# Windows (run as administrator)\nicacls finbot\\data /grant Users:F /t\n</code></pre>"},{"location":"user-guide/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Full API Reference</li> <li>Issues: GitHub Issues</li> <li>Examples: Jupyter Notebooks</li> <li>Research: Published Findings</li> </ul>"},{"location":"user-guide/getting-started/#development-setup","title":"Development Setup","text":"<p>If you plan to contribute:</p> <pre><code># Install dev dependencies\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n\n# Run code quality checks\nmake check  # Runs lint, format, type, security\n\n# Run tests with coverage\nmake test-cov\n</code></pre> <p>See Contributing Guide for details.</p>"},{"location":"user-guide/health-economics-tutorial/","title":"Health Economics Tutorial","text":"<p>Audience: Clinicians, health policymakers, researchers Prerequisites: Basic Python, understanding of QALYs and cost-effectiveness Time: 30-45 minutes Goal: Learn to perform cost-effectiveness analysis using Finbot's health economics toolkit</p>"},{"location":"user-guide/health-economics-tutorial/#introduction","title":"Introduction","text":"<p>This tutorial walks through a realistic health economics analysis: comparing treatment options for patients with newly diagnosed Type 2 diabetes. By the end, you'll be able to:</p> <ul> <li>Model health interventions using Monte Carlo simulation</li> <li>Calculate standard cost-effectiveness metrics (ICER, NMB, CEAC)</li> <li>Interpret results against international thresholds (NICE, CADTH, WHO, US)</li> <li>Make evidence-based formulary and clinical decisions</li> </ul> <p>Real-world application: This analysis mirrors decisions made daily by: - NICE (UK): Appraising new diabetes drugs for NHS formulary - CADTH (Canada): Reviewing for provincial drug coverage - US Payers: Making formulary tier decisions (preferred vs. non-preferred) - Clinicians: Choosing between metformin and newer GLP-1 agonists</p>"},{"location":"user-guide/health-economics-tutorial/#clinical-scenario","title":"Clinical Scenario","text":"<p>Patient Population: Adults aged 45-65 with newly diagnosed Type 2 diabetes (HbA1c 7.5-9%)</p> <p>Treatment Options: 1. Metformin (standard of care): Generic, $500/year, modest efficacy 2. GLP-1 Receptor Agonist (newer option): Branded, $10,000/year, greater efficacy</p> <p>Clinical Question: Is the higher cost of GLP-1 agonists justified by improved health outcomes?</p> <p>Decision Framework: Use cost-effectiveness analysis to balance costs against health benefits (measured in QALYs).</p>"},{"location":"user-guide/health-economics-tutorial/#step-1-define-interventions","title":"Step 1: Define Interventions","text":"<p>First, we define each treatment's parameters based on clinical trial data.</p> <pre><code>from finbot.services.health_economics.qaly_simulator import HealthIntervention\n\n# Metformin (standard of care)\nmetformin = HealthIntervention(\n    name='Metformin',\n    cost_per_year=500.0,           # Generic pricing\n    cost_std=100.0,                # Cost uncertainty\n    utility_gain=0.08,              # Quality of life improvement (0-1 scale)\n    utility_gain_std=0.02,         # Utility uncertainty\n    mortality_reduction=0.003,      # Annual mortality reduction (3 per 1000)\n    mortality_reduction_std=0.001, # Mortality uncertainty\n)\n\n# GLP-1 agonist (e.g., semaglutide, liraglutide)\nglp1 = HealthIntervention(\n    name='GLP-1 Agonist',\n    cost_per_year=10_000.0,        # Branded pricing\n    cost_std=1_500.0,\n    utility_gain=0.15,              # Greater QoL (HbA1c control + weight loss)\n    utility_gain_std=0.03,\n    mortality_reduction=0.008,      # Proven CV mortality reduction\n    mortality_reduction_std=0.002,\n)\n</code></pre> <p>Parameter sources: - Costs: AWP (Average Wholesale Price) databases - Utility gains: EQ-5D or SF-6D quality-of-life instruments from trials - Mortality: Hazard ratios from cardiovascular outcomes trials (SUSTAIN, LEADER)</p> <p>Uncertainty: Standard deviations capture parameter uncertainty from clinical trials.</p>"},{"location":"user-guide/health-economics-tutorial/#step-2-run-monte-carlo-simulations","title":"Step 2: Run Monte Carlo Simulations","text":"<p>Monte Carlo simulation generates distributions of outcomes, not just point estimates.</p> <pre><code>from finbot.services.health_economics.qaly_simulator import simulate_qalys\n\n# Baseline for newly diagnosed T2D patients\nbaseline_utility = 0.65      # Uncontrolled diabetes quality of life\nbaseline_mortality = 0.04    # 4%/year CV mortality risk\ntime_horizon = 15            # 15 years (until age 60-80)\n\n# Run 10,000 Monte Carlo trials for each intervention\nsim_metformin = simulate_qalys(\n    metformin,\n    baseline_utility=baseline_utility,\n    baseline_mortality=baseline_mortality,\n    time_horizon=time_horizon,\n    n_sims=10_000,\n    discount_rate=0.03,  # 3% per WHO/NICE guidelines\n    seed=42,\n)\n\nsim_glp1 = simulate_qalys(\n    glp1,\n    baseline_utility=baseline_utility,\n    baseline_mortality=baseline_mortality,\n    time_horizon=time_horizon,\n    n_sims=10_000,\n    discount_rate=0.03,\n    seed=42,\n)\n\n# View mean results\nprint(f'Metformin:     {sim_metformin[\"mean_qaly\"]:.2f} QALYs, ${sim_metformin[\"mean_cost\"]:,.0f}')\nprint(f'GLP-1 Agonist: {sim_glp1[\"mean_qaly\"]:.2f} QALYs, ${sim_glp1[\"mean_cost\"]:,.0f}')\n</code></pre> <p>Example Output: <pre><code>Metformin:     9.23 QALYs, $3,876\nGLP-1 Agonist: 10.71 QALYs, $78,245\n</code></pre></p> <p>Interpretation: - Metformin provides 9.23 discounted QALYs over 15 years at low cost - GLP-1 provides 1.48 more QALYs but costs $74,369 more - Is this trade-off worthwhile?</p>"},{"location":"user-guide/health-economics-tutorial/#step-3-calculate-cost-effectiveness-metrics","title":"Step 3: Calculate Cost-Effectiveness Metrics","text":"<p>Now we compare the interventions using standard health economics metrics.</p> <pre><code>from finbot.services.health_economics.cost_effectiveness import cost_effectiveness_analysis\n\n# Run cost-effectiveness analysis\ncea = cost_effectiveness_analysis(\n    sim_results={'GLP-1 Agonist': sim_glp1, 'Metformin': sim_metformin},\n    comparator='Metformin',\n)\n\n# Display ICER\nicer_val = cea['icer']['ICER'].iloc[0]\nprint(f'ICER: ${icer_val:,.0f} per QALY')\nprint(f'Incremental QALYs: {cea[\"icer\"][\"Incremental QALYs\"].iloc[0]:.2f}')\nprint(f'Incremental Cost:  ${cea[\"icer\"][\"Incremental Cost\"].iloc[0]:,.0f}')\n</code></pre> <p>Example Output: <pre><code>ICER: $50,249 per QALY\nIncremental QALYs: 1.48\nIncremental Cost:  $74,369\n</code></pre></p>"},{"location":"user-guide/health-economics-tutorial/#interpreting-the-icer","title":"Interpreting the ICER","text":"<p>ICER Formula: <pre><code>ICER = (Cost_GLP1 - Cost_Metformin) / (QALY_GLP1 - QALY_Metformin)\n     = $74,369 / 1.48 QALYs\n     = $50,249 per QALY\n</code></pre></p> <p>Compare against international thresholds:</p> Jurisdiction Threshold Decision NICE (UK) \u00a320K-\u00a330K/QALY (~\\(25K-\\)38K USD) \u2717 Not cost-effective CADTH (Canada) ~\\(50K CAD/QALY (~\\)37K USD) \u2717 Borderline US (lower) $50K/QALY \u2713 Cost-effective US (mid) $100K/QALY \u2713\u2713 Highly cost-effective <p>Decision: GLP-1 agonists are cost-effective in the US but may not be approved in UK/Canada at current prices.</p>"},{"location":"user-guide/health-economics-tutorial/#step-4-quantify-decision-uncertainty","title":"Step 4: Quantify Decision Uncertainty","text":"<p>ICER gives a point estimate but hides uncertainty. Use the Cost-Effectiveness Acceptability Curve (CEAC) to show the probability of cost-effectiveness at different WTP thresholds.</p> <pre><code># Extract CEAC probabilities at key thresholds\nceac = cea['ceac']\nceac_glp1 = ceac['GLP-1 Agonist']\n\nprint('Probability GLP-1 is Cost-Effective:')\nprint(f'  At $25K/QALY (NICE UK):     {ceac_glp1[25_000]:.1%}')\nprint(f'  At $37K/QALY (CADTH Canada): {ceac_glp1[37_000]:.1%}')\nprint(f'  At $50K/QALY (US lower):     {ceac_glp1[50_000]:.1%}')\nprint(f'  At $100K/QALY (US mid):      {ceac_glp1[100_000]:.1%}')\n</code></pre> <p>Example Output: <pre><code>Probability GLP-1 is Cost-Effective:\n  At $25K/QALY (NICE UK):     23.4%\n  At $37K/QALY (CADTH Canada): 47.8%\n  At $50K/QALY (US lower):     72.1%\n  At $100K/QALY (US mid):      98.3%\n</code></pre></p> <p>Interpretation: - At NICE threshold (\\(25K/QALY): Only 23% chance GLP-1 is cost-effective \u2192 **Don't approve** - At US lower threshold (\\)50K/QALY): 72% chance cost-effective \u2192 Likely approve - At US mid threshold ($100K/QALY): 98% chance cost-effective \u2192 Definitely approve</p> <p>Why uncertainty matters: Decision changes from 23% to 98% depending on WTP threshold. Probabilistic analysis reveals this sensitivity.</p>"},{"location":"user-guide/health-economics-tutorial/#step-5-visualize-the-cost-effectiveness-plane","title":"Step 5: Visualize the Cost-Effectiveness Plane","text":"<p>The CE plane shows joint uncertainty in incremental costs and QALYs.</p> <pre><code>import plotly.graph_objects as go\n\nplane = cea['ce_plane']['GLP-1 Agonist']\n\nfig = go.Figure()\n\n# Scatter plot of 10,000 simulations\nfig.add_trace(go.Scatter(\n    x=plane['Delta QALYs'],\n    y=plane['Delta Cost'],\n    mode='markers',\n    marker=dict(size=2, opacity=0.2, color='blue'),\n    name='Simulations',\n))\n\n# Add WTP threshold lines\nx_range = [plane['Delta QALYs'].min(), plane['Delta QALYs'].max()]\nfig.add_trace(go.Scatter(\n    x=x_range, y=[x * 50_000 for x in x_range],\n    mode='lines', line=dict(dash='dash', color='orange'),\n    name='US Lower: $50K/QALY',\n))\n\nfig.add_hline(y=0, line_dash='dot', line_color='gray')\nfig.add_vline(x=0, line_dash='dot', line_color='gray')\n\nfig.update_layout(\n    title='Cost-Effectiveness Plane',\n    xaxis_title='Incremental QALYs',\n    yaxis_title='Incremental Cost ($)',\n    template='plotly_white',\n)\nfig.show()\n</code></pre> <p>Quadrants: - NE (North-East): More effective, more costly \u2192 Trade-off (most points here) - SE (South-East): More effective, less costly \u2192 Dominant (always adopt) - NW (North-West): Less effective, more costly \u2192 Dominated (never adopt) - SW (South-West): Less effective, less costly \u2192 Rare</p> <p>Result: Nearly all simulations in NE quadrant means decision depends on WTP threshold.</p>"},{"location":"user-guide/health-economics-tutorial/#step-6-calculate-net-monetary-benefit-nmb","title":"Step 6: Calculate Net Monetary Benefit (NMB)","text":"<p>NMB converts health gains to monetary terms for easier interpretation.</p> <pre><code># NMB at $100K/QALY threshold\nwtp = 100_000\nnmb = cea['nmb']\n\nprint(f'Net Monetary Benefit at ${wtp:,}/QALY threshold:')\nprint(f'  Metformin:     ${nmb.loc[wtp, \"Metformin\"]:,.0f}')\nprint(f'  GLP-1 Agonist: ${nmb.loc[wtp, \"GLP-1 Agonist\"]:,.0f}')\n</code></pre> <p>Example Output: <pre><code>Net Monetary Benefit at $100,000/QALY threshold:\n  Metformin:     $919,124\n  GLP-1 Agonist: $992,856\n</code></pre></p> <p>NMB Formula: <pre><code>NMB = WTP \u00d7 QALYs - Cost\n</code></pre></p> <p>Interpretation: - At \\(100K/QALY, GLP-1 has higher NMB (\\)992K vs. $919K) - Decision: Choose GLP-1 (higher NMB = more valuable) - NMB difference: $73,732 (value gained from switching to GLP-1)</p>"},{"location":"user-guide/health-economics-tutorial/#step-7-make-clinical-and-policy-decisions","title":"Step 7: Make Clinical and Policy Decisions","text":""},{"location":"user-guide/health-economics-tutorial/#for-healthcare-payers","title":"For Healthcare Payers","text":"<p>UK (NICE): <pre><code>if icer_val &lt; 25_000:\n    print('Decision: Approve for NHS formulary')\nelif icer_val &lt; 38_000:\n    print('Decision: Negotiate price reduction or restrict to high-risk patients')\nelse:\n    print('Decision: Reject at current price')\n</code></pre></p> <p>Canada (CADTH): <pre><code>if icer_val &lt; 37_000:\n    print('Decision: Recommend for provincial formularies')\nelif icer_val &lt; 75_000:\n    print('Decision: Conditional recommendation (price negotiation)')\nelse:\n    print('Decision: Not recommended')\n</code></pre></p> <p>US Payers: <pre><code>if icer_val &lt; 50_000:\n    print('Decision: Include on preferred formulary tier (low copay)')\nelif icer_val &lt; 150_000:\n    print('Decision: Include on non-preferred tier (higher copay)')\nelse:\n    print('Decision: Exclude or require prior authorization')\n</code></pre></p>"},{"location":"user-guide/health-economics-tutorial/#for-clinicians","title":"For Clinicians","text":"<p>Shared Decision-Making: <pre><code># Check individual patient factors\nhigh_cv_risk = True  # Patient has cardiovascular risk factors\nhigh_hba1c = True    # Poor glycemic control (HbA1c &gt;8%)\ncan_afford = True    # Insurance covers or patient can afford copay\n\nif high_cv_risk and high_hba1c and can_afford:\n    print('Recommendation: Consider GLP-1 agonist (higher benefit)')\nelif not can_afford:\n    print('Recommendation: Metformin (financial barrier to GLP-1)')\nelse:\n    print('Recommendation: Start with metformin, escalate if needed')\n</code></pre></p> <p>Population Health: - High-risk patients: GLP-1 (CV benefits justify cost) - Low-risk patients: Metformin (cost-effective first-line) - Resource stewardship: Tiered approach maximizes population health under budget constraint</p>"},{"location":"user-guide/health-economics-tutorial/#advanced-treatment-schedule-optimization","title":"Advanced: Treatment Schedule Optimization","text":"<p>Find the optimal dosing regimen to maximize Net Monetary Benefit.</p> <pre><code>from finbot.services.health_economics.treatment_optimizer import optimize_treatment\n\n# Optimize dose frequency and duration\nresults = optimize_treatment(\n    cost_per_dose=800.0,\n    cost_per_dose_std=100.0,\n    qaly_gain_per_dose=0.015,\n    qaly_gain_per_dose_std=0.003,\n    frequencies=[1, 2, 4, 12, 26, 52],  # doses per year\n    durations=[1, 2, 3, 5, 10, 15],     # years of treatment\n    baseline_utility=0.65,\n    baseline_mortality=0.03,\n    wtp_threshold=100_000,\n    n_sims=5000,\n    seed=42,\n)\n\n# Show top 5 schedules\nprint('Top 5 Treatment Schedules by NMB:')\ntop5 = results.head()\nfor _, row in top5.iterrows():\n    print(f'  {int(row[\"Frequency\"]):&gt;2} doses/yr \u00d7 {int(row[\"Duration\"]):&gt;2} yr  |  '\n          f'ICER: ${row[\"ICER\"]:&gt;10,.0f}/QALY  |  NMB: ${row[\"NMB\"]:&gt;10,.0f}')\n</code></pre> <p>Example Output: <pre><code>Top 5 Treatment Schedules by NMB:\n  12 doses/yr \u00d7 15 yr  |  ICER: $45,234/QALY  |  NMB: $142,567\n  12 doses/yr \u00d7 10 yr  |  ICER: $46,891/QALY  |  NMB: $138,234\n  26 doses/yr \u00d7 10 yr  |  ICER: $52,145/QALY  |  NMB: $135,789\n  ...\n</code></pre></p> <p>Interpretation: Monthly dosing (12/year) for 15 years maximizes NMB at $100K/QALY threshold.</p>"},{"location":"user-guide/health-economics-tutorial/#interpreting-results-for-different-audiences","title":"Interpreting Results for Different Audiences","text":""},{"location":"user-guide/health-economics-tutorial/#for-clinicians_1","title":"For Clinicians","text":"<p>Key Message: \"GLP-1 agonists provide 1.5 additional years of quality-adjusted life at a cost of ~$50,000 per QALY gained compared to metformin. This is considered cost-effective in the US (where thresholds are \\(50K-\\)150K/QALY) but may not be approved in countries like the UK where thresholds are lower (~$25K/QALY).\"</p> <p>Clinical Implication: Use GLP-1 for high-risk patients where benefit is greatest, metformin for lower-risk patients where cost-effectiveness is marginal.</p>"},{"location":"user-guide/health-economics-tutorial/#for-policymakers","title":"For Policymakers","text":"<p>Key Message: \"At current prices, GLP-1 agonists have an ICER of ~$50K/QALY. This exceeds NICE (UK) thresholds but falls within US acceptable ranges. Price negotiations could bring ICER below \u00a320K/QALY for UK approval.\"</p> <p>Policy Implication: Consider tiered formularies, negotiate rebates, or restrict to high-risk subgroups to improve cost-effectiveness.</p>"},{"location":"user-guide/health-economics-tutorial/#for-patients","title":"For Patients","text":"<p>Key Message: \"GLP-1 medications are newer, more expensive diabetes drugs that provide better blood sugar control and weight loss compared to metformin. Whether they're worth the extra cost depends on your insurance coverage and personal health situation. Your doctor can help you decide.\"</p> <p>Shared Decision: Discuss out-of-pocket costs, expected benefits, and personal values in consultation with physician.</p>"},{"location":"user-guide/health-economics-tutorial/#limitations-and-cautions","title":"Limitations and Cautions","text":""},{"location":"user-guide/health-economics-tutorial/#model-limitations","title":"Model Limitations","text":"<pre><code># What the model DOES capture:\n# \u2713 Cost uncertainty from price variability\n# \u2713 Efficacy uncertainty from clinical trial confidence intervals\n# \u2713 Mortality and quality-of-life trade-offs\n# \u2713 Time discounting (3% per WHO/NICE guidelines)\n\n# What the model DOES NOT capture:\n# \u2717 Disease progression states (e.g., complications like retinopathy, neuropathy)\n# \u2717 Treatment switching (e.g., metformin \u2192 GLP-1 if HbA1c not controlled)\n# \u2717 Real-world adherence (assumes 100% compliance, reality ~50-70%)\n# \u2717 Heterogeneity (all patients treated identically)\n</code></pre>"},{"location":"user-guide/health-economics-tutorial/#appropriate-uses","title":"Appropriate Uses","text":"<p>\u2713 Good Uses: - Exploring cost-effectiveness trade-offs between treatments - Identifying which patients benefit most (high-risk vs. low-risk) - Estimating population-level budget impact - Supporting formulary and clinical guideline decisions - Pedagogical demonstrations for teaching health economics</p> <p>\u2717 Bad Uses: - Sole basis for individual treatment decisions (clinical judgment required) - Assuming simulated outcomes will match real-world results exactly - Ignoring patient preferences, values, and financial circumstances - Treating ICERs as precise rather than estimates with uncertainty</p>"},{"location":"user-guide/health-economics-tutorial/#further-reading","title":"Further Reading","text":"<p>Methodology: - Health Economics Methodology - Full mathematical details, validation, 22 academic references</p> <p>Examples: - Health Economics Notebook - Interactive Jupyter notebook with visualizations</p> <p>Guidelines: - NICE Methods Guide: nice.org.uk/process/pmg9 - CADTH Guidelines: cadth.ca/guidelines - WHO CHOICE: who.int/choice - Second Panel Report (JAMA): Sanders GD, et al. JAMA 316.10 (2016): 1093-1103</p> <p>Academic Texts: - Drummond MF, et al. Methods for the Economic Evaluation of Health Care Programmes, 4th ed. Oxford, 2015. - Briggs AH, et al. Decision Modelling for Health Economic Evaluation. Oxford, 2006.</p>"},{"location":"user-guide/health-economics-tutorial/#summary","title":"Summary","text":"<p>You've learned to:</p> <ol> <li>\u2713 Define health interventions with cost and efficacy parameters</li> <li>\u2713 Run Monte Carlo simulations to capture uncertainty</li> <li>\u2713 Calculate ICER, NMB, and CEAC using standard methods</li> <li>\u2713 Interpret results against international thresholds (NICE/CADTH/WHO/US)</li> <li>\u2713 Make evidence-based clinical and policy decisions</li> <li>\u2713 Optimize treatment schedules to maximize value</li> </ol> <p>Key Takeaway: Cost-effectiveness analysis provides a rigorous framework for balancing health benefits against costs, but results are jurisdiction-dependent (different countries have different WTP thresholds) and should inform\u2014not replace\u2014clinical judgment.</p> <p>Next Steps: - Explore the methodology document for theoretical foundations - Run the Jupyter notebook for hands-on practice - Apply to your own clinical scenarios by modifying intervention parameters - Consider subgroup analysis (age, risk level, comorbidities) for more nuanced decisions</p> <p>Last Updated: 2026-02-12 Feedback: Open an issue on GitHub or contribute improvements via PR.</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>Detailed installation instructions for Finbot.</p>"},{"location":"user-guide/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: &gt;=3.11, &lt;3.15</li> <li>Operating System: Linux, macOS, or Windows (WSL recommended)</li> <li>Memory: 4GB RAM minimum, 8GB recommended</li> <li>Disk Space: 2GB for installation + data storage</li> </ul>"},{"location":"user-guide/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"user-guide/installation/#method-1-uv-recommended","title":"Method 1: uv (Recommended)","text":"<p>uv provides fast, reliable dependency management and environment isolation:</p> <pre><code># Install uv if not already installed\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install dependencies (creates .venv automatically)\nuv sync\n\n# Activate environment (optional, but recommended)\nsource .venv/bin/activate  # On Linux/Mac\n.venv\\Scripts\\activate     # On Windows\n\n# Verify installation\nfinbot --version\npython -c \"import finbot; print('Success!')\"\n</code></pre>"},{"location":"user-guide/installation/#method-2-pip-with-venv","title":"Method 2: pip with venv","text":"<p>Standard Python virtual environment approach:</p> <pre><code># Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Create virtual environment\npython3 -m venv venv\n\n# Activate (Linux/Mac)\nsource venv/bin/activate\n\n# Activate (Windows)\nvenv\\Scripts\\activate\n\n# Install package\npip install -e .\n\n# Verify\nfinbot --version\n</code></pre>"},{"location":"user-guide/installation/#post-installation","title":"Post-Installation","text":""},{"location":"user-guide/installation/#configure-environment","title":"Configure Environment","text":"<pre><code># Set environment variable\nexport DYNACONF_ENV=development  # or production\n\n# Add to ~/.bashrc or ~/.zshrc for persistence\necho 'export DYNACONF_ENV=development' &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"user-guide/installation/#install-optional-dependencies","title":"Install Optional Dependencies","text":"<p>For development:</p> <pre><code>uv sync\n</code></pre> <p>For documentation building:</p> <pre><code>uv sync\n</code></pre>"},{"location":"user-guide/installation/#verify-installation","title":"Verify Installation","text":"<p>Run the test suite:</p> <pre><code>uv run pytest -v\n</code></pre> <p>Expected: All 80 tests pass.</p>"},{"location":"user-guide/installation/#troubleshooting","title":"Troubleshooting","text":"<p>See Getting Started - Common Issues for help with installation problems.</p>"},{"location":"user-guide/quick-start/","title":"Quick Start","text":"<p>This guide provides a rapid walkthrough of Finbot's core features.</p>"},{"location":"user-guide/quick-start/#5-minute-quick-start","title":"5-Minute Quick Start","text":""},{"location":"user-guide/quick-start/#1-simulate-a-fund","title":"1. Simulate a Fund","text":"<pre><code># Simulate UPRO (3x leveraged S&amp;P 500)\nfinbot simulate --fund UPRO --start 2010-01-01 --plot\n</code></pre>"},{"location":"user-guide/quick-start/#2-backtest-a-strategy","title":"2. Backtest a Strategy","text":"<pre><code># Test 60/40 rebalancing strategy\nfinbot backtest --strategy Rebalance --asset SPY,TLT --plot\n</code></pre>"},{"location":"user-guide/quick-start/#3-optimize-allocation","title":"3. Optimize Allocation","text":"<pre><code># Find optimal SPY/TLT ratio\nfinbot optimize --method dca --assets SPY,TLT --plot\n</code></pre>"},{"location":"user-guide/quick-start/#detailed-workflows","title":"Detailed Workflows","text":"<p>See Getting Started for comprehensive documentation.</p>"}]}