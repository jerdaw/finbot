{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Finbot Documentation","text":"<p>Welcome to the Finbot documentation! Finbot is a comprehensive financial data collection, simulation, and backtesting platform designed for quantitative analysis and portfolio optimization.</p>"},{"location":"#overview","title":"Overview","text":"<p>Finbot consolidates three key areas of quantitative finance:</p> <ul> <li>Data Collection: Automated fetching from Yahoo Finance, FRED, Alpha Vantage, Google Finance, and more</li> <li>Simulation: Fund simulators (leveraged ETFs), bond ladders, Monte Carlo risk analysis</li> <li>Backtesting: 10 trading strategies with comprehensive performance metrics using Backtrader</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#comprehensive-backtesting-engine","title":"\ud83d\udcca Comprehensive Backtesting Engine","text":"<ul> <li>10 built-in strategies: Rebalance, NoRebalance, SMA Crossovers, MACD, Dip Buying, Hybrid strategies</li> <li>Performance metrics: CAGR, Sharpe ratio, Sortino ratio, Max drawdown, Win rate, Kelly criterion</li> <li>Powered by Backtrader: Industry-standard backtesting framework with custom analyzers</li> </ul>"},{"location":"#advanced-simulation-systems","title":"\ud83c\udfaf Advanced Simulation Systems","text":"<ul> <li>Fund Simulator: Simulate leveraged ETFs with fees, borrowing costs, and tracking error</li> <li>Bond Ladder Simulator: Model bond portfolios with yield curves and maturity rolling</li> <li>Monte Carlo Simulator: Portfolio risk analysis with probability distributions and VaR</li> <li>Specific fund implementations: SPY, SSO, UPRO, QQQ, TQQQ, TLT, TMF, and more</li> </ul>"},{"location":"#portfolio-optimization","title":"\ud83d\udd27 Portfolio Optimization","text":"<ul> <li>DCA Optimizer: Grid search across asset ratios, durations, and purchase intervals</li> <li>Rebalance Optimizer: Gradient descent for optimal portfolio rebalancing</li> <li>Multi-metric optimization: CAGR, Sharpe, Sortino, Max drawdown</li> </ul>"},{"location":"#data-collection-infrastructure","title":"\ud83d\udcc8 Data Collection Infrastructure","text":"<ul> <li>Multiple data sources: Yahoo Finance, FRED, Alpha Vantage, Google Finance, BLS, MSCI</li> <li>Automatic caching: Zstandard-compressed parquet files for performance</li> <li>Daily update pipeline: Automated data refresh with retry logic and error handling</li> </ul>"},{"location":"#modern-infrastructure","title":"\ud83d\udee0\ufe0f Modern Infrastructure","text":"<ul> <li>CLI interface: <code>finbot simulate</code>, <code>finbot backtest</code>, <code>finbot optimize</code>, <code>finbot update</code></li> <li>Dynaconf configuration: Environment-aware YAML config (development, production)</li> <li>Queue-based logging: Non-blocking async logging with JSON output</li> <li>Comprehensive utilities: 160+ utility functions across 15 categories</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install with uv\nuv sync\n\n# Set environment\nexport DYNACONF_ENV=development\n\n# Run tests\nuv run pytest\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code># Simulate a leveraged fund\nfinbot simulate --fund UPRO --start 2010-01-01 --plot\n\n# Backtest a strategy\nfinbot backtest --strategy Rebalance --asset SPY,TLT --plot\n\n# Optimize DCA portfolio\nfinbot optimize --method dca --assets SPY,TQQQ --plot\n\n# Update all data\nfinbot update\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<pre><code>from finbot.services.simulation import fund_simulator\nfrom finbot.services.backtesting import BacktestRunner\nfrom finbot.services.optimization import dca_optimizer\n\n# Simulate UPRO fund\nupro_sim = fund_simulator.simulate_fund('UPRO', start_date='2010-01-01')\n\n# Run backtest\nrunner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy_data, 'TLT': tlt_data},\n    strategy_params={'rebalance_days': 30}\n)\nresults = runner.run()\n\n# Optimize DCA strategy\noptimal_results = dca_optimizer(\n    price_history=combined_df,\n    ratio_linspace=(0.5, 0.95, 10),\n    dca_duration_days=365 * 5,\n    trial_duration_days=365 * 10\n)\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>User Guide: Installation, configuration, and usage tutorials</li> <li>API Reference: Detailed API documentation for all modules</li> <li>Research: Published research findings and analysis</li> <li>Contributing: Guidelines for contributors</li> </ul>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository: github.com/jerdaw/finbot</li> <li>Issue Tracker: GitHub Issues</li> <li>Changelog: CHANGELOG.md</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;=3.11, &lt;3.15</li> <li>uv for dependency management</li> <li>Optional: API keys for data sources (Alpha Vantage, NASDAQ Data Link, BLS, Google Finance)</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Finbot are documented here.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>For the full changelog, see CHANGELOG.md in the repository.</p>"},{"location":"changelog/#100-2026-02-10","title":"[1.0.0] - 2026-02-10","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>CLI interface with 4 commands (simulate, backtest, optimize, update)</li> <li>Comprehensive test suite (80 tests, 444% increase)</li> <li>5 example Jupyter notebooks</li> <li>3 research documents (~50 pages)</li> <li>Documentation (README expansion, utils overview, ADRs)</li> <li>Performance benchmarks</li> <li>CI/CD pipeline with 8 checks</li> <li>Dependabot configuration</li> <li>Makefile with 14 targets</li> <li>Pre-commit hooks (17 total)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Consolidated dual config system to Dynaconf only</li> <li>Refactored fund simulations to data-driven config</li> <li>Updated ruff to v0.11.13 with expanded rules</li> <li>Modernized pyproject.toml to PEP 621</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Logger code duplication</li> <li>Import-time side effects in constants</li> <li>Dangerous error handling (bare except, assert)</li> <li>103 lint violations \u2192 0</li> </ul>"},{"location":"changelog/#010-2026-02-09","title":"[0.1.0] - 2026-02-09","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial consolidated release</li> <li>Merged three repos (finbot, bb, backbetter)</li> <li>10 backtesting strategies</li> <li>Fund, bond ladder, and Monte Carlo simulators</li> <li>160+ utility functions</li> <li>Comprehensive data collection</li> <li>CI workflow</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Replaced numba with vectorized NumPy</li> <li>Replaced pickle with parquet</li> <li>Lazy API key loading</li> </ul>"},{"location":"changelog/#project-lineage","title":"Project Lineage","text":"<p>Finbot consolidates work from three repositories:</p> <ul> <li>finbot (2021-2022): Original backtesting and simulation code</li> <li>bb (2023-2024): Data collection and utilities</li> <li>backbetter (2022): Enhanced backtesting features</li> </ul> <p>See ADR-001 for consolidation rationale.</p>"},{"location":"contributing/","title":"Contributing to Finbot","text":"<p>Thank you for your interest in contributing to Finbot! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install with dev dependencies\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n\n# Run tests\nuv run pytest\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":""},{"location":"contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<pre><code># Run all checks\nmake check\n\n# Individual checks\nmake lint      # Ruff linting\nmake format    # Ruff formatting\nmake type      # Mypy type checking\nmake security  # Bandit security scan\n</code></pre>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Automatic hooks run on every commit: - Trailing whitespace removal - YAML/JSON/TOML syntax validation - Python AST validation - Ruff linting and formatting - Line ending normalization (LF)</p> <p>Manual hooks (run on demand): <pre><code>uv run pre-commit run --hook-stage manual mypy\nuv run pre-commit run --hook-stage manual bandit\n</code></pre></p>"},{"location":"contributing/#testing","title":"Testing","text":"<pre><code># Run all tests\nmake test\n\n# Run with coverage\nmake test-cov\n\n# Run specific test\nuv run pytest tests/unit/test_finance_utils.py -v\n</code></pre>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Python version: 3.11+</li> <li>Line length: 120 characters</li> <li>Docstrings: Google style</li> <li>Type hints: Required for all functions</li> <li>Imports: Sorted with ruff/isort</li> <li>Code style: ruff format</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create feature branch (<code>git checkout -b feature/my-feature</code>)</li> <li>Make changes with tests</li> <li>Run <code>make check</code> and <code>make test</code></li> <li>Commit with descriptive message</li> <li>Push to your fork</li> <li>Create pull request</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow conventional commit format:</p> <pre><code>type(scope): brief description\n\nLonger description if needed.\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>test</code>, <code>refactor</code>, <code>perf</code>, <code>chore</code></p>"},{"location":"contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"contributing/#new-utility-functions","title":"New Utility Functions","text":"<ol> <li>Add function to appropriate <code>finbot/utils/</code> category</li> <li>Add comprehensive docstring (Google style)</li> <li>Add type hints</li> <li>Add unit tests</li> <li>Update category README if needed</li> </ol>"},{"location":"contributing/#new-strategies","title":"New Strategies","text":"<ol> <li>Create strategy in <code>finbot/services/backtesting/strategies/</code></li> <li>Inherit from <code>bt.Strategy</code></li> <li>Add comprehensive docstring</li> <li>Add to strategy registry</li> <li>Add tests</li> </ol>"},{"location":"contributing/#new-simulators","title":"New Simulators","text":"<ol> <li>Create simulator in <code>finbot/services/simulation/</code></li> <li>Use vectorized NumPy operations</li> <li>Add comprehensive docstring</li> <li>Add validation tests</li> <li>Add performance benchmark</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#module-docstrings","title":"Module Docstrings","text":"<p>All modules require comprehensive module-level docstrings:</p> <pre><code>\"\"\"Brief one-line description.\n\nDetailed description with:\n- Purpose\n- Typical usage examples\n- Key features\n- Use cases\n- Performance notes\n- Limitations\n- Dependencies\n- Related modules\n\"\"\"\n</code></pre>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<p>Update mkdocs documentation when adding public APIs:</p> <pre><code># Build documentation\nuv run mkdocs build\n\n# Serve locally\nuv run mkdocs serve\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Documentation: This site</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"api/","title":"API Reference Overview","text":"<p>This section provides comprehensive API documentation for Finbot's modules, automatically generated from inline docstrings.</p>"},{"location":"api/#package-structure","title":"Package Structure","text":"<p>Finbot is organized into three main areas:</p>"},{"location":"api/#services-finbotservices","title":"Services (<code>finbot/services/</code>)","text":"<p>High-level analysis and simulation services:</p> <ul> <li>Backtesting (<code>backtesting/</code>): Strategy backtesting engine powered by Backtrader</li> <li><code>BacktestRunner</code>: Main orchestrator for running backtests</li> <li><code>run_backtest</code>, <code>backtest_batch</code>: Single and parallel backtest execution</li> <li><code>compute_stats</code>: Performance metrics calculation</li> <li><code>strategies/</code>: 10 trading strategies</li> <li> <p><code>rebalance_optimizer</code>: Portfolio rebalancing optimization</p> </li> <li> <p>Simulation (<code>simulation/</code>): Financial instrument simulators</p> </li> <li><code>fund_simulator</code>: Simulate leveraged ETFs with fees and borrowing costs</li> <li><code>bond_ladder/</code>: Bond ladder construction and simulation</li> <li><code>monte_carlo/</code>: Monte Carlo risk analysis</li> <li><code>sim_specific_funds</code>: Pre-configured fund simulations (SPY, UPRO, TQQQ, etc.)</li> <li> <p><code>sim_specific_*_indexes</code>: Stock and bond index simulations</p> </li> <li> <p>Optimization (<code>optimization/</code>): Portfolio optimization tools</p> </li> <li><code>dca_optimizer</code>: Dollar-cost averaging strategy optimizer</li> <li><code>rebalance_optimizer</code>: Rebalance ratio optimizer (convenience import)</li> </ul>"},{"location":"api/#utilities-finbotutils","title":"Utilities (<code>finbot/utils/</code>)","text":"<p>160+ utility functions across 15 categories:</p> Category Count Purpose finance_utils 19 CGR, drawdown, periods, risk-free rate, price trends datetime_utils 23 Business dates, duration, conversions, time ranges pandas_utils 17 Save/load parquet, filtering, frequency detection data_collection_utils 40 Yahoo Finance, FRED, Alpha Vantage, BLS, Google Finance data_science_utils 37 Missing data, outliers, scaling, imputation file_utils 10 Text I/O with compression, staleness checking json_utils 4 JSON serialization with zstandard compression request_utils 2 HTTP client with retry logic and caching plotting_utils 1 Interactive plotly visualizations multithreading_utils 1 Optimal thread count calculation validation_utils 1 Parameter validation helpers vectorization_utils 1 Vectorization profiling class_utils 1 Singleton metaclasses dict_utils 1 Deterministic dictionary hashing function_utils 1 Logging decorators"},{"location":"api/#infrastructure","title":"Infrastructure","text":"<ul> <li>config/: Dynaconf-based configuration with lazy API key loading</li> <li>constants/: Application constants (paths, APIs, datetime, networking)</li> <li>libs/: Core libraries (API manager, queue-based logger)</li> </ul>"},{"location":"api/#navigation","title":"Navigation","text":"<p>Use the left sidebar to navigate to specific modules. Each page provides:</p> <ul> <li>Module overview and purpose</li> <li>Typical usage examples</li> <li>Full API documentation with signatures</li> <li>Parameter descriptions</li> <li>Return types</li> <li>Raises information</li> <li>Related modules</li> </ul>"},{"location":"api/#key-entry-points","title":"Key Entry Points","text":"Module Purpose Documentation <code>fund_simulator</code> Simulate leveraged funds Fund Simulator API <code>BacktestRunner</code> Run strategy backtests BacktestRunner API <code>dca_optimizer</code> Optimize DCA strategies DCA Optimizer API <code>monte_carlo_simulator</code> Portfolio risk analysis Monte Carlo API <code>finbot.cli</code> Command-line interface CLI Reference"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All services and utilities include type hints for parameters and return values. Type checking is performed using <code>mypy</code> with strict optional checking.</p>"},{"location":"api/#docstring-format","title":"Docstring Format","text":"<p>All modules use Google-style docstrings with the following sections:</p> <ul> <li>Module-level docstring with purpose, usage examples, and features</li> <li>Function/method docstrings with Args, Returns, Raises</li> <li>Class docstrings with attributes and methods</li> </ul>"},{"location":"api/#source-code","title":"Source Code","text":"<p>All API documentation pages include links to the source code on GitHub for reference.</p>"},{"location":"api/services/backtesting/backtest-runner/","title":"BacktestRunner","text":"<p>The <code>BacktestRunner</code> class is the main orchestrator for running backtests in Finbot. It wraps Backtrader's Cerebro engine and provides a simplified interface for testing trading strategies.</p>"},{"location":"api/services/backtesting/backtest-runner/#overview","title":"Overview","text":"<p><code>BacktestRunner</code> provides:</p> <ul> <li>Strategy initialization with parameters</li> <li>Data feed management (multiple assets)</li> <li>Broker configuration (cash, commission)</li> <li>Custom analyzers for performance tracking</li> <li>Results processing and statistics computation</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.backtesting.backtest_runner import BacktestRunner\nimport pandas as pd\n\n# Load price data\nspy_data = pd.read_parquet('spy_prices.parquet')\ntlt_data = pd.read_parquet('tlt_prices.parquet')\n\n# Create backtest runner\nrunner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy_data, 'TLT': tlt_data},\n    strategy_params={'rebalance_days': 30},\n    cash=100000,\n    commission=0.001\n)\n\n# Run backtest\nresults = runner.run()\n\n# Get statistics\nstats = runner.get_stats()\nprint(f\"CAGR: {stats['CAGR']:.2%}\")\nprint(f\"Sharpe: {stats['Sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['Max Drawdown']:.2%}\")\n</code></pre>"},{"location":"api/services/backtesting/backtest-runner/#class-backtestrunner","title":"Class: BacktestRunner","text":"<p>Location: <code>finbot.services.backtesting.backtest_runner</code></p>"},{"location":"api/services/backtesting/backtest-runner/#constructor","title":"Constructor","text":"<pre><code>BacktestRunner(\n    strategy: str,\n    data_feeds: dict[str, pd.DataFrame],\n    strategy_params: dict[str, Any] = None,\n    cash: float = 100000,\n    commission: float = 0.001\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>strategy</code> (str): Strategy name (Rebalance, SMACrossover, etc.)</li> <li><code>data_feeds</code> (dict): Dictionary mapping tickers to DataFrames</li> <li><code>strategy_params</code> (dict, optional): Strategy-specific parameters</li> <li><code>cash</code> (float, optional): Starting cash amount (default: 100000)</li> <li><code>commission</code> (float, optional): Commission rate (default: 0.001)</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/#methods","title":"Methods","text":""},{"location":"api/services/backtesting/backtest-runner/#run","title":"run()","text":"<p>Execute the backtest and return results.</p> <pre><code>results = runner.run()\n</code></pre> <p>Returns: Dictionary with backtest results including portfolio values, returns, and analyzer data.</p>"},{"location":"api/services/backtesting/backtest-runner/#get_stats","title":"get_stats()","text":"<p>Calculate performance statistics.</p> <pre><code>stats = runner.get_stats()\n</code></pre> <p>Returns: Dictionary with performance metrics: - CAGR: Compound annual growth rate - Sharpe: Sharpe ratio - Sortino: Sortino ratio - Calmar: Calmar ratio - Max Drawdown: Maximum drawdown percentage - Win Rate: Percentage of winning trades - Volatility: Annualized volatility</p>"},{"location":"api/services/backtesting/backtest-runner/#supported-strategies","title":"Supported Strategies","text":"<ul> <li>Rebalance: Periodic portfolio rebalancing</li> <li>NoRebalance: Buy and hold</li> <li>SMACrossover: Simple moving average crossover</li> <li>SMACrossoverDouble: Dual SMA crossover</li> <li>SMACrossoverTriple: Triple SMA crossover</li> <li>MACDSingle: MACD-based strategy</li> <li>MACDDual: Dual MACD strategy</li> <li>DipBuySMA: Buy dips with SMA filter</li> <li>DipBuyStdev: Buy dips with standard deviation filter</li> <li>SMARebalMix: Mixed SMA + rebalance approach</li> </ul>"},{"location":"api/services/backtesting/backtest-runner/#performance-metrics","title":"Performance Metrics","text":"<p>The backtest computes the following metrics using quantstats:</p> Metric Description CAGR Compound Annual Growth Rate Sharpe Ratio Risk-adjusted return (Rf = 2%) Sortino Ratio Downside risk-adjusted return Calmar Ratio CAGR / Max Drawdown Max Drawdown Largest peak-to-trough decline Win Rate Percentage of winning trades Kelly Criterion Optimal position sizing Volatility Annualized standard deviation"},{"location":"api/services/backtesting/backtest-runner/#examples","title":"Examples","text":""},{"location":"api/services/backtesting/backtest-runner/#basic-rebalance-strategy","title":"Basic Rebalance Strategy","text":"<pre><code>runner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy, 'TLT': tlt},\n    strategy_params={\n        'rebalance_days': 30,\n        'target_allocations': {'SPY': 0.6, 'TLT': 0.4}\n    }\n)\nresults = runner.run()\n</code></pre>"},{"location":"api/services/backtesting/backtest-runner/#sma-crossover-with-custom-parameters","title":"SMA Crossover with Custom Parameters","text":"<pre><code>runner = BacktestRunner(\n    strategy='SMACrossover',\n    data_feeds={'SPY': spy},\n    strategy_params={\n        'fast_period': 50,\n        'slow_period': 200\n    },\n    cash=100000,\n    commission=0.001\n)\nresults = runner.run()\n</code></pre>"},{"location":"api/services/backtesting/backtest-runner/#see-also","title":"See Also","text":"<ul> <li>run_backtest Function - Single backtest execution</li> <li>compute_stats Function - Performance metrics</li> <li>User Guide: Backtesting - Tutorial</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/","title":"DCA Optimizer","text":"<p>The DCA (Dollar Cost Averaging) optimizer performs grid search across asset allocation ratios, DCA durations, and purchase intervals to find optimal portfolio strategies.</p>"},{"location":"api/services/optimization/dca-optimizer/#overview","title":"Overview","text":"<p>The optimizer:</p> <ul> <li>Tests combinations of allocation ratios, DCA durations, and purchase intervals</li> <li>Calculates CAGR, Sharpe ratio, Sortino ratio, max drawdown, and std dev for each</li> <li>Uses multiprocessing for parallel evaluation (~70-80 combinations/second)</li> <li>Returns results ranked by Sharpe ratio</li> <li>Supports 2-asset portfolios (extensible to N assets)</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.optimization.dca_optimizer import dca_optimizer\nimport pandas as pd\n\n# Load price data\nspy = pd.read_parquet('spy_prices.parquet')['Close']\ntlt = pd.read_parquet('tlt_prices.parquet')['Close']\n\n# Merge on common dates\ncombined = pd.DataFrame({'SPY': spy, 'TLT': tlt}).dropna()\n\n# Run optimizer\nresults = dca_optimizer(\n    price_history=combined,\n    ratio_linspace=(0.50, 0.95, 10),  # Test 50% to 95% in SPY (10 values)\n    dca_duration_days=365 * 5,  # 5-year DCA period\n    dca_step_days=30,  # Monthly purchases\n    trial_duration_days=365 * 10,  # 10-year trial period\n    starting_cash=100000\n)\n\n# View top results\nprint(results.head())\nprint(f\"Optimal allocation: {results.iloc[0]['ratio']:.0%} SPY / {1-results.iloc[0]['ratio']:.0%} TLT\")\nprint(f\"Optimal Sharpe: {results.iloc[0]['sharpe']:.2f}\")\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#api-reference","title":"API Reference","text":""},{"location":"api/services/optimization/dca-optimizer/#finbot.services.optimization.dca_optimizer.dca_optimizer","title":"finbot.services.optimization.dca_optimizer.dca_optimizer","text":"<pre><code>dca_optimizer(\n    price_history: Series,\n    ticker: str | None = None,\n    ratio_range: tuple = (1, 1.5, 2, 3, 5, 10),\n    dca_durations: tuple = tuple(\n        (round(n))\n        for n in (\n            1,\n            5,\n            252 / 12,\n            252 / 4,\n            252 / 2,\n            252,\n            252 * 2,\n            252 * 3,\n        )\n    ),\n    dca_steps: tuple = tuple(\n        (round(n)) for n in (1, 5, 10, 252 / 12, 252 / 4)\n    ),\n    trial_durations: tuple = tuple(\n        (round(n)) for n in (252 * 3, 252 * 5)\n    ),\n    starting_cash: float = 1000,\n    start_step: int = 5,\n    save_df: bool = True,\n    analyze_results: bool = True,\n) -&gt; pd.DataFrame | tuple[pd.DataFrame, pd.DataFrame]\n</code></pre> <p>Run DCA optimization across many parameter combinations.</p>"},{"location":"api/services/optimization/dca-optimizer/#finbot.services.optimization.dca_optimizer.dca_optimizer--parameters","title":"Parameters","text":"<p>price_history : pd.Series     Series of \"Adj Close\" or \"Close\" float values. ticker : str, optional     Ticker symbol for labeling output. ratio_range : tuple     Ratios of amount to invest on first DCA day over last DCA day. dca_durations : tuple     Number of periods to DCA over. dca_steps : tuple     Number of periods between DCA purchases. trial_durations : tuple     Total number of periods per trial. starting_cash : float     Starting cash amount. start_step : int     Periods to advance trial starting point between trials. save_df : bool     Whether to save results to parquet. analyze_results : bool     Whether to return analyzed results or raw DataFrame.</p>"},{"location":"api/services/optimization/dca-optimizer/#finbot.services.optimization.dca_optimizer.dca_optimizer--raises","title":"Raises","text":"<p>ValueError     If price_history is None or empty.</p> Source code in <code>finbot/services/optimization/dca_optimizer.py</code> <pre><code>def dca_optimizer(\n    price_history: pd.Series,\n    ticker: str | None = None,\n    ratio_range: tuple = (1, 1.5, 2, 3, 5, 10),\n    dca_durations: tuple = tuple(round(n) for n in (1, 5, 252 / 12, 252 / 4, 252 / 2, 252, 252 * 2, 252 * 3)),\n    dca_steps: tuple = tuple(round(n) for n in (1, 5, 10, 252 / 12, 252 / 4)),\n    trial_durations: tuple = tuple(round(n) for n in (252 * 3, 252 * 5)),\n    starting_cash: float = 1000,\n    start_step: int = 5,\n    save_df: bool = True,\n    analyze_results: bool = True,\n) -&gt; pd.DataFrame | tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Run DCA optimization across many parameter combinations.\n\n    Parameters\n    ----------\n    price_history : pd.Series\n        Series of \"Adj Close\" or \"Close\" float values.\n    ticker : str, optional\n        Ticker symbol for labeling output.\n    ratio_range : tuple\n        Ratios of amount to invest on first DCA day over last DCA day.\n    dca_durations : tuple\n        Number of periods to DCA over.\n    dca_steps : tuple\n        Number of periods between DCA purchases.\n    trial_durations : tuple\n        Total number of periods per trial.\n    starting_cash : float\n        Starting cash amount.\n    start_step : int\n        Periods to advance trial starting point between trials.\n    save_df : bool\n        Whether to save results to parquet.\n    analyze_results : bool\n        Whether to return analyzed results or raw DataFrame.\n\n    Raises\n    ------\n    ValueError\n        If price_history is None or empty.\n    \"\"\"\n    # Input validation\n    if price_history is None or price_history.empty:\n        raise ValueError(\"price_history cannot be None or empty\")\n\n    closes = tuple(price_history)\n    start_idxs = tuple(start_step * n for n in range((len(price_history) - max(trial_durations)) // start_step))\n\n    # Create DCAParameters objects for each combination\n    params_list = [\n        DCAParameters(\n            start_idx=start_idx,\n            ratio=ratio,\n            dca_duration=dca_duration,\n            dca_step=dca_step,\n            trial_duration=trial_duration,\n            closes=closes,\n            starting_cash=starting_cash,\n        )\n        for start_idx, ratio, dca_duration, dca_step, trial_duration in itertools.product(\n            start_idxs, ratio_range, dca_durations, dca_steps, trial_durations\n        )\n    ]\n\n    n_combs = len(params_list)\n    data = process_map(_mp_helper, params_list, total=n_combs, chunksize=1000, desc=f\"Running DCA Optimizer - {ticker}\")\n\n    price_hist_idxs = price_history.index\n    df = _convert_to_df(data, price_hist_idxs)\n    if save_df:\n        file_name = f\"{ticker if ticker else str(pd.Timestamp.now())} - DCA Optimizer.parquet\"\n        df.to_parquet(BACKTESTS_DATA_DIR / file_name)\n\n    if analyze_results:\n        return analyze_results_helper(df)\n    return df\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#parameters-explained","title":"Parameters Explained","text":""},{"location":"api/services/optimization/dca-optimizer/#ratio_linspace","title":"ratio_linspace","text":"<p>Defines the range of allocation ratios to test: - Format: <code>(start, stop, num_points)</code> - Example: <code>(0.5, 0.95, 10)</code> tests 50%, 55%, 60%, ..., 95% in asset 1 - Interpretation: <code>ratio</code> is allocation to first asset, <code>1-ratio</code> is allocation to second</p>"},{"location":"api/services/optimization/dca-optimizer/#dca_duration_days","title":"dca_duration_days","text":"<p>How long the DCA accumulation period lasts: - Short (1-2 years): Better for fast-moving bull markets - Medium (3-5 years): Balanced, averages out volatility - Long (7-10 years): Better for volatile markets, maximum cost averaging</p>"},{"location":"api/services/optimization/dca-optimizer/#dca_step_days","title":"dca_step_days","text":"<p>Frequency of purchases during DCA period: - Daily (1): Maximum cost averaging, high transaction costs - Weekly (7): Good balance - Monthly (30): Standard DCA approach, realistic for most investors - Quarterly (90): Minimal transactions, less cost averaging benefit</p>"},{"location":"api/services/optimization/dca-optimizer/#trial_duration_days","title":"trial_duration_days","text":"<p>Total time horizon for evaluation (must be &gt; dca_duration_days): - Should be 2-3x dca_duration_days for meaningful results - Includes both accumulation (DCA) and hold period - Example: 5-year DCA + 5-year hold = 10-year trial</p>"},{"location":"api/services/optimization/dca-optimizer/#optimization-metrics","title":"Optimization Metrics","text":"<p>The optimizer calculates these metrics for each combination:</p> Metric Description Interpretation CAGR Compound Annual Growth Rate Higher is better (growth) Sharpe Risk-adjusted return (Rf=2%) Higher is better (&gt;1 good, &gt;2 excellent) Sortino Downside risk-adjusted return Higher is better (focuses on negative volatility) Max Drawdown Largest peak-to-trough decline Lower is better (risk metric) Std Dev Annualized volatility Lower is better (risk metric) <p>Results are sorted by Sharpe ratio (best risk-adjusted return).</p>"},{"location":"api/services/optimization/dca-optimizer/#performance","title":"Performance","text":"<p>Based on comprehensive benchmarks:</p> Test Case Combinations Time (s) Rate (comb/s) Simple 500 7.10 70.4 Medium 1,000 13.22 75.6 Large 2,000 26.45 75.6 <p>Key Findings: - Consistent ~70-80 combinations/second across data sizes - Multiprocessing scales well with parameter space - Can evaluate 1,000 strategies in ~13 seconds</p>"},{"location":"api/services/optimization/dca-optimizer/#examples","title":"Examples","text":""},{"location":"api/services/optimization/dca-optimizer/#classic-6040-validation","title":"Classic 60/40 Validation","text":"<p>Test if 60/40 SPY/TLT is optimal:</p> <pre><code>results = dca_optimizer(\n    price_history=spy_tlt_combined,\n    ratio_linspace=(0.4, 0.8, 9),  # Test 40% to 80% SPY\n    dca_duration_days=365 * 5,\n    dca_step_days=30,\n    trial_duration_days=365 * 15\n)\n\n# Find 60/40 allocation\nrow_60_40 = results[abs(results['ratio'] - 0.6) &lt; 0.01]\nprint(f\"60/40 Sharpe: {row_60_40.iloc[0]['sharpe']:.2f}\")\nprint(f\"Best Sharpe: {results.iloc[0]['sharpe']:.2f}\")\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#leveraged-portfolio-optimization","title":"Leveraged Portfolio Optimization","text":"<p>Optimize UPRO/TMF allocation:</p> <pre><code>upro = get_history('UPRO')['Close']\ntmf = get_history('TMF')['Close']\ncombined = pd.DataFrame({'UPRO': upro, 'TMF': tmf}).dropna()\n\nresults = dca_optimizer(\n    price_history=combined,\n    ratio_linspace=(0.3, 0.7, 9),  # Test 30% to 70% UPRO\n    dca_duration_days=365 * 3,  # Shorter for leveraged\n    dca_step_days=30,\n    trial_duration_days=365 * 10\n)\n\nprint(f\"Optimal UPRO allocation: {results.iloc[0]['ratio']:.0%}\")\nprint(f\"Expected CAGR: {results.iloc[0]['cagr']:.2%}\")\nprint(f\"Expected Max DD: {results.iloc[0]['max_dd']:.2%}\")\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#dca-duration-sensitivity","title":"DCA Duration Sensitivity","text":"<p>Test impact of DCA duration:</p> <pre><code>durations = [365, 365*2, 365*3, 365*5, 365*7]\nduration_results = []\n\nfor duration in durations:\n    results = dca_optimizer(\n        price_history=combined,\n        ratio_linspace=(0.6, 0.6, 1),  # Fixed 60% allocation\n        dca_duration_days=duration,\n        dca_step_days=30,\n        trial_duration_days=duration * 2\n    )\n    duration_results.append({\n        'duration_years': duration / 365,\n        'sharpe': results.iloc[0]['sharpe'],\n        'cagr': results.iloc[0]['cagr']\n    })\n\nduration_df = pd.DataFrame(duration_results)\nprint(duration_df)\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#purchase-frequency-comparison","title":"Purchase Frequency Comparison","text":"<p>Test daily vs weekly vs monthly purchases:</p> <pre><code>frequencies = [1, 7, 30, 90]  # Daily, weekly, monthly, quarterly\nfreq_results = []\n\nfor freq in frequencies:\n    results = dca_optimizer(\n        price_history=combined,\n        ratio_linspace=(0.6, 0.6, 1),\n        dca_duration_days=365 * 5,\n        dca_step_days=freq,\n        trial_duration_days=365 * 10\n    )\n    freq_results.append({\n        'frequency': f\"Every {freq} days\",\n        'sharpe': results.iloc[0]['sharpe'],\n        'num_purchases': 365 * 5 // freq\n    })\n\nfreq_df = pd.DataFrame(freq_results)\nprint(freq_df)\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#results-dataframe","title":"Results DataFrame","text":"<p>The optimizer returns a pandas DataFrame with these columns:</p> <pre><code>&gt;&gt;&gt; results.columns\nIndex(['start_idx', 'ratio', 'cagr', 'sharpe', 'sortino', 'max_dd', 'std'], dtype='object')\n\n&gt;&gt;&gt; results.dtypes\nstart_idx      int64\nratio        float64\ncagr         float64\nsharpe       float64\nsortino      float64\nmax_dd       float64\nstd          float64\ndtype: object\n</code></pre>"},{"location":"api/services/optimization/dca-optimizer/#column-descriptions","title":"Column Descriptions","text":"<ul> <li>start_idx: Starting index in price history for this trial</li> <li>ratio: Allocation ratio to first asset (0-1)</li> <li>cagr: Compound annual growth rate (decimal, e.g., 0.12 = 12%)</li> <li>sharpe: Sharpe ratio with 2% risk-free rate</li> <li>sortino: Sortino ratio (downside risk only)</li> <li>max_dd: Maximum drawdown (decimal, e.g., -0.20 = -20%)</li> <li>std: Annualized standard deviation (volatility)</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/#multiprocessing","title":"Multiprocessing","text":"<p>The optimizer uses <code>multiprocessing.Pool</code> to parallelize trials:</p> <pre><code># Automatically uses all available CPU cores minus 1\nnum_workers = multiprocessing.cpu_count() - 1\n\nwith Pool(num_workers) as pool:\n    results = pool.map(_mp_helper, parameter_combinations)\n</code></pre> <p>Benefits: - Linear speedup with CPU cores (4 cores \u2248 4x faster) - Evaluates independent trials in parallel - Automatically chunks work across processes</p> <p>Considerations: - Overhead for small parameter spaces (&lt;100 combinations) - Memory usage scales with number of workers - Not compatible with Jupyter notebooks (use <code>if __name__ == '__main__'</code>)</p>"},{"location":"api/services/optimization/dca-optimizer/#limitations","title":"Limitations","text":"<ul> <li>Two assets only: Current implementation supports 2-asset portfolios</li> <li>Equal purchase amounts: Buys equal dollar amounts at each step</li> <li>No transaction costs: Assumes zero trading fees</li> <li>Historical data: Optimizes on past data (risk of overfitting)</li> <li>Static allocation: Doesn't consider dynamic rebalancing during DCA</li> <li>No dividends: Price appreciation only</li> </ul>"},{"location":"api/services/optimization/dca-optimizer/#best-practices","title":"Best Practices","text":"<ol> <li>Use sufficient trial duration: At least 2x DCA duration</li> <li>Test multiple periods: Don't rely on single historical period</li> <li>Consider transaction costs: Adjust for your broker's fees</li> <li>Validate on out-of-sample data: Test on recent data not used for optimization</li> <li>Use Monte Carlo: Complement with forward-looking simulations</li> <li>Consider taxes: Optimize after-tax returns if relevant</li> </ol>"},{"location":"api/services/optimization/dca-optimizer/#see-also","title":"See Also","text":"<ul> <li>Research: DCA Optimization Findings - Detailed research results</li> <li>Monte Carlo Simulator - Forward-looking risk analysis</li> <li>Rebalance Optimizer - Post-accumulation rebalancing</li> <li>Performance Benchmarks - Optimization performance analysis</li> </ul>"},{"location":"api/services/simulation/fund-simulator/","title":"Fund Simulator","text":"<p>The fund simulator models leveraged ETFs with realistic fees, borrowing costs, and spread expenses. It uses vectorized NumPy operations for high performance.</p>"},{"location":"api/services/simulation/fund-simulator/#overview","title":"Overview","text":"<p>The fund simulator:</p> <ul> <li>Simulates leveraged fund returns from underlying index data</li> <li>Accounts for expense ratios, borrowing costs (LIBOR), and spread</li> <li>Uses adjustment constants calibrated to real ETF data</li> <li>Processes 40 years of data in ~110ms (92,000 trading days/second)</li> <li>Validates against actual ETF performance with 2-5% tracking error</li> </ul>"},{"location":"api/services/simulation/fund-simulator/#key-functions","title":"Key Functions","text":""},{"location":"api/services/simulation/fund-simulator/#simulate_fund","title":"simulate_fund","text":"<p>Generic fund simulation function that looks up configuration from registry:</p>"},{"location":"api/services/simulation/fund-simulator/#finbot.services.simulation.sim_specific_funds.simulate_fund","title":"finbot.services.simulation.sim_specific_funds.simulate_fund","text":"<pre><code>simulate_fund(\n    ticker: str,\n    underlying=None,\n    libor_yield_df=None,\n    save_sim: bool = True,\n    force_update: bool = False,\n    adj=None,\n    overwrite_sim_with_fund: bool | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Simulate any fund by ticker using configuration registry.</p> <p>This is the new recommended way to simulate funds. It uses a data-driven configuration approach that's easier to maintain and extend.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Fund ticker symbol (e.g., \"SPY\", \"UPRO\", \"TQQQ\")</p> required <code>underlying</code> <p>Pre-computed underlying index price history (optional)</p> <code>None</code> <code>libor_yield_df</code> <p>LIBOR yield data for swap cost calculation (optional)</p> <code>None</code> <code>save_sim</code> <code>bool</code> <p>Whether to save simulation to disk (default: True)</p> <code>True</code> <code>force_update</code> <code>bool</code> <p>Force regeneration even if cached version exists (default: False)</p> <code>False</code> <code>adj</code> <p>Override additive constant (default: use config value)</p> <code>None</code> <code>overwrite_sim_with_fund</code> <code>bool | None</code> <p>Override config setting for actual data merge</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with simulated fund price history (columns: \"Close\", \"Change\")</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If ticker is not in FUND_CONFIGS registry</p> Example <p>spy_sim = simulate_fund(\"SPY\") upro_sim = simulate_fund(\"UPRO\", force_update=True)</p> Source code in <code>finbot/services/simulation/sim_specific_funds.py</code> <pre><code>def simulate_fund(\n    ticker: str,\n    underlying=None,\n    libor_yield_df=None,\n    save_sim: bool = True,\n    force_update: bool = False,\n    adj=None,\n    overwrite_sim_with_fund: bool | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Simulate any fund by ticker using configuration registry.\n\n    This is the new recommended way to simulate funds. It uses a data-driven\n    configuration approach that's easier to maintain and extend.\n\n    Parameters:\n        ticker: Fund ticker symbol (e.g., \"SPY\", \"UPRO\", \"TQQQ\")\n        underlying: Pre-computed underlying index price history (optional)\n        libor_yield_df: LIBOR yield data for swap cost calculation (optional)\n        save_sim: Whether to save simulation to disk (default: True)\n        force_update: Force regeneration even if cached version exists (default: False)\n        adj: Override additive constant (default: use config value)\n        overwrite_sim_with_fund: Override config setting for actual data merge\n\n    Returns:\n        DataFrame with simulated fund price history (columns: \"Close\", \"Change\")\n\n    Raises:\n        ValueError: If ticker is not in FUND_CONFIGS registry\n\n    Example:\n        &gt;&gt;&gt; spy_sim = simulate_fund(\"SPY\")\n        &gt;&gt;&gt; upro_sim = simulate_fund(\"UPRO\", force_update=True)\n    \"\"\"\n    ticker_upper = ticker.upper()\n    if ticker_upper not in FUND_CONFIGS:\n        available = \", \".join(sorted(FUND_CONFIGS.keys()))\n        raise ValueError(f\"Unknown fund ticker: {ticker}. Available funds: {available}\")\n\n    config = FUND_CONFIGS[ticker_upper]\n\n    # Use config's overwrite setting unless explicitly overridden\n    overwrite = config.overwrite_sim_with_fund if overwrite_sim_with_fund is None else overwrite_sim_with_fund\n\n    return _sim_fund(\n        config.name,\n        config.underlying_func,\n        config.leverage_mult,\n        config.annual_er_pct,\n        config.percent_daily_spread_cost,\n        config.fund_swap_pct,\n        config.additive_constant,\n        underlying,\n        libor_yield_df,\n        save_sim,\n        force_update,\n        adj,\n        overwrite,\n    )\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#fund_simulator","title":"fund_simulator","text":"<p>Core simulation function with full parameter control:</p>"},{"location":"api/services/simulation/fund-simulator/#finbot.services.simulation.fund_simulator.fund_simulator","title":"finbot.services.simulation.fund_simulator.fund_simulator","text":"<pre><code>fund_simulator(\n    price_df: DataFrame,\n    leverage_mult: float = 1,\n    annual_er_pct: float = 0.5 / 100,\n    percent_daily_spread_cost: float = 0,\n    fund_swap_pct: float = 0,\n    periods_per_year: int = 250,\n    multiplicative_constant: float = 1,\n    additive_constant: float = 0,\n    libor_yield_df: DataFrame | Series | None = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Returns a pd.DataFrame fund simulation with \"Close\" and percent \"Change\" values.</p> <p>Parameters:</p> Name Type Description Default <code>price_df</code> <code>DataFrame</code> <p>DataFrame with Timestamp index and \"Close\" or \"Adj Close\" column.</p> required <code>leverage_mult</code> <code>float</code> <p>Leverage multiplier applied to underlying daily pct change.</p> <code>1</code> <code>annual_er_pct</code> <code>float</code> <p>Annual expense ratio (decimal form).</p> <code>0.5 / 100</code> <code>percent_daily_spread_cost</code> <code>float</code> <p>Spread cost (decimal form) on the current fund date.</p> <code>0</code> <code>fund_swap_pct</code> <code>float</code> <p>Fraction of fund allocated to swap contracts.</p> <code>0</code> <code>periods_per_year</code> <code>int</code> <p>Number of compounding periods per year.</p> <code>250</code> <code>multiplicative_constant</code> <code>float</code> <p>Multiplicative curve fitting constant (1 = no effect).</p> <code>1</code> <code>additive_constant</code> <code>float</code> <p>Additive curve fitting constant (0 = no effect).</p> <code>0</code> <code>libor_yield_df</code> <code>DataFrame | Series | None</code> <p>DataFrame/Series with Timestamp index and \"Yield\" column.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with simulated \"Close\" and percent \"Change\" values.</p> Source code in <code>finbot/services/simulation/fund_simulator.py</code> <pre><code>def fund_simulator(\n    price_df: pd.DataFrame,\n    leverage_mult: float = 1,\n    annual_er_pct: float = 0.5 / 100,\n    percent_daily_spread_cost: float = 0,\n    fund_swap_pct: float = 0,\n    periods_per_year: int = 250,\n    multiplicative_constant: float = 1,\n    additive_constant: float = 0,\n    libor_yield_df: pd.DataFrame | pd.Series | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a pd.DataFrame fund simulation with \"Close\" and percent \"Change\" values.\n\n    Args:\n        price_df: DataFrame with Timestamp index and \"Close\" or \"Adj Close\" column.\n        leverage_mult: Leverage multiplier applied to underlying daily pct change.\n        annual_er_pct: Annual expense ratio (decimal form).\n        percent_daily_spread_cost: Spread cost (decimal form) on the current fund date.\n        fund_swap_pct: Fraction of fund allocated to swap contracts.\n        periods_per_year: Number of compounding periods per year.\n        multiplicative_constant: Multiplicative curve fitting constant (1 = no effect).\n        additive_constant: Additive curve fitting constant (0 = no effect).\n        libor_yield_df: DataFrame/Series with Timestamp index and \"Yield\" column.\n\n    Returns:\n        DataFrame with simulated \"Close\" and percent \"Change\" values.\n    \"\"\"\n    # Data validation\n    if (\n        libor_yield_df is not None\n        and hasattr(libor_yield_df, \"index\")\n        and libor_yield_df.index.dtype.name != \"datetime64[ns]\"\n    ):\n        raise ValueError(\n            f\"libor_yield_df must be indexed with dates of dtype datetime64[ns], not {libor_yield_df.index.dtype.name}\"\n        )\n    if price_df.index.dtype.name != \"datetime64[ns]\":\n        raise ValueError(\n            f\"price_df must be indexed with dates of dtype datetime64[ns], not {price_df.index.dtype.name}\"\n        )\n    casefold_cols = [n.casefold() for n in price_df.columns]\n    if \"close\" not in casefold_cols and \"adj close\" not in casefold_cols:\n        raise ValueError(\"price_df must contain 'Close' column or 'Adj Close' column\")\n\n    # Get/generate approximate overnight lending rate\n    if libor_yield_df is None:\n        libor_yield_df = approximate_overnight_libor()\n    # Ensure a \"Yield\" column or Series\n    if isinstance(libor_yield_df, pd.Series):\n        libor_yield_df = (\n            libor_yield_df.to_frame(name=\"Yield\") if libor_yield_df.name != \"Yield\" else libor_yield_df.to_frame()\n        )\n\n    # Ensure all dates in price_df are also in libor_yield_df\n    if not set(price_df.index).issubset(set(libor_yield_df.index)):\n        libor_yield_df = pd.concat([libor_yield_df, price_df], axis=1, join=\"outer\")\n        libor_yield_df = pd.DataFrame(libor_yield_df[\"Yield\"]).interpolate().bfill()\n\n    logger.info(\"Building fund simulation...\")\n    # Get the close column to use (\"Adj Close\" has priority)\n    close_col = \"Adj Close\" if \"Adj Close\" in price_df.columns else \"Close\"\n    underlying_changes = price_df[close_col].pct_change().to_numpy()\n    underlying_changes[0] = 0\n    period_libor_yield_percents = libor_yield_df.loc[price_df.index, \"Yield\"].to_numpy() / 100\n\n    # Vectorized computation replacing numba @jit loop\n    changes = _compute_sim_changes(\n        underlying_changes=underlying_changes,\n        period_libor_yield_percents=period_libor_yield_percents,\n        leverage_mult=leverage_mult,\n        annual_er_pct=annual_er_pct,\n        percent_daily_spread_cost=percent_daily_spread_cost,\n        fund_swap_pct=fund_swap_pct,\n        periods_per_year=periods_per_year,\n        multiplicative_constant=multiplicative_constant,\n        additive_constant=additive_constant,\n    )\n\n    # Compute close values\n    mults = changes + 1\n    closes = mults.cumprod()\n\n    # Check for zero value event\n    zero_value_indexes = np.where(closes &lt;= 0)[0]\n    if len(zero_value_indexes):\n        zero_idx = zero_value_indexes[0]\n        closes = np.concatenate((closes[:zero_idx], np.zeros(len(closes[zero_idx:]))))\n\n    # Construct and return final df\n    fund_df = pd.DataFrame({\"Close\": closes, \"Change\": changes})\n    fund_df.index = price_df.index\n    return fund_df\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#simulation-equation","title":"Simulation Equation","text":"<p>The core simulation equation is:</p> <pre><code>simulated_return = (underlying_change * leverage - daily_expenses) * mult_constant + add_constant\n</code></pre> <p>Where: - <code>underlying_change</code>: Daily return of the underlying index - <code>leverage</code>: Leverage ratio (1x, 2x, 3x, -1x, -2x, -3x) - <code>daily_expenses</code>: Expense ratio + swap rate + spread + borrowing costs (LIBOR) - <code>mult_constant</code>: Multiplicative adjustment factor (typically 1.0) - <code>add_constant</code>: Additive adjustment factor (calibrated to real data)</p>"},{"location":"api/services/simulation/fund-simulator/#expense-components","title":"Expense Components","text":""},{"location":"api/services/simulation/fund-simulator/#expense-ratio","title":"Expense Ratio","text":"<p>Annual management fee charged by the fund: - SPY: 0.0945% (very low, index fund) - UPRO: 0.91% (leveraged, higher management) - TQQQ: 0.86% (leveraged)</p>"},{"location":"api/services/simulation/fund-simulator/#swap-rate-overnight-borrowing","title":"Swap Rate (Overnight Borrowing)","text":"<p>Cost to maintain leveraged positions overnight: - Approximated using overnight LIBOR rates - Applied as <code>LIBOR * leverage_factor</code> for leveraged funds - Zero for 1x funds</p>"},{"location":"api/services/simulation/fund-simulator/#spread","title":"Spread","text":"<p>Bid-ask spread and trading friction: - Default: 0.05% (5 basis points) - Higher for less liquid funds</p>"},{"location":"api/services/simulation/fund-simulator/#borrowing-costs","title":"Borrowing Costs","text":"<p>Additional costs for short positions and leverage beyond swap: - Zero for long-only 1x funds - Increases with leverage ratio</p>"},{"location":"api/services/simulation/fund-simulator/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.simulation.fund_simulator import simulate_fund\nfrom finbot.utils.data_collection_utils.yfinance import get_history\n\n# Simulate UPRO (3x leveraged S&amp;P 500)\nupro_sim = simulate_fund('UPRO', start_date='2010-01-01', end_date='2024-01-01')\n\n# Access simulation results\nprint(upro_sim.columns)  # ['Open', 'High', 'Low', 'Close', 'Volume', 'Dividends', 'Stock Splits']\nprint(f\"Total return: {(upro_sim['Close'][-1] / upro_sim['Close'][0] - 1) * 100:.2f}%\")\n\n# Custom parameters\ncustom_sim = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=2.0,\n    expense_ratio=0.01,\n    spread=0.0005,\n    swap_rate_df=libor_data,\n    mult_constant=1.0,\n    add_constant=0.0\n)\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#pre-configured-funds","title":"Pre-configured Funds","text":"<p>Finbot includes pre-configured simulations for 15 popular funds:</p>"},{"location":"api/services/simulation/fund-simulator/#stock-funds","title":"Stock Funds","text":"Fund Underlying Leverage Expense Ratio SPY S&amp;P 500 1x 0.0945% SSO S&amp;P 500 2x 0.91% UPRO S&amp;P 500 3x 0.91% QQQ Nasdaq 100 1x 0.20% QLD Nasdaq 100 2x 0.95% TQQQ Nasdaq 100 3x 0.86%"},{"location":"api/services/simulation/fund-simulator/#bond-funds","title":"Bond Funds","text":"Fund Underlying Leverage Expense Ratio TLT 20Y Treasury 1x 0.15% UBT 20Y Treasury 2x 0.95% TMF 20Y Treasury 3x 1.09% IEF 7-10Y Treasury 1x 0.15% UST 7-10Y Treasury 2x 0.95% TYD 7-10Y Treasury 3x 1.09% SHY 1-3Y Treasury 1x 0.15%"},{"location":"api/services/simulation/fund-simulator/#hybrid-funds","title":"Hybrid Funds","text":"Fund Underlying Composition NTSX 90% S&amp;P 500 + 60% Treasury futures 1.5x effective leverage"},{"location":"api/services/simulation/fund-simulator/#performance","title":"Performance","text":"<p>Based on comprehensive benchmarks:</p> Data Size Time (ms) Throughput (days/sec) 1 month (21 days) 91.67 \u00b1 10.52 ~230 1 year (252 days) 91.83 \u00b1 9.67 ~2,744 5 years (1,260 days) 93.22 \u00b1 9.93 ~13,517 10 years (2,520 days) 95.84 \u00b1 10.64 ~26,289 20 years (5,040 days) 101.80 \u00b1 11.48 ~49,500 40 years (10,080 days) 109.79 \u00b1 12.77 ~91,818 <p>Key Findings: - Sub-linear O(n) scaling: 480x data \u2192 1.2x time - Vectorized NumPy is faster than numba JIT compilation - Processes 40 years of daily data in ~110ms</p>"},{"location":"api/services/simulation/fund-simulator/#tracking-accuracy","title":"Tracking Accuracy","text":"<p>Simulations validate against actual ETF data:</p> Fund Tracking Error Sample Period UPRO 2-4% 2010-2024 TQQQ 3-5% 2010-2024 TMF 2-3% 2010-2024 <p>Tracking error sources: - LIBOR approximation (overnight vs 3-month) - Rebalancing timing differences - Dividend reinvestment assumptions - Intraday volatility (using daily data)</p>"},{"location":"api/services/simulation/fund-simulator/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/services/simulation/fund-simulator/#historical-extension","title":"Historical Extension","text":"<p>Simulate funds before their inception:</p> <pre><code># UPRO launched in 2009, simulate back to 1990\nupro_extended = simulate_fund('UPRO', start_date='1990-01-01', end_date='2024-01-01')\n\n# Compare to actual data\nactual_upro = get_history('UPRO', start='2009-06-25')\nsimulated_overlap = upro_extended.loc['2009-06-25':]\n\n# Calculate tracking error\ntracking_error = (simulated_overlap['Close'] / actual_upro['Close'] - 1).std()\nprint(f\"Tracking error: {tracking_error:.2%}\")\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#custom-fund-creation","title":"Custom Fund Creation","text":"<p>Create hypothetical funds with custom parameters:</p> <pre><code># Hypothetical 5x leveraged S&amp;P 500\nextreme_leverage = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=5.0,\n    expense_ratio=0.015,  # 1.5% expense ratio\n    spread=0.001,  # 10 bps spread\n    swap_rate_df=libor_data,\n    mult_constant=1.0,\n    add_constant=0.0\n)\n\n# Inverse leveraged fund\ninverse_fund = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=-2.0,  # 2x inverse\n    expense_ratio=0.0095,\n    spread=0.0005,\n    swap_rate_df=libor_data\n)\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>Test impact of different expense assumptions:</p> <pre><code>base_sim = simulate_fund('UPRO')\n\n# Higher expenses\nhigh_expense = fund_simulator(\n    price_df=spy_data,\n    leverage_ratio=3.0,\n    expense_ratio=0.02,  # 2% vs 0.91% actual\n    spread=0.001,\n    swap_rate_df=libor_data\n)\n\n# Compare performance\nbase_return = (base_sim['Close'][-1] / base_sim['Close'][0] - 1)\nhigh_expense_return = (high_expense['Close'][-1] / high_expense['Close'][0] - 1)\nexpense_drag = base_return - high_expense_return\nprint(f\"Expense drag: {expense_drag:.2%}\")\n</code></pre>"},{"location":"api/services/simulation/fund-simulator/#data-requirements","title":"Data Requirements","text":""},{"location":"api/services/simulation/fund-simulator/#price-data-format","title":"Price Data Format","text":"<p>Input <code>price_df</code> must be a pandas DataFrame with: - Index: DatetimeIndex (daily frequency) - Columns: <code>Open</code>, <code>High</code>, <code>Low</code>, <code>Close</code>, <code>Volume</code> - Format: Decimal (not percentage) prices</p>"},{"location":"api/services/simulation/fund-simulator/#libor-data-format","title":"LIBOR Data Format","text":"<p>Input <code>swap_rate_df</code> must be a pandas DataFrame with: - Index: DatetimeIndex matching price_df - Column: Interest rates as decimal (0.02 = 2%) - Source: Approximated overnight LIBOR from <code>approximate_overnight_libor()</code></p>"},{"location":"api/services/simulation/fund-simulator/#implementation-details","title":"Implementation Details","text":"<p>The simulator uses: - Vectorized NumPy: All operations vectorized for performance - Daily rebalancing: Leveraged positions rebalanced at close - Compound returns: Accurate multi-day return calculation - Missing data handling: Forward-fill for gaps in LIBOR data</p>"},{"location":"api/services/simulation/fund-simulator/#see-also","title":"See Also","text":"<ul> <li>Specific Funds - Pre-configured fund simulations</li> <li>Bond Ladder - Bond portfolio simulation</li> <li>Monte Carlo - Risk analysis with simulated data</li> <li>Performance Benchmarks - Detailed performance analysis</li> </ul>"},{"location":"api/services/simulation/monte-carlo/","title":"Monte Carlo Simulator","text":"<p>The Monte Carlo simulator generates probabilistic forecasts of portfolio performance using historical return distributions and random sampling.</p>"},{"location":"api/services/simulation/monte-carlo/#overview","title":"Overview","text":"<p>The Monte Carlo simulator:</p> <ul> <li>Generates thousands of possible future return paths</li> <li>Samples from historical return distributions</li> <li>Accounts for portfolio volatility and correlations</li> <li>Provides percentile analysis (5th, 25th, 50th, 75th, 95th)</li> <li>Tests withdrawal sustainability and retirement planning</li> <li>Visualizes probability distributions and confidence bands</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#quick-start","title":"Quick Start","text":"<pre><code>from finbot.services.simulation.monte_carlo.monte_carlo_simulator import monte_carlo_simulator\nimport pandas as pd\n\n# Load historical returns\nspy_returns = pd.read_parquet('spy_prices.parquet')['Close'].pct_change()\n\n# Run Monte Carlo simulation\nresults = monte_carlo_simulator(\n    returns_series=spy_returns,\n    num_trials=10000,\n    num_periods=252 * 30,  # 30 years of daily returns\n    starting_value=100000\n)\n\n# Analyze results\nprint(f\"Median final value: ${results['final_values'].median():,.0f}\")\nprint(f\"5th percentile: ${results['final_values'].quantile(0.05):,.0f}\")\nprint(f\"95th percentile: ${results['final_values'].quantile(0.95):,.0f}\")\n\n# Calculate probability of doubling investment\nprob_double = (results['final_values'] &gt;= 200000).sum() / len(results['final_values'])\nprint(f\"Probability of doubling: {prob_double:.1%}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#api-reference","title":"API Reference","text":""},{"location":"api/services/simulation/monte-carlo/#finbot.services.simulation.monte_carlo.monte_carlo_simulator.monte_carlo_simulator","title":"finbot.services.simulation.monte_carlo.monte_carlo_simulator.monte_carlo_simulator","text":"<pre><code>monte_carlo_simulator(\n    equity_data: DataFrame,\n    equity_start: Timestamp = _DEFAULT_EQUITY_START,\n    equity_end: Timestamp | None = None,\n    sim_periods: int = 252,\n    n_sims: int = 10000,\n    start_price: float | None = None,\n) -&gt; pd.DataFrame\n</code></pre> Source code in <code>finbot/services/simulation/monte_carlo/monte_carlo_simulator.py</code> <pre><code>def monte_carlo_simulator(\n    equity_data: pd.DataFrame,\n    equity_start: pd.Timestamp = _DEFAULT_EQUITY_START,\n    equity_end: pd.Timestamp | None = None,\n    sim_periods: int = 252,\n    n_sims: int = 10000,\n    start_price: float | None = None,\n) -&gt; pd.DataFrame:\n    if equity_end is None:\n        equity_end = pd.Timestamp.now()\n    equity_data = equity_data.truncate(before=equity_start, after=equity_end)\n\n    closes = equity_data[\"Adj Close\" if \"Adj Close\" in equity_data.columns else \"Close\"]\n    changes = closes.pct_change()\n    start_price = (\n        closes.iloc[-(sim_periods if len(closes) &gt;= sim_periods else 1)] if start_price is None else start_price\n    )\n    mu = changes.dropna().mean()\n    sigma = changes.dropna().std()\n\n    trials = np.array(\n        [\n            sim_type_nd(\n                sim_periods=sim_periods,\n                n_sims=n_sims,\n                start_price=start_price,\n                mu=mu,\n                sigma=sigma,\n                cov_matrix=None,\n            )\n            for _ in tqdm(range(n_sims), desc=\"Performing monte carlo simulation\")\n        ]\n    )\n\n    trials_df = pd.DataFrame(trials)\n    trials_df.index.name = \"Trials\"\n    trials_df.columns.name = \"Periods\"\n\n    return trials_df\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#simulation-types","title":"Simulation Types","text":""},{"location":"api/services/simulation/monte-carlo/#normal-distribution","title":"Normal Distribution","text":"<p>Assumes returns follow a normal distribution: - Mean = historical mean return - Std dev = historical volatility - Fastest method, but ignores skewness and kurtosis</p>"},{"location":"api/services/simulation/monte-carlo/#finbot.services.simulation.monte_carlo.sim_types.sim_type_nd","title":"finbot.services.simulation.monte_carlo.sim_types.sim_type_nd","text":"<pre><code>sim_type_nd(**kwargs) -&gt; np.ndarray\n</code></pre> <p>Normal distribution Monte Carlo simulation.</p> Source code in <code>finbot/services/simulation/monte_carlo/sim_types.py</code> <pre><code>def sim_type_nd(**kwargs) -&gt; np.ndarray:\n    \"\"\"Normal distribution Monte Carlo simulation.\"\"\"\n    sim_periods = kwargs[\"sim_periods\"]\n    start_price = kwargs[\"start_price\"]\n    mu = kwargs[\"mu\"]\n    sigma = kwargs[\"sigma\"]\n\n    daily_changes = np.random.normal(loc=mu + 1, scale=sigma, size=sim_periods)\n    daily_changes[0] = 1\n    cum_changes = np.cumprod(daily_changes)\n    price_array = cum_changes * start_price\n    return price_array\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#historical-bootstrap","title":"Historical Bootstrap","text":"<p>Randomly samples actual historical returns: - Preserves real return distribution - Captures fat tails and skewness - Requires sufficient historical data (&gt;1000 observations)</p>"},{"location":"api/services/simulation/monte-carlo/#output-structure","title":"Output Structure","text":"<p>The simulator returns a dictionary containing:</p> <pre><code>{\n    'trials': np.ndarray,  # Shape: (num_trials, num_periods)\n    'final_values': np.ndarray,  # Shape: (num_trials,)\n    'mean_path': np.ndarray,  # Shape: (num_periods,)\n    'percentiles': {\n        5: np.ndarray,  # 5th percentile path\n        25: np.ndarray,  # 25th percentile path\n        50: np.ndarray,  # 50th percentile (median)\n        75: np.ndarray,  # 75th percentile path\n        95: np.ndarray  # 95th percentile path\n    }\n}\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#examples","title":"Examples","text":""},{"location":"api/services/simulation/monte-carlo/#retirement-planning","title":"Retirement Planning","text":"<p>Test 4% withdrawal rule:</p> <pre><code># 60/40 portfolio returns\nportfolio_returns = 0.6 * spy_returns + 0.4 * tlt_returns\n\n# Run simulation with withdrawals\nstarting_value = 1_000_000\nannual_withdrawal = 40_000  # 4% rule\nyears = 30\n\nresults = monte_carlo_simulator(\n    returns_series=portfolio_returns,\n    num_trials=10000,\n    num_periods=252 * years,\n    starting_value=starting_value\n)\n\n# Simulate withdrawals\nwithdrawal_per_day = annual_withdrawal / 252\ntrials_with_withdrawals = results['trials'].copy()\n\nfor i in range(trials_with_withdrawals.shape[1]):\n    trials_with_withdrawals[:, i] -= withdrawal_per_day\n\n# Calculate success rate (portfolio doesn't deplete)\nfinal_values_with_withdrawal = trials_with_withdrawals[:, -1]\nsuccess_rate = (final_values_with_withdrawal &gt; 0).sum() / len(final_values_with_withdrawal)\n\nprint(f\"4% rule success rate: {success_rate:.1%}\")\nprint(f\"Median final value: ${np.median(final_values_with_withdrawal):,.0f}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#value-at-risk-var","title":"Value at Risk (VaR)","text":"<p>Calculate probability of specific losses:</p> <pre><code>results = monte_carlo_simulator(\n    returns_series=portfolio_returns,\n    num_trials=10000,\n    num_periods=252 * 1,  # 1 year\n    starting_value=100000\n)\n\n# Calculate VaR at different confidence levels\nlosses = 100000 - results['final_values']\nvar_95 = np.percentile(losses, 95)\nvar_99 = np.percentile(losses, 99)\n\nprint(f\"VaR (95%): ${var_95:,.0f} maximum loss\")\nprint(f\"VaR (99%): ${var_99:,.0f} maximum loss\")\n\n# Conditional VaR (CVaR / Expected Shortfall)\ncvar_95 = losses[losses &gt;= var_95].mean()\nprint(f\"CVaR (95%): ${cvar_95:,.0f} expected loss if VaR exceeded\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#multi-asset-portfolio","title":"Multi-Asset Portfolio","text":"<p>Simulate correlated assets:</p> <pre><code>import numpy as np\n\n# Calculate correlation matrix\nreturns_df = pd.DataFrame({\n    'SPY': spy_returns,\n    'TLT': tlt_returns,\n    'GLD': gld_returns\n})\ncorrelation_matrix = returns_df.corr()\n\n# Cholesky decomposition for correlated sampling\nL = np.linalg.cholesky(correlation_matrix)\n\n# Generate correlated returns\nnum_trials = 10000\nnum_periods = 252 * 10\n\nuncorrelated_returns = np.random.normal(\n    loc=returns_df.mean().values,\n    scale=returns_df.std().values,\n    size=(num_trials, num_periods, 3)\n)\n\n# Apply correlation\ncorrelated_returns = uncorrelated_returns @ L.T\n\n# Simulate portfolio (equal weight)\nweights = np.array([0.33, 0.33, 0.34])\nportfolio_returns = (correlated_returns * weights).sum(axis=2)\n\n# Calculate final values\ncumulative_returns = (1 + portfolio_returns).cumprod(axis=1)\nfinal_values = 100000 * cumulative_returns[:, -1]\n\nprint(f\"Median final value: ${np.median(final_values):,.0f}\")\nprint(f\"5th percentile: ${np.percentile(final_values, 5):,.0f}\")\nprint(f\"95th percentile: ${np.percentile(final_values, 95):,.0f}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#leveraged-portfolio-risk","title":"Leveraged Portfolio Risk","text":"<p>Analyze risk of leveraged strategies:</p> <pre><code># UPRO (3x leveraged S&amp;P 500) returns\nupro_returns = spy_returns * 3  # Simplified for illustration\n\nresults_spy = monte_carlo_simulator(spy_returns, 10000, 252*10, 100000)\nresults_upro = monte_carlo_simulator(upro_returns, 10000, 252*10, 100000)\n\n# Compare distributions\nprint(\"SPY Simulation:\")\nprint(f\"  Median: ${results_spy['final_values'].median():,.0f}\")\nprint(f\"  5th percentile: ${np.percentile(results_spy['final_values'], 5):,.0f}\")\n\nprint(\"\\nUPRO Simulation:\")\nprint(f\"  Median: ${results_upro['final_values'].median():,.0f}\")\nprint(f\"  5th percentile: ${np.percentile(results_upro['final_values'], 5):,.0f}\")\n\n# Calculate probability of loss\nprob_loss_spy = (results_spy['final_values'] &lt; 100000).sum() / 10000\nprob_loss_upro = (results_upro['final_values'] &lt; 100000).sum() / 10000\n\nprint(f\"\\nProbability of loss after 10 years:\")\nprint(f\"  SPY: {prob_loss_spy:.1%}\")\nprint(f\"  UPRO: {prob_loss_upro:.1%}\")\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#visualization","title":"Visualization","text":""},{"location":"api/services/simulation/monte-carlo/#plot-trials","title":"Plot Trials","text":"<pre><code>from finbot.services.simulation.monte_carlo.visualization import plot_trials\n\nplot_trials(\n    results['trials'],\n    results['percentiles'],\n    title=\"Monte Carlo Simulation: 10,000 Trials\",\n    xlabel=\"Trading Days\",\n    ylabel=\"Portfolio Value ($)\"\n)\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#plot-distribution","title":"Plot Distribution","text":"<pre><code>from finbot.services.simulation.monte_carlo.visualization import plot_distribution\n\nplot_distribution(\n    results['final_values'],\n    title=\"Final Value Distribution After 30 Years\",\n    xlabel=\"Final Portfolio Value ($)\",\n    initial_value=100000\n)\n</code></pre>"},{"location":"api/services/simulation/monte-carlo/#key-assumptions","title":"Key Assumptions","text":""},{"location":"api/services/simulation/monte-carlo/#what-monte-carlo-captures","title":"What Monte Carlo Captures","text":"<ul> <li>Historical return distribution (mean, volatility)</li> <li>Random variation and uncertainty</li> <li>Compound return effects</li> <li>Path-dependent outcomes</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#what-monte-carlo-doesnt-capture","title":"What Monte Carlo Doesn't Capture","text":"<ul> <li>Regime changes: Market conditions may differ from historical</li> <li>Structural breaks: Economic crises not in historical data</li> <li>Fat tails: May underestimate extreme events</li> <li>Time-varying volatility: Assumes constant volatility</li> <li>Mean reversion: Doesn't model market cycles</li> <li>Autocorrelation: Assumes independent returns</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#best-practices","title":"Best Practices","text":"<ol> <li>Use sufficient trials: At least 10,000 for stable percentiles</li> <li>Historical data quality: Minimum 5-10 years of data</li> <li>Include multiple scenarios: Test bull, bear, and sideways markets separately</li> <li>Stress test: Add extreme scenarios not in historical data</li> <li>Validate assumptions: Check if normal distribution is appropriate</li> <li>Combine with fundamentals: Don't rely solely on historical returns</li> <li>Update regularly: Re-run with latest historical data</li> </ol>"},{"location":"api/services/simulation/monte-carlo/#limitations","title":"Limitations","text":"<ul> <li>Backward-looking: Based entirely on past performance</li> <li>Distribution assumptions: Normal distribution may not capture reality</li> <li>Independence assumption: Ignores serial correlation</li> <li>No structural change: Assumes future like past</li> <li>Overfitting risk: Historical period may not be representative</li> </ul>"},{"location":"api/services/simulation/monte-carlo/#see-also","title":"See Also","text":"<ul> <li>Research: Monte Carlo Risk Analysis - Detailed findings</li> <li>Notebook: Monte Carlo Demo - Interactive examples</li> <li>Visualization - Plotting functions</li> <li>DCA Optimizer - Complementary optimization approach</li> </ul>"},{"location":"api/utils/finance-utils/","title":"Finance Utilities","text":"<p>The <code>finance_utils</code> module provides 19 financial calculation and analysis functions for returns, drawdowns, time series statistics, and economic data.</p>"},{"location":"api/utils/finance-utils/#overview","title":"Overview","text":"<p>Key capabilities:</p> <ul> <li>Returns Calculation: Compound growth rate (CGR), percentage change</li> <li>Risk Metrics: Drawdown analysis, volatility, time series statistics</li> <li>Time Period Analysis: Detect data frequency, calculate periods per year</li> <li>Price Adjustments: Inflation adjustment, merge overlapping price series</li> <li>Economic Cycles: US GDP recession dates and classifications</li> <li>Trend Analysis: Bull/bear/sideways market classification</li> </ul>"},{"location":"api/utils/finance-utils/#quick-reference","title":"Quick Reference","text":"Function Purpose Location <code>get_cgr</code> Compound growth rate (CAGR) <code>finbot.utils.finance_utils.get_cgr</code> <code>get_pct_change</code> Percentage change between values <code>finbot.utils.finance_utils.get_pct_change</code> <code>get_drawdown</code> Calculate drawdown from price series <code>finbot.utils.finance_utils.get_drawdown</code> <code>get_periods_per_year</code> Detect data frequency (daily, weekly, monthly) <code>finbot.utils.finance_utils.get_periods_per_year</code> <code>get_risk_free_rate</code> Fetch current risk-free rate from FRED <code>finbot.utils.finance_utils.get_risk_free_rate</code> <code>merge_price_histories</code> Merge overlapping price series <code>finbot.utils.finance_utils.merge_price_histories</code> <code>get_timeseries_stats</code> Comprehensive statistics (mean, std, Sharpe, etc.) <code>finbot.utils.finance_utils.get_timeseries_stats</code> <code>get_theta_decay</code> Calculate leveraged ETF decay <code>finbot.utils.finance_utils.get_theta_decay</code> <code>get_inflation_adjusted_value</code> Adjust for CPI inflation <code>finbot.utils.finance_utils.get_inflation_adjusted_value</code> <code>get_price_trend_classifications</code> Classify bull/bear/sideways periods <code>finbot.utils.finance_utils.get_price_trend_classifications</code>"},{"location":"api/utils/finance-utils/#core-functions","title":"Core Functions","text":""},{"location":"api/utils/finance-utils/#get_cgr","title":"get_cgr","text":"<p>Calculate compound annual growth rate.</p> <p>Location: <code>finbot.utils.finance_utils.get_cgr</code></p> <pre><code>def get_cgr(\n    initial_value: float,\n    final_value: float,\n    years: float\n) -&gt; float\n</code></pre> <p>Parameters: - <code>initial_value</code> (float): Starting value - <code>final_value</code> (float): Ending value - <code>years</code> (float): Time period in years</p> <p>Returns: Compound annual growth rate as decimal (0.10 = 10%)</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_cgr import get_cgr\n\n# Calculate CAGR for 5-year investment\ninitial_value = 100000\nfinal_value = 150000\nyears = 5\n\ncagr = get_cgr(initial_value, final_value, years)\nprint(f\"CAGR: {cagr:.2%}\")  # Output: CAGR: 8.45%\n</code></pre>"},{"location":"api/utils/finance-utils/#get_drawdown","title":"get_drawdown","text":"<p>Calculate drawdown from peak.</p> <p>Location: <code>finbot.utils.finance_utils.get_drawdown</code></p> <pre><code>def get_drawdown(prices: pd.Series) -&gt; pd.Series\n</code></pre> <p>Parameters: - <code>prices</code> (pd.Series): Price series with DatetimeIndex</p> <p>Returns: Series of drawdown percentages (negative values)</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_drawdown import get_drawdown\nimport pandas as pd\n\n# Load price history\nprices = pd.read_parquet('spy_prices.parquet')['Close']\n\n# Calculate drawdown\ndrawdown = get_drawdown(prices)\n\n# Analyze\nmax_dd = drawdown.min()\nprint(f\"Maximum drawdown: {max_dd:.2%}\")\n\n# Find max drawdown date\nmax_dd_date = drawdown.idxmin()\nprint(f\"Occurred on: {max_dd_date}\")\n</code></pre>"},{"location":"api/utils/finance-utils/#get_periods_per_year","title":"get_periods_per_year","text":"<p>Detect data frequency.</p> <p>Location: <code>finbot.utils.finance_utils.get_periods_per_year</code></p> <pre><code>def get_periods_per_year(data: pd.Series | pd.DataFrame) -&gt; int\n</code></pre> <p>Parameters: - <code>data</code> (pd.Series | pd.DataFrame): Time series data with DatetimeIndex</p> <p>Returns: Number of periods per year (252 for daily, 52 for weekly, 12 for monthly)</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_periods_per_year import get_periods_per_year\n\n# Detect frequency of price data\nperiods = get_periods_per_year(daily_prices)\nprint(f\"Periods per year: {periods}\")  # Output: 252 (trading days)\n\n# Use for annualization\ndaily_returns = daily_prices.pct_change()\nannual_volatility = daily_returns.std() * np.sqrt(periods)\n</code></pre>"},{"location":"api/utils/finance-utils/#merge_price_histories","title":"merge_price_histories","text":"<p>Merge overlapping price series with priority control.</p> <p>Location: <code>finbot.utils.finance_utils.merge_price_histories</code></p> <pre><code>def merge_price_histories(\n    df1: pd.DataFrame,\n    df2: pd.DataFrame,\n    priority: str = 'second'\n) -&gt; pd.DataFrame\n</code></pre> <p>Parameters: - <code>df1</code> (pd.DataFrame): First price DataFrame - <code>df2</code> (pd.DataFrame): Second price DataFrame - <code>priority</code> (str): Which DataFrame takes precedence ('first' or 'second')</p> <p>Returns: Merged DataFrame with overlapping dates resolved by priority</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.merge_price_histories import merge_price_histories\n\n# Merge simulated pre-inception data with actual ETF data\nsimulated = simulate_fund('UPRO', start='1990-01-01', end='2009-06-24')\nactual = get_history('UPRO', start='2009-06-25')\n\n# Merge with priority to actual data\nmerged = merge_price_histories(simulated, actual, priority='second')\n\n# Result: 1990-2009 from simulation, 2009+ from actual\n</code></pre>"},{"location":"api/utils/finance-utils/#get_risk_free_rate","title":"get_risk_free_rate","text":"<p>Fetch current risk-free rate from FRED.</p> <p>Location: <code>finbot.utils.finance_utils.get_risk_free_rate</code></p> <pre><code>def get_risk_free_rate(fallback: float = 0.02) -&gt; float\n</code></pre> <p>Parameters: - <code>fallback</code> (float, optional): Fallback rate if FRED unavailable (default: 0.02)</p> <p>Returns: Risk-free rate as decimal</p> <p>Example:</p> <pre><code>from finbot.utils.finance_utils.get_risk_free_rate import get_risk_free_rate\n\n# Get latest 3-month T-bill rate from FRED\nrf_rate = get_risk_free_rate()\nprint(f\"Risk-free rate: {rf_rate:.2%}\")\n\n# Use in Sharpe ratio calculation\nsharpe = (portfolio_return - rf_rate) / portfolio_std\n</code></pre>"},{"location":"api/utils/finance-utils/#complete-function-list","title":"Complete Function List","text":""},{"location":"api/utils/finance-utils/#returns-and-growth","title":"Returns and Growth","text":"<ul> <li><code>get_cgr</code>: Compound growth rate</li> <li><code>get_pct_change</code>: Percentage change</li> <li><code>get_open_close_percent_change</code>: Open-to-close change</li> </ul>"},{"location":"api/utils/finance-utils/#risk-metrics","title":"Risk Metrics","text":"<ul> <li><code>get_drawdown</code>: Drawdown from peak</li> <li><code>get_theta_decay</code>: Leveraged ETF decay</li> <li><code>get_timeseries_stats</code>: Comprehensive statistics</li> </ul>"},{"location":"api/utils/finance-utils/#time-and-frequency","title":"Time and Frequency","text":"<ul> <li><code>get_periods_per_year</code>: Detect data frequency</li> <li><code>get_investment_event_horizon</code>: Calculate holding period</li> </ul>"},{"location":"api/utils/finance-utils/#price-operations","title":"Price Operations","text":"<ul> <li><code>merge_price_histories</code>: Merge overlapping series</li> <li><code>get_inflation_adjusted_value</code>: CPI adjustment</li> <li><code>get_series_adjusted_for_inflation</code>: Series-wide inflation adjustment</li> </ul>"},{"location":"api/utils/finance-utils/#market-analysis","title":"Market Analysis","text":"<ul> <li><code>get_price_trend_classifications</code>: Bull/bear/sideways classification</li> <li><code>get_us_gdp_recession_dates</code>: Recession periods</li> <li><code>get_us_gdp_non_recession_dates</code>: Expansion periods</li> <li><code>get_us_gdp_cycle_dates</code>: Full cycle dates</li> <li><code>get_us_gdp_recessions_bools</code>: Boolean recession indicators</li> </ul>"},{"location":"api/utils/finance-utils/#data-and-utilities","title":"Data and Utilities","text":"<ul> <li><code>get_risk_free_rate</code>: Fetch from FRED</li> <li><code>get_mult_from_suffix</code>: Parse K/M/B/T multipliers</li> <li><code>get_number_from_suffix</code>: Convert formatted strings to numbers</li> </ul>"},{"location":"api/utils/finance-utils/#see-also","title":"See Also","text":"<ul> <li>Datetime Utilities - Time period calculations</li> <li>Pandas Utilities - DataFrame operations</li> <li>Data Science Utilities - Statistical analysis</li> </ul>"},{"location":"research/","title":"Research Documentation","text":"<p>This section contains research findings and analysis from Finbot simulations and backtests.</p>"},{"location":"research/#published-research","title":"Published Research","text":""},{"location":"research/#leveraged-etf-simulation-accuracy","title":"Leveraged ETF Simulation Accuracy","text":"<p>Analysis of how well the fund simulator tracks real ETF returns.</p> <p>Key Findings: - 2-5% tracking error for leveraged funds - Suitable for historical backtesting and extension - LIBOR approximation accounts for ~1% of error</p> <p>Read Full Report</p>"},{"location":"research/#dca-optimization-findings","title":"DCA Optimization Findings","text":"<p>Optimal dollar-cost averaging strategies across multiple portfolios.</p> <p>Key Findings: - 60/40 SPY/TLT validated for non-leveraged portfolios - 45/55 UPRO/TMF optimal for leveraged portfolios - 5-year DCA duration balances risk and return</p> <p>Read Full Report</p>"},{"location":"research/#strategy-backtest-results","title":"Strategy Backtest Results","text":"<p>Comparison of 10 trading strategies on S&amp;P 500 data.</p> <p>Key Findings: - Rebalancing outperforms buy-and-hold for multi-asset portfolios - SMA crossovers effective in trending markets - Transaction costs matter for frequent-trading strategies</p> <p>Read Full Report</p>"},{"location":"research/#research-notebooks","title":"Research Notebooks","text":"<p>Interactive Jupyter notebooks with full analysis:</p> <ol> <li>Fund Simulation Demo</li> <li>DCA Optimization Results</li> <li>Backtest Strategy Comparison</li> <li>Monte Carlo Risk Analysis</li> <li>Bond Ladder Analysis</li> </ol>"},{"location":"research/#methodology","title":"Methodology","text":"<p>All research uses: - Historical data from Yahoo Finance and FRED - Simulated data from Finbot's fund simulator - Backtrader-based backtesting engine - Quantstats for performance metrics</p>"},{"location":"research/#limitations","title":"Limitations","text":"<ul> <li>Historical data (past performance \u2260 future results)</li> <li>Simulation assumptions (constant expense ratios, LIBOR approximation)</li> <li>No transaction costs in some analyses</li> <li>Survivorship bias (analyzing successful ETFs)</li> </ul>"},{"location":"research/#citation","title":"Citation","text":"<p>If you use Finbot's research in academic work:</p> <pre><code>@software{finbot2026,\n  author = {Dawson, Jeremy},\n  title = {Finbot: Financial Simulation and Backtesting Platform},\n  year = {2026},\n  url = {https://github.com/jerdaw/finbot}\n}\n</code></pre>"},{"location":"user-guide/cli-reference/","title":"CLI Reference","text":"<p>Complete command-line interface documentation for Finbot.</p>"},{"location":"user-guide/cli-reference/#global-options","title":"Global Options","text":"<pre><code>finbot [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Global Options: - <code>--version</code>: Show version and exit - <code>--verbose</code>, <code>-v</code>: Enable verbose output - <code>--help</code>: Show help message</p>"},{"location":"user-guide/cli-reference/#commands","title":"Commands","text":""},{"location":"user-guide/cli-reference/#finbot-simulate","title":"finbot simulate","text":"<p>Simulate leveraged funds:</p> <pre><code>finbot simulate --fund FUND_TICKER [OPTIONS]\n</code></pre> <p>Required: - <code>--fund TEXT</code>: Fund ticker (SPY, UPRO, TQQQ, etc.)</p> <p>Optional: - <code>--start TEXT</code>: Start date (YYYY-MM-DD) - <code>--end TEXT</code>: End date (YYYY-MM-DD) - <code>--output PATH</code>: Save results (CSV, parquet, JSON) - <code>--plot</code>: Show interactive plot</p> <p>Examples:</p> <pre><code># Basic simulation\nfinbot simulate --fund UPRO\n\n# Historical extension\nfinbot simulate --fund TQQQ --start 1990-01-01 --end 2024-01-01\n\n# Save and plot\nfinbot simulate --fund TMF --output results/tmf.parquet --plot\n</code></pre>"},{"location":"user-guide/cli-reference/#finbot-backtest","title":"finbot backtest","text":"<p>Run strategy backtests:</p> <pre><code>finbot backtest --strategy STRATEGY --asset ASSETS [OPTIONS]\n</code></pre> <p>Required: - <code>--strategy TEXT</code>: Strategy name (Rebalance, SMACrossover, etc.) - <code>--asset TEXT</code>: Comma-separated tickers (SPY,TLT)</p> <p>Optional: - <code>--start TEXT</code>: Start date - <code>--end TEXT</code>: End date - <code>--cash FLOAT</code>: Starting cash (default: 100000) - <code>--commission FLOAT</code>: Commission rate (default: 0.001) - <code>--output PATH</code>: Save results - <code>--plot</code>: Show portfolio value chart</p> <p>Examples:</p> <pre><code># 60/40 portfolio\nfinbot backtest --strategy Rebalance --asset SPY,TLT\n\n# Custom parameters\nfinbot backtest --strategy SMACrossover --asset QQQ \\\n  --start 2010-01-01 --cash 50000 --commission 0.0005 --plot\n</code></pre>"},{"location":"user-guide/cli-reference/#finbot-optimize","title":"finbot optimize","text":"<p>Portfolio optimization:</p> <pre><code>finbot optimize --method METHOD --assets ASSETS [OPTIONS]\n</code></pre> <p>Required: - <code>--method TEXT</code>: Optimization method (dca) - <code>--assets TEXT</code>: Comma-separated tickers</p> <p>Optional: - <code>--duration INTEGER</code>: DCA duration in days - <code>--interval INTEGER</code>: Purchase interval in days - <code>--ratios TEXT</code>: Ratio range (start,stop,num) - <code>--output PATH</code>: Save results - <code>--plot</code>: Show optimization charts</p> <p>Examples:</p> <pre><code># Default optimization\nfinbot optimize --method dca --assets SPY,TLT\n\n# Custom parameters\nfinbot optimize --method dca --assets UPRO,TMF \\\n  --duration 1095 --interval 30 --ratios 0.3,0.7,9 --plot\n</code></pre>"},{"location":"user-guide/cli-reference/#finbot-update","title":"finbot update","text":"<p>Update all data:</p> <pre><code>finbot update [OPTIONS]\n</code></pre> <p>Optional: - <code>--dry-run</code>: Show what would be updated - <code>--skip-prices</code>: Skip price history updates - <code>--skip-simulations</code>: Skip simulation updates</p> <p>Examples:</p> <pre><code># Full update\nfinbot update\n\n# Dry run (no changes)\nfinbot update --dry-run\n\n# Update prices only\nfinbot update --skip-simulations\n</code></pre>"},{"location":"user-guide/cli-reference/#output-formats","title":"Output Formats","text":"<p>Specify output format via file extension:</p> <ul> <li><code>.csv</code>: Comma-separated values</li> <li><code>.parquet</code>: Apache Parquet (recommended)</li> <li><code>.json</code>: JSON format</li> </ul>"},{"location":"user-guide/cli-reference/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Installation and setup</li> <li>Configuration - Advanced settings</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Advanced configuration options for Finbot.</p>"},{"location":"user-guide/configuration/#configuration-system","title":"Configuration System","text":"<p>Finbot uses Dynaconf for environment-aware configuration. Settings are loaded from YAML files based on the <code>DYNACONF_ENV</code> environment variable.</p>"},{"location":"user-guide/configuration/#configuration-files","title":"Configuration Files","text":"<p>Located in <code>config/</code> directory:</p> <ul> <li><code>settings.yaml</code>: Base settings (all environments)</li> <li><code>development.yaml</code>: Development overrides</li> <li><code>production.yaml</code>: Production overrides</li> <li><code>.env</code>: Environment variables (gitignored)</li> </ul>"},{"location":"user-guide/configuration/#environment-selection","title":"Environment Selection","text":"<pre><code># Development (default)\nexport DYNACONF_ENV=development\n\n# Production\nexport DYNACONF_ENV=production\n</code></pre>"},{"location":"user-guide/configuration/#common-settings","title":"Common Settings","text":""},{"location":"user-guide/configuration/#threading","title":"Threading","text":"<pre><code># config/development.yaml\nthreading:\n  min_threads: 1\n  max_threads: null  # Auto-detect\n  reserved_threads: 2  # Leave 2 cores for system\n</code></pre>"},{"location":"user-guide/configuration/#logging","title":"Logging","text":"<pre><code>logging:\n  level: INFO  # DEBUG, INFO, WARNING, ERROR\n  json_output: true\n  file_rotation_mb: 5\n  file_backup_count: 3\n</code></pre>"},{"location":"user-guide/configuration/#api-keys","title":"API Keys","text":"<p>Store API keys in <code>config/.env</code>:</p> <pre><code># config/.env\nALPHA_VANTAGE_API_KEY=your_key_here\nNASDAQ_DATA_LINK_API_KEY=your_key_here\nUS_BUREAU_OF_LABOR_STATISTICS_API_KEY=your_key_here\nGOOGLE_FINANCE_SERVICE_ACCOUNT_CREDENTIALS_PATH=/path/to/creds.json\n</code></pre> <p>Keys are loaded lazily (only when needed).</p>"},{"location":"user-guide/configuration/#python-api","title":"Python API","text":"<p>Access settings in code:</p> <pre><code>from config import settings, settings_accessors\n\n# Get threading config\nmax_threads = settings_accessors.MAX_THREADS\n\n# Get API key (raises OSError if not set)\napi_key = settings_accessors.get_alpha_vantage_api_key()\n\n# Access any setting\nlog_level = settings.logging.level\n</code></pre>"},{"location":"user-guide/configuration/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic setup</li> <li>config Module - Configuration API reference</li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with Finbot for financial simulation, backtesting, and portfolio optimization.</p>"},{"location":"user-guide/getting-started/#what-is-finbot","title":"What is Finbot?","text":"<p>Finbot is a comprehensive platform for:</p> <ul> <li>Data Collection: Automated fetching from 6+ data sources</li> <li>Simulation: Model leveraged ETFs, bond ladders, and Monte Carlo scenarios</li> <li>Backtesting: Test 10 trading strategies with detailed performance metrics</li> <li>Optimization: Find optimal portfolios using DCA and rebalancing strategies</li> </ul>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":""},{"location":"user-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python &gt;=3.11, &lt;3.15</li> <li>uv (recommended) or pip</li> <li>Optional: API keys for data sources</li> </ul>"},{"location":"user-guide/getting-started/#install-with-uv-recommended","title":"Install with uv (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install dependencies\nuv sync\n\n# Activate virtual environment (optional, uv creates .venv automatically)\nsource .venv/bin/activate  # On Linux/Mac\n.venv\\Scripts\\activate     # On Windows\n\n# Set environment (development or production)\nexport DYNACONF_ENV=development\n\n# Verify installation\nfinbot --version\n</code></pre>"},{"location":"user-guide/getting-started/#install-with-pip","title":"Install with pip","text":"<pre><code># Clone the repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in editable mode\npip install -e .\n\n# Verify installation\nfinbot --version\n</code></pre>"},{"location":"user-guide/getting-started/#configuration","title":"Configuration","text":""},{"location":"user-guide/getting-started/#environment-setup","title":"Environment Setup","text":"<p>Finbot uses Dynaconf for environment-aware configuration. Create a <code>.env</code> file in the <code>config/</code> directory:</p> <pre><code># config/.env\nDYNACONF_ENV=development\n\n# Optional: API keys for data collection\nALPHA_VANTAGE_API_KEY=your_key_here\nNASDAQ_DATA_LINK_API_KEY=your_key_here\nUS_BUREAU_OF_LABOR_STATISTICS_API_KEY=your_key_here\nGOOGLE_FINANCE_SERVICE_ACCOUNT_CREDENTIALS_PATH=/path/to/credentials.json\n</code></pre>"},{"location":"user-guide/getting-started/#configuration-files","title":"Configuration Files","text":"<p>Finbot loads settings from YAML files based on <code>DYNACONF_ENV</code>:</p> <ul> <li><code>config/settings.yaml</code>: Base settings (shared across all environments)</li> <li><code>config/development.yaml</code>: Development-specific settings</li> <li><code>config/production.yaml</code>: Production-specific settings</li> </ul> <p>Example development configuration:</p> <pre><code># config/development.yaml\nthreading:\n  min_threads: 1\n  max_threads: null  # Auto-detect CPU cores\n  reserved_threads: 2  # Reserve 2 cores for system\n\nlogging:\n  level: INFO\n  json_output: true\n</code></pre>"},{"location":"user-guide/getting-started/#first-steps","title":"First Steps","text":""},{"location":"user-guide/getting-started/#1-run-tests","title":"1. Run Tests","text":"<p>Verify your installation by running the test suite:</p> <pre><code># Run all tests\nuv run pytest\n\n# Run with verbose output\nuv run pytest -v\n\n# Run specific test file\nuv run pytest tests/unit/test_imports.py\n</code></pre> <p>Expected output: <code>80 passed</code> (all tests should pass)</p>"},{"location":"user-guide/getting-started/#2-update-data","title":"2. Update Data","text":"<p>Fetch the latest data from all sources:</p> <pre><code># Run full update (requires API keys)\nfinbot update\n\n# Dry run (shows what would be updated)\nfinbot update --dry-run\n\n# Skip price updates\nfinbot update --skip-prices\n\n# Skip simulations\nfinbot update --skip-simulations\n</code></pre> <p>This will: - Fetch Yahoo Finance and Google Finance price histories - Update FRED economic data - Download Shiller datasets - Re-run overnight LIBOR approximation - Regenerate all index and fund simulations</p>"},{"location":"user-guide/getting-started/#3-run-your-first-simulation","title":"3. Run Your First Simulation","text":"<p>Simulate a leveraged fund:</p> <pre><code># Simulate UPRO (3x leveraged S&amp;P 500)\nfinbot simulate --fund UPRO --start 2010-01-01 --plot\n\n# Save results to file\nfinbot simulate --fund UPRO --start 2010-01-01 --output results/upro_sim.parquet\n\n# See all available funds\nfinbot simulate --help\n</code></pre> <p>Available funds: SPY, SSO, UPRO, QQQ, QLD, TQQQ, TLT, UBT, TMF, IEF, UST, TYD, SHY, NTSX</p>"},{"location":"user-guide/getting-started/#4-run-your-first-backtest","title":"4. Run Your First Backtest","text":"<p>Test a trading strategy:</p> <pre><code># Backtest rebalancing strategy on 60/40 portfolio\nfinbot backtest --strategy Rebalance --asset SPY,TLT --plot\n\n# Backtest with custom parameters\nfinbot backtest --strategy Rebalance --asset SPY,TLT \\\n  --cash 100000 --commission 0.001 --output results/backtest.csv\n\n# See all available strategies\nfinbot backtest --help\n</code></pre> <p>Available strategies: Rebalance, NoRebalance, SMACrossover, SMACrossoverDouble, SMACrossoverTriple, MACDSingle, MACDDual, DipBuySMA, DipBuyStdev, SMARebalMix</p>"},{"location":"user-guide/getting-started/#5-optimize-a-portfolio","title":"5. Optimize a Portfolio","text":"<p>Find optimal asset allocation:</p> <pre><code># Optimize SPY/TLT allocation with DCA strategy\nfinbot optimize --method dca --assets SPY,TLT --plot\n\n# Custom optimization parameters\nfinbot optimize --method dca --assets SPY,TLT \\\n  --duration 1825 --interval 30 --ratios 0.5,0.95,10 \\\n  --output results/optimization.parquet\n</code></pre>"},{"location":"user-guide/getting-started/#python-api-usage","title":"Python API Usage","text":""},{"location":"user-guide/getting-started/#simulate-a-fund","title":"Simulate a Fund","text":"<pre><code>from finbot.services.simulation.fund_simulator import simulate_fund\n\n# Simulate TQQQ (3x leveraged Nasdaq 100)\ntqqq_sim = simulate_fund('TQQQ', start_date='2010-02-11', end_date='2024-01-01')\n\n# Access results\nprint(tqqq_sim.head())\nprint(f\"Total return: {(tqqq_sim['Close'][-1] / tqqq_sim['Close'][0] - 1) * 100:.2f}%\")\n</code></pre>"},{"location":"user-guide/getting-started/#run-a-backtest","title":"Run a Backtest","text":"<pre><code>from finbot.services.backtesting.backtest_runner import BacktestRunner\nfrom finbot.utils.data_collection_utils.yfinance import get_history\n\n# Load data\nspy = get_history('SPY', start='2010-01-01')\ntlt = get_history('TLT', start='2010-01-01')\n\n# Create backtest runner\nrunner = BacktestRunner(\n    strategy='Rebalance',\n    data_feeds={'SPY': spy, 'TLT': tlt},\n    strategy_params={'rebalance_days': 30, 'target_allocations': {'SPY': 0.6, 'TLT': 0.4}},\n    cash=100000,\n    commission=0.001\n)\n\n# Run backtest\nresults = runner.run()\nstats = runner.get_stats()\n\nprint(f\"CAGR: {stats['CAGR']:.2%}\")\nprint(f\"Sharpe: {stats['Sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['Max Drawdown']:.2%}\")\n</code></pre>"},{"location":"user-guide/getting-started/#optimize-dca-strategy","title":"Optimize DCA Strategy","text":"<pre><code>from finbot.services.optimization.dca_optimizer import dca_optimizer\nimport pandas as pd\n\n# Load and merge price data\nspy = get_history('SPY')['Close']\ntlt = get_history('TLT')['Close']\ncombined = pd.DataFrame({'SPY': spy, 'TLT': tlt}).dropna()\n\n# Run optimizer\nresults = dca_optimizer(\n    price_history=combined,\n    ratio_linspace=(0.50, 0.95, 10),\n    dca_duration_days=365 * 5,\n    dca_step_days=30,\n    trial_duration_days=365 * 10,\n    starting_cash=100000\n)\n\n# View best allocation\nprint(results.head())\nprint(f\"Optimal: {results.iloc[0]['ratio']:.0%} SPY / {1-results.iloc[0]['ratio']:.0%} TLT\")\nprint(f\"Expected Sharpe: {results.iloc[0]['sharpe']:.2f}\")\n</code></pre>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide: Detailed walkthrough of common tasks</li> <li>CLI Reference: Complete command-line interface documentation</li> <li>API Reference: Detailed API documentation for all modules</li> <li>Configuration Guide: Advanced configuration options</li> <li>Example Notebooks: Jupyter notebooks with analysis examples</li> </ul>"},{"location":"user-guide/getting-started/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/getting-started/#import-errors","title":"Import Errors","text":"<p>If you see import errors, ensure you've installed all dependencies:</p> <pre><code>uv sync\n# or\npip install -e .\n</code></pre>"},{"location":"user-guide/getting-started/#api-key-errors","title":"API Key Errors","text":"<p>If data collection fails with \"OSError: API key not found\":</p> <ol> <li>Create <code>config/.env</code> file</li> <li>Add the relevant API key (see Configuration section)</li> <li>Restart your shell / reload environment</li> </ol>"},{"location":"user-guide/getting-started/#no-data-available","title":"No Data Available","text":"<p>If simulations fail with \"no data available\":</p> <ol> <li>Run <code>finbot update</code> to fetch data</li> <li>Check that <code>finbot/data/</code> subdirectories are populated</li> <li>Verify API keys are configured correctly</li> </ol>"},{"location":"user-guide/getting-started/#permission-errors","title":"Permission Errors","text":"<p>If you see permission errors on <code>finbot/data/</code> directories:</p> <pre><code># Linux/Mac\nchmod -R 755 finbot/data\n\n# Windows (run as administrator)\nicacls finbot\\data /grant Users:F /t\n</code></pre>"},{"location":"user-guide/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Full API Reference</li> <li>Issues: GitHub Issues</li> <li>Examples: Jupyter Notebooks</li> <li>Research: Published Findings</li> </ul>"},{"location":"user-guide/getting-started/#development-setup","title":"Development Setup","text":"<p>If you plan to contribute:</p> <pre><code># Install dev dependencies\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n\n# Run code quality checks\nmake check  # Runs lint, format, type, security\n\n# Run tests with coverage\nmake test-cov\n</code></pre> <p>See Contributing Guide for details.</p>"},{"location":"user-guide/health-economics-tutorial/","title":"Health Economics Tutorial","text":"<p>Audience: Clinicians, health policymakers, researchers Prerequisites: Basic Python, understanding of QALYs and cost-effectiveness Time: 30-45 minutes Goal: Learn to perform cost-effectiveness analysis using Finbot's health economics toolkit</p>"},{"location":"user-guide/health-economics-tutorial/#introduction","title":"Introduction","text":"<p>This tutorial walks through a realistic health economics analysis: comparing treatment options for patients with newly diagnosed Type 2 diabetes. By the end, you'll be able to:</p> <ul> <li>Model health interventions using Monte Carlo simulation</li> <li>Calculate standard cost-effectiveness metrics (ICER, NMB, CEAC)</li> <li>Interpret results against international thresholds (NICE, CADTH, WHO, US)</li> <li>Make evidence-based formulary and clinical decisions</li> </ul> <p>Real-world application: This analysis mirrors decisions made daily by: - NICE (UK): Appraising new diabetes drugs for NHS formulary - CADTH (Canada): Reviewing for provincial drug coverage - US Payers: Making formulary tier decisions (preferred vs. non-preferred) - Clinicians: Choosing between metformin and newer GLP-1 agonists</p>"},{"location":"user-guide/health-economics-tutorial/#clinical-scenario","title":"Clinical Scenario","text":"<p>Patient Population: Adults aged 45-65 with newly diagnosed Type 2 diabetes (HbA1c 7.5-9%)</p> <p>Treatment Options: 1. Metformin (standard of care): Generic, $500/year, modest efficacy 2. GLP-1 Receptor Agonist (newer option): Branded, $10,000/year, greater efficacy</p> <p>Clinical Question: Is the higher cost of GLP-1 agonists justified by improved health outcomes?</p> <p>Decision Framework: Use cost-effectiveness analysis to balance costs against health benefits (measured in QALYs).</p>"},{"location":"user-guide/health-economics-tutorial/#step-1-define-interventions","title":"Step 1: Define Interventions","text":"<p>First, we define each treatment's parameters based on clinical trial data.</p> <pre><code>from finbot.services.health_economics.qaly_simulator import HealthIntervention\n\n# Metformin (standard of care)\nmetformin = HealthIntervention(\n    name='Metformin',\n    cost_per_year=500.0,           # Generic pricing\n    cost_std=100.0,                # Cost uncertainty\n    utility_gain=0.08,              # Quality of life improvement (0-1 scale)\n    utility_gain_std=0.02,         # Utility uncertainty\n    mortality_reduction=0.003,      # Annual mortality reduction (3 per 1000)\n    mortality_reduction_std=0.001, # Mortality uncertainty\n)\n\n# GLP-1 agonist (e.g., semaglutide, liraglutide)\nglp1 = HealthIntervention(\n    name='GLP-1 Agonist',\n    cost_per_year=10_000.0,        # Branded pricing\n    cost_std=1_500.0,\n    utility_gain=0.15,              # Greater QoL (HbA1c control + weight loss)\n    utility_gain_std=0.03,\n    mortality_reduction=0.008,      # Proven CV mortality reduction\n    mortality_reduction_std=0.002,\n)\n</code></pre> <p>Parameter sources: - Costs: AWP (Average Wholesale Price) databases - Utility gains: EQ-5D or SF-6D quality-of-life instruments from trials - Mortality: Hazard ratios from cardiovascular outcomes trials (SUSTAIN, LEADER)</p> <p>Uncertainty: Standard deviations capture parameter uncertainty from clinical trials.</p>"},{"location":"user-guide/health-economics-tutorial/#step-2-run-monte-carlo-simulations","title":"Step 2: Run Monte Carlo Simulations","text":"<p>Monte Carlo simulation generates distributions of outcomes, not just point estimates.</p> <pre><code>from finbot.services.health_economics.qaly_simulator import simulate_qalys\n\n# Baseline for newly diagnosed T2D patients\nbaseline_utility = 0.65      # Uncontrolled diabetes quality of life\nbaseline_mortality = 0.04    # 4%/year CV mortality risk\ntime_horizon = 15            # 15 years (until age 60-80)\n\n# Run 10,000 Monte Carlo trials for each intervention\nsim_metformin = simulate_qalys(\n    metformin,\n    baseline_utility=baseline_utility,\n    baseline_mortality=baseline_mortality,\n    time_horizon=time_horizon,\n    n_sims=10_000,\n    discount_rate=0.03,  # 3% per WHO/NICE guidelines\n    seed=42,\n)\n\nsim_glp1 = simulate_qalys(\n    glp1,\n    baseline_utility=baseline_utility,\n    baseline_mortality=baseline_mortality,\n    time_horizon=time_horizon,\n    n_sims=10_000,\n    discount_rate=0.03,\n    seed=42,\n)\n\n# View mean results\nprint(f'Metformin:     {sim_metformin[\"mean_qaly\"]:.2f} QALYs, ${sim_metformin[\"mean_cost\"]:,.0f}')\nprint(f'GLP-1 Agonist: {sim_glp1[\"mean_qaly\"]:.2f} QALYs, ${sim_glp1[\"mean_cost\"]:,.0f}')\n</code></pre> <p>Example Output: <pre><code>Metformin:     9.23 QALYs, $3,876\nGLP-1 Agonist: 10.71 QALYs, $78,245\n</code></pre></p> <p>Interpretation: - Metformin provides 9.23 discounted QALYs over 15 years at low cost - GLP-1 provides 1.48 more QALYs but costs $74,369 more - Is this trade-off worthwhile?</p>"},{"location":"user-guide/health-economics-tutorial/#step-3-calculate-cost-effectiveness-metrics","title":"Step 3: Calculate Cost-Effectiveness Metrics","text":"<p>Now we compare the interventions using standard health economics metrics.</p> <pre><code>from finbot.services.health_economics.cost_effectiveness import cost_effectiveness_analysis\n\n# Run cost-effectiveness analysis\ncea = cost_effectiveness_analysis(\n    sim_results={'GLP-1 Agonist': sim_glp1, 'Metformin': sim_metformin},\n    comparator='Metformin',\n)\n\n# Display ICER\nicer_val = cea['icer']['ICER'].iloc[0]\nprint(f'ICER: ${icer_val:,.0f} per QALY')\nprint(f'Incremental QALYs: {cea[\"icer\"][\"Incremental QALYs\"].iloc[0]:.2f}')\nprint(f'Incremental Cost:  ${cea[\"icer\"][\"Incremental Cost\"].iloc[0]:,.0f}')\n</code></pre> <p>Example Output: <pre><code>ICER: $50,249 per QALY\nIncremental QALYs: 1.48\nIncremental Cost:  $74,369\n</code></pre></p>"},{"location":"user-guide/health-economics-tutorial/#interpreting-the-icer","title":"Interpreting the ICER","text":"<p>ICER Formula: <pre><code>ICER = (Cost_GLP1 - Cost_Metformin) / (QALY_GLP1 - QALY_Metformin)\n     = $74,369 / 1.48 QALYs\n     = $50,249 per QALY\n</code></pre></p> <p>Compare against international thresholds:</p> Jurisdiction Threshold Decision NICE (UK) \u00a320K-\u00a330K/QALY (~\\(25K-\\)38K USD) \u2717 Not cost-effective CADTH (Canada) ~\\(50K CAD/QALY (~\\)37K USD) \u2717 Borderline US (lower) $50K/QALY \u2713 Cost-effective US (mid) $100K/QALY \u2713\u2713 Highly cost-effective <p>Decision: GLP-1 agonists are cost-effective in the US but may not be approved in UK/Canada at current prices.</p>"},{"location":"user-guide/health-economics-tutorial/#step-4-quantify-decision-uncertainty","title":"Step 4: Quantify Decision Uncertainty","text":"<p>ICER gives a point estimate but hides uncertainty. Use the Cost-Effectiveness Acceptability Curve (CEAC) to show the probability of cost-effectiveness at different WTP thresholds.</p> <pre><code># Extract CEAC probabilities at key thresholds\nceac = cea['ceac']\nceac_glp1 = ceac['GLP-1 Agonist']\n\nprint('Probability GLP-1 is Cost-Effective:')\nprint(f'  At $25K/QALY (NICE UK):     {ceac_glp1[25_000]:.1%}')\nprint(f'  At $37K/QALY (CADTH Canada): {ceac_glp1[37_000]:.1%}')\nprint(f'  At $50K/QALY (US lower):     {ceac_glp1[50_000]:.1%}')\nprint(f'  At $100K/QALY (US mid):      {ceac_glp1[100_000]:.1%}')\n</code></pre> <p>Example Output: <pre><code>Probability GLP-1 is Cost-Effective:\n  At $25K/QALY (NICE UK):     23.4%\n  At $37K/QALY (CADTH Canada): 47.8%\n  At $50K/QALY (US lower):     72.1%\n  At $100K/QALY (US mid):      98.3%\n</code></pre></p> <p>Interpretation: - At NICE threshold (\\(25K/QALY): Only 23% chance GLP-1 is cost-effective \u2192 **Don't approve** - At US lower threshold (\\)50K/QALY): 72% chance cost-effective \u2192 Likely approve - At US mid threshold ($100K/QALY): 98% chance cost-effective \u2192 Definitely approve</p> <p>Why uncertainty matters: Decision changes from 23% to 98% depending on WTP threshold. Probabilistic analysis reveals this sensitivity.</p>"},{"location":"user-guide/health-economics-tutorial/#step-5-visualize-the-cost-effectiveness-plane","title":"Step 5: Visualize the Cost-Effectiveness Plane","text":"<p>The CE plane shows joint uncertainty in incremental costs and QALYs.</p> <pre><code>import plotly.graph_objects as go\n\nplane = cea['ce_plane']['GLP-1 Agonist']\n\nfig = go.Figure()\n\n# Scatter plot of 10,000 simulations\nfig.add_trace(go.Scatter(\n    x=plane['Delta QALYs'],\n    y=plane['Delta Cost'],\n    mode='markers',\n    marker=dict(size=2, opacity=0.2, color='blue'),\n    name='Simulations',\n))\n\n# Add WTP threshold lines\nx_range = [plane['Delta QALYs'].min(), plane['Delta QALYs'].max()]\nfig.add_trace(go.Scatter(\n    x=x_range, y=[x * 50_000 for x in x_range],\n    mode='lines', line=dict(dash='dash', color='orange'),\n    name='US Lower: $50K/QALY',\n))\n\nfig.add_hline(y=0, line_dash='dot', line_color='gray')\nfig.add_vline(x=0, line_dash='dot', line_color='gray')\n\nfig.update_layout(\n    title='Cost-Effectiveness Plane',\n    xaxis_title='Incremental QALYs',\n    yaxis_title='Incremental Cost ($)',\n    template='plotly_white',\n)\nfig.show()\n</code></pre> <p>Quadrants: - NE (North-East): More effective, more costly \u2192 Trade-off (most points here) - SE (South-East): More effective, less costly \u2192 Dominant (always adopt) - NW (North-West): Less effective, more costly \u2192 Dominated (never adopt) - SW (South-West): Less effective, less costly \u2192 Rare</p> <p>Result: Nearly all simulations in NE quadrant means decision depends on WTP threshold.</p>"},{"location":"user-guide/health-economics-tutorial/#step-6-calculate-net-monetary-benefit-nmb","title":"Step 6: Calculate Net Monetary Benefit (NMB)","text":"<p>NMB converts health gains to monetary terms for easier interpretation.</p> <pre><code># NMB at $100K/QALY threshold\nwtp = 100_000\nnmb = cea['nmb']\n\nprint(f'Net Monetary Benefit at ${wtp:,}/QALY threshold:')\nprint(f'  Metformin:     ${nmb.loc[wtp, \"Metformin\"]:,.0f}')\nprint(f'  GLP-1 Agonist: ${nmb.loc[wtp, \"GLP-1 Agonist\"]:,.0f}')\n</code></pre> <p>Example Output: <pre><code>Net Monetary Benefit at $100,000/QALY threshold:\n  Metformin:     $919,124\n  GLP-1 Agonist: $992,856\n</code></pre></p> <p>NMB Formula: <pre><code>NMB = WTP \u00d7 QALYs - Cost\n</code></pre></p> <p>Interpretation: - At \\(100K/QALY, GLP-1 has higher NMB (\\)992K vs. $919K) - Decision: Choose GLP-1 (higher NMB = more valuable) - NMB difference: $73,732 (value gained from switching to GLP-1)</p>"},{"location":"user-guide/health-economics-tutorial/#step-7-make-clinical-and-policy-decisions","title":"Step 7: Make Clinical and Policy Decisions","text":""},{"location":"user-guide/health-economics-tutorial/#for-healthcare-payers","title":"For Healthcare Payers","text":"<p>UK (NICE): <pre><code>if icer_val &lt; 25_000:\n    print('Decision: Approve for NHS formulary')\nelif icer_val &lt; 38_000:\n    print('Decision: Negotiate price reduction or restrict to high-risk patients')\nelse:\n    print('Decision: Reject at current price')\n</code></pre></p> <p>Canada (CADTH): <pre><code>if icer_val &lt; 37_000:\n    print('Decision: Recommend for provincial formularies')\nelif icer_val &lt; 75_000:\n    print('Decision: Conditional recommendation (price negotiation)')\nelse:\n    print('Decision: Not recommended')\n</code></pre></p> <p>US Payers: <pre><code>if icer_val &lt; 50_000:\n    print('Decision: Include on preferred formulary tier (low copay)')\nelif icer_val &lt; 150_000:\n    print('Decision: Include on non-preferred tier (higher copay)')\nelse:\n    print('Decision: Exclude or require prior authorization')\n</code></pre></p>"},{"location":"user-guide/health-economics-tutorial/#for-clinicians","title":"For Clinicians","text":"<p>Shared Decision-Making: <pre><code># Check individual patient factors\nhigh_cv_risk = True  # Patient has cardiovascular risk factors\nhigh_hba1c = True    # Poor glycemic control (HbA1c &gt;8%)\ncan_afford = True    # Insurance covers or patient can afford copay\n\nif high_cv_risk and high_hba1c and can_afford:\n    print('Recommendation: Consider GLP-1 agonist (higher benefit)')\nelif not can_afford:\n    print('Recommendation: Metformin (financial barrier to GLP-1)')\nelse:\n    print('Recommendation: Start with metformin, escalate if needed')\n</code></pre></p> <p>Population Health: - High-risk patients: GLP-1 (CV benefits justify cost) - Low-risk patients: Metformin (cost-effective first-line) - Resource stewardship: Tiered approach maximizes population health under budget constraint</p>"},{"location":"user-guide/health-economics-tutorial/#advanced-treatment-schedule-optimization","title":"Advanced: Treatment Schedule Optimization","text":"<p>Find the optimal dosing regimen to maximize Net Monetary Benefit.</p> <pre><code>from finbot.services.health_economics.treatment_optimizer import optimize_treatment\n\n# Optimize dose frequency and duration\nresults = optimize_treatment(\n    cost_per_dose=800.0,\n    cost_per_dose_std=100.0,\n    qaly_gain_per_dose=0.015,\n    qaly_gain_per_dose_std=0.003,\n    frequencies=[1, 2, 4, 12, 26, 52],  # doses per year\n    durations=[1, 2, 3, 5, 10, 15],     # years of treatment\n    baseline_utility=0.65,\n    baseline_mortality=0.03,\n    wtp_threshold=100_000,\n    n_sims=5000,\n    seed=42,\n)\n\n# Show top 5 schedules\nprint('Top 5 Treatment Schedules by NMB:')\ntop5 = results.head()\nfor _, row in top5.iterrows():\n    print(f'  {int(row[\"Frequency\"]):&gt;2} doses/yr \u00d7 {int(row[\"Duration\"]):&gt;2} yr  |  '\n          f'ICER: ${row[\"ICER\"]:&gt;10,.0f}/QALY  |  NMB: ${row[\"NMB\"]:&gt;10,.0f}')\n</code></pre> <p>Example Output: <pre><code>Top 5 Treatment Schedules by NMB:\n  12 doses/yr \u00d7 15 yr  |  ICER: $45,234/QALY  |  NMB: $142,567\n  12 doses/yr \u00d7 10 yr  |  ICER: $46,891/QALY  |  NMB: $138,234\n  26 doses/yr \u00d7 10 yr  |  ICER: $52,145/QALY  |  NMB: $135,789\n  ...\n</code></pre></p> <p>Interpretation: Monthly dosing (12/year) for 15 years maximizes NMB at $100K/QALY threshold.</p>"},{"location":"user-guide/health-economics-tutorial/#interpreting-results-for-different-audiences","title":"Interpreting Results for Different Audiences","text":""},{"location":"user-guide/health-economics-tutorial/#for-clinicians_1","title":"For Clinicians","text":"<p>Key Message: \"GLP-1 agonists provide 1.5 additional years of quality-adjusted life at a cost of ~$50,000 per QALY gained compared to metformin. This is considered cost-effective in the US (where thresholds are \\(50K-\\)150K/QALY) but may not be approved in countries like the UK where thresholds are lower (~$25K/QALY).\"</p> <p>Clinical Implication: Use GLP-1 for high-risk patients where benefit is greatest, metformin for lower-risk patients where cost-effectiveness is marginal.</p>"},{"location":"user-guide/health-economics-tutorial/#for-policymakers","title":"For Policymakers","text":"<p>Key Message: \"At current prices, GLP-1 agonists have an ICER of ~$50K/QALY. This exceeds NICE (UK) thresholds but falls within US acceptable ranges. Price negotiations could bring ICER below \u00a320K/QALY for UK approval.\"</p> <p>Policy Implication: Consider tiered formularies, negotiate rebates, or restrict to high-risk subgroups to improve cost-effectiveness.</p>"},{"location":"user-guide/health-economics-tutorial/#for-patients","title":"For Patients","text":"<p>Key Message: \"GLP-1 medications are newer, more expensive diabetes drugs that provide better blood sugar control and weight loss compared to metformin. Whether they're worth the extra cost depends on your insurance coverage and personal health situation. Your doctor can help you decide.\"</p> <p>Shared Decision: Discuss out-of-pocket costs, expected benefits, and personal values in consultation with physician.</p>"},{"location":"user-guide/health-economics-tutorial/#limitations-and-cautions","title":"Limitations and Cautions","text":""},{"location":"user-guide/health-economics-tutorial/#model-limitations","title":"Model Limitations","text":"<pre><code># What the model DOES capture:\n# \u2713 Cost uncertainty from price variability\n# \u2713 Efficacy uncertainty from clinical trial confidence intervals\n# \u2713 Mortality and quality-of-life trade-offs\n# \u2713 Time discounting (3% per WHO/NICE guidelines)\n\n# What the model DOES NOT capture:\n# \u2717 Disease progression states (e.g., complications like retinopathy, neuropathy)\n# \u2717 Treatment switching (e.g., metformin \u2192 GLP-1 if HbA1c not controlled)\n# \u2717 Real-world adherence (assumes 100% compliance, reality ~50-70%)\n# \u2717 Heterogeneity (all patients treated identically)\n</code></pre>"},{"location":"user-guide/health-economics-tutorial/#appropriate-uses","title":"Appropriate Uses","text":"<p>\u2713 Good Uses: - Exploring cost-effectiveness trade-offs between treatments - Identifying which patients benefit most (high-risk vs. low-risk) - Estimating population-level budget impact - Supporting formulary and clinical guideline decisions - Pedagogical demonstrations for teaching health economics</p> <p>\u2717 Bad Uses: - Sole basis for individual treatment decisions (clinical judgment required) - Assuming simulated outcomes will match real-world results exactly - Ignoring patient preferences, values, and financial circumstances - Treating ICERs as precise rather than estimates with uncertainty</p>"},{"location":"user-guide/health-economics-tutorial/#further-reading","title":"Further Reading","text":"<p>Methodology: - Health Economics Methodology - Full mathematical details, validation, 22 academic references</p> <p>Examples: - Health Economics Notebook - Interactive Jupyter notebook with visualizations</p> <p>Guidelines: - NICE Methods Guide: nice.org.uk/process/pmg9 - CADTH Guidelines: cadth.ca/guidelines - WHO CHOICE: who.int/choice - Second Panel Report (JAMA): Sanders GD, et al. JAMA 316.10 (2016): 1093-1103</p> <p>Academic Texts: - Drummond MF, et al. Methods for the Economic Evaluation of Health Care Programmes, 4th ed. Oxford, 2015. - Briggs AH, et al. Decision Modelling for Health Economic Evaluation. Oxford, 2006.</p>"},{"location":"user-guide/health-economics-tutorial/#summary","title":"Summary","text":"<p>You've learned to:</p> <ol> <li>\u2713 Define health interventions with cost and efficacy parameters</li> <li>\u2713 Run Monte Carlo simulations to capture uncertainty</li> <li>\u2713 Calculate ICER, NMB, and CEAC using standard methods</li> <li>\u2713 Interpret results against international thresholds (NICE/CADTH/WHO/US)</li> <li>\u2713 Make evidence-based clinical and policy decisions</li> <li>\u2713 Optimize treatment schedules to maximize value</li> </ol> <p>Key Takeaway: Cost-effectiveness analysis provides a rigorous framework for balancing health benefits against costs, but results are jurisdiction-dependent (different countries have different WTP thresholds) and should inform\u2014not replace\u2014clinical judgment.</p> <p>Next Steps: - Explore the methodology document for theoretical foundations - Run the Jupyter notebook for hands-on practice - Apply to your own clinical scenarios by modifying intervention parameters - Consider subgroup analysis (age, risk level, comorbidities) for more nuanced decisions</p> <p>Last Updated: 2026-02-12 Feedback: Open an issue on GitHub or contribute improvements via PR.</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>Detailed installation instructions for Finbot.</p>"},{"location":"user-guide/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: &gt;=3.11, &lt;3.15</li> <li>Operating System: Linux, macOS, or Windows (WSL recommended)</li> <li>Memory: 4GB RAM minimum, 8GB recommended</li> <li>Disk Space: 2GB for installation + data storage</li> </ul>"},{"location":"user-guide/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"user-guide/installation/#method-1-uv-recommended","title":"Method 1: uv (Recommended)","text":"<p>uv provides fast, reliable dependency management and environment isolation:</p> <pre><code># Install uv if not already installed\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Install dependencies (creates .venv automatically)\nuv sync\n\n# Activate environment (optional, but recommended)\nsource .venv/bin/activate  # On Linux/Mac\n.venv\\Scripts\\activate     # On Windows\n\n# Verify installation\nfinbot --version\npython -c \"import finbot; print('Success!')\"\n</code></pre>"},{"location":"user-guide/installation/#method-2-pip-with-venv","title":"Method 2: pip with venv","text":"<p>Standard Python virtual environment approach:</p> <pre><code># Clone repository\ngit clone https://github.com/jerdaw/finbot.git\ncd finbot\n\n# Create virtual environment\npython3 -m venv venv\n\n# Activate (Linux/Mac)\nsource venv/bin/activate\n\n# Activate (Windows)\nvenv\\Scripts\\activate\n\n# Install package\npip install -e .\n\n# Verify\nfinbot --version\n</code></pre>"},{"location":"user-guide/installation/#post-installation","title":"Post-Installation","text":""},{"location":"user-guide/installation/#configure-environment","title":"Configure Environment","text":"<pre><code># Set environment variable\nexport DYNACONF_ENV=development  # or production\n\n# Add to ~/.bashrc or ~/.zshrc for persistence\necho 'export DYNACONF_ENV=development' &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"user-guide/installation/#install-optional-dependencies","title":"Install Optional Dependencies","text":"<p>For development:</p> <pre><code>uv sync\n</code></pre> <p>For documentation building:</p> <pre><code>uv sync\n</code></pre>"},{"location":"user-guide/installation/#verify-installation","title":"Verify Installation","text":"<p>Run the test suite:</p> <pre><code>uv run pytest -v\n</code></pre> <p>Expected: All 80 tests pass.</p>"},{"location":"user-guide/installation/#troubleshooting","title":"Troubleshooting","text":"<p>See Getting Started - Common Issues for help with installation problems.</p>"},{"location":"user-guide/quick-start/","title":"Quick Start","text":"<p>This guide provides a rapid walkthrough of Finbot's core features.</p>"},{"location":"user-guide/quick-start/#5-minute-quick-start","title":"5-Minute Quick Start","text":""},{"location":"user-guide/quick-start/#1-simulate-a-fund","title":"1. Simulate a Fund","text":"<pre><code># Simulate UPRO (3x leveraged S&amp;P 500)\nfinbot simulate --fund UPRO --start 2010-01-01 --plot\n</code></pre>"},{"location":"user-guide/quick-start/#2-backtest-a-strategy","title":"2. Backtest a Strategy","text":"<pre><code># Test 60/40 rebalancing strategy\nfinbot backtest --strategy Rebalance --asset SPY,TLT --plot\n</code></pre>"},{"location":"user-guide/quick-start/#3-optimize-allocation","title":"3. Optimize Allocation","text":"<pre><code># Find optimal SPY/TLT ratio\nfinbot optimize --method dca --assets SPY,TLT --plot\n</code></pre>"},{"location":"user-guide/quick-start/#detailed-workflows","title":"Detailed Workflows","text":"<p>See Getting Started for comprehensive documentation.</p>"}]}